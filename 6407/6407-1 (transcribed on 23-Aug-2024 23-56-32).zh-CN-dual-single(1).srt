1
00:03:30,000 --> 00:03:32,000
 .
。

2
00:06:30,000 --> 00:06:50,000
 Okay. Hello.
好的。你好。

3
00:06:50,000 --> 00:06:55,000
 First week of school, right?
开学第一周，对吗？

4
00:06:55,000 --> 00:06:57,000
 So how do you all feel?
那么大家感觉如何呢？

5
00:06:57,000 --> 00:06:59,000
 All geared up, right?
一切都准备好了，对吧？

6
00:06:59,000 --> 00:07:01,000
 You start the semester.
你开始新学期。

7
00:07:01,000 --> 00:07:03,000
 Okay.
好的。

8
00:07:03,000 --> 00:07:05,000
 First of all, let's...
首先，让我们...

9
00:07:05,000 --> 00:07:09,000
 Can you hear me from the back?
你能从后面听到我说话吗？

10
00:07:09,000 --> 00:07:17,000
 No?
不？

11
00:07:17,000 --> 00:07:22,000
 The microphone.
麦克风。

12
00:07:22,000 --> 00:07:24,000
 Okay, this is probably as near as it's going to get.
好吧，这可能已经是最接近的了。

13
00:07:24,000 --> 00:07:26,000
 Can you hear me?
你能听到我吗？

14
00:07:26,000 --> 00:07:27,000
 Is that all right?
这样可以吗？

15
00:07:27,000 --> 00:07:33,000
 All the way to the back, can you hear?
一直到后面，你能听到吗？

16
00:07:33,000 --> 00:07:35,000
 You know, I ever had this experience.
你知道，我曾经有过这样的经历。

17
00:07:35,000 --> 00:07:37,000
 You know, after I finished the class, somebody told me,
你知道，我上完课后，有人告诉我，

18
00:07:37,000 --> 00:07:41,000
 you know, all along I couldn't hear you, you know.
你知道，我一直听不到你说话，你知道。

19
00:07:41,000 --> 00:07:45,000
 I say, oh gee, you know, thanks for telling me.
我说，哦天哪，你知道，谢谢你告诉我。

20
00:07:45,000 --> 00:07:46,000
 Right?
正确的？

21
00:07:46,000 --> 00:07:49,000
 So I have to make sure you can hear me right at the end.
所以我必须确保你能在最后听到我的声音。

22
00:07:49,000 --> 00:07:51,000
 Okay. Thank you.
好的。谢谢。

23
00:07:51,000 --> 00:07:53,000
 Okay.
好的。

24
00:07:53,000 --> 00:07:55,000
 Are you in the right class?
你在正确的班级吗？

25
00:07:55,000 --> 00:07:57,000
 I hope so, right?
我希望如此，对吧？

26
00:07:57,000 --> 00:07:58,000
 Okay.
好的。

27
00:07:58,000 --> 00:08:01,000
 So I'm pretty sure I'm in the right class.
所以我很确定我在正确的班级。

28
00:08:01,000 --> 00:08:06,000
 So this is EE6407, right?
这是 EE6407，对吧？

29
00:08:06,000 --> 00:08:09,000
 And my name is Lim, right?
我叫林，对吧？

30
00:08:09,000 --> 00:08:11,000
 I'm Prof Lim, Lim Ming-hyot.
我是林明孝教授。

31
00:08:11,000 --> 00:08:13,000
 I'm in the School of EEE.
我在EEE学院。

32
00:08:13,000 --> 00:08:16,000
 So my office is stated there,
所以我的办公室就在那里，

33
00:08:16,000 --> 00:08:22,000
 but you can connect with me to email, right?
但你可以通过电子邮件与我联系，对吗？

34
00:08:23,000 --> 00:08:28,000
 Connecting by email doesn't guarantee an immediate reply.
通过电子邮件连接并不能保证立即得到回复。

35
00:08:28,000 --> 00:08:29,000
 Okay.
好的。

36
00:08:29,000 --> 00:08:31,000
 There will be times where I miss out your email.
有时我会错过你的电子邮件。

37
00:08:31,000 --> 00:08:35,000
 So if you don't hear anything, drop me a gentle reminder.
因此，如果您没有听到任何声音，请给我一个温柔的提醒。

38
00:08:35,000 --> 00:08:40,000
 Just say there, I send you an email, right, about such and such.
就说那里，我给你发了一封电子邮件，对吧，关于这样那样的事情。

39
00:08:40,000 --> 00:08:42,000
 Did you have time to look at it?
你有时间看一下吗？

40
00:08:42,000 --> 00:08:44,000
 You know, things like that.
你知道，诸如此类的事情。

41
00:08:44,000 --> 00:08:45,000
 Okay.
好的。

42
00:08:45,000 --> 00:08:50,000
 And I think you know why, because these days we tend to be
我想你知道为什么，因为现在我们倾向于

43
00:08:50,000 --> 00:08:54,000
 overwhelmed by emails, right?
被电子邮件淹没了，对吗？

44
00:08:54,000 --> 00:08:58,000
 So try and be understanding on that count.
因此，请尝试理解这一点。

45
00:08:58,000 --> 00:09:00,000
 So email is good.
所以电子邮件是好的。

46
00:09:00,000 --> 00:09:05,000
 I'll do my best to handle or manage the email.
我会尽力处理或管理该电子邮件。

47
00:09:05,000 --> 00:09:08,000
 So the title of this subject, this course, is
所以这个主题、这个课程的标题是

48
00:09:08,000 --> 00:09:12,000
 Genetic Algorithms and Machine Learnings, right?
遗传算法和机器学习，对吧？

49
00:09:12,000 --> 00:09:16,000
 Now before we go any further, it always makes sense to try
现在，在我们进一步讨论之前，尝试一下总是有意义的

50
00:09:17,000 --> 00:09:23,000
 and understand, you know, in a very broad sense, the title.
并从广义上理解标题。

51
00:09:23,000 --> 00:09:28,000
 So one of the questions that probably occurred to you would be,
所以你可能想到的问题之一是，

52
00:09:28,000 --> 00:09:32,000
 okay, look, you know, there's this genetic algorithm here,
好吧，看，你知道，这里有遗传算法，

53
00:09:32,000 --> 00:09:34,000
 and then machine learning.
然后是机器学习。

54
00:09:34,000 --> 00:09:36,000
 Is it really connected?
真的有联系吗？

55
00:09:39,000 --> 00:09:44,000
 These days, recently, I attended this conference on Artificial Intelligence.
这几天，最近，我参加了这个人工智能的会议。

56
00:09:44,000 --> 00:09:49,000
 You can sense the euphoria of artificial intelligence.
你可以感受到人工智能带来的欣快感。

57
00:09:49,000 --> 00:09:51,000
 There were so many people attending.
参加的人真多。

58
00:09:51,000 --> 00:09:55,000
 Everybody's talking about AI, what they can do, and so on.
每个人都在谈论人工智能、它们能做什么等等。

59
00:09:55,000 --> 00:09:57,000
 Okay.
好的。

60
00:09:57,000 --> 00:10:01,000
 So really, when you think about AI, the term machine learning comes
所以说真的，当你想到人工智能时，机器学习这个词就会出现

61
00:10:01,000 --> 00:10:03,000
 into the mind.
进入头脑。

62
00:10:03,000 --> 00:10:06,000
 It's all about learning, correct?
一切都是为了学习，对吗？

63
00:10:06,000 --> 00:10:10,000
 Now on that basis or on that denominator learning, right,
现在在此基础上或在分母学习上，对吧，

64
00:10:10,000 --> 00:10:15,000
 that's why you can link the two genetic algorithms into machine
这就是为什么你可以将两种遗传算法链接到机器中

65
00:10:15,000 --> 00:10:20,000
 as one of the methods of machine learning, right?
作为机器学习的方法之一，对吧？

66
00:10:20,000 --> 00:10:24,000
 So there's no doubt that you can put GA as one of the methods in AI,
所以毫无疑问你可以把GA作为AI中的方法之一，

67
00:10:24,000 --> 00:10:26,000
 if you may, right?
如果可以的话，对吗？

68
00:10:26,000 --> 00:10:30,000
 So later on, as you understand the genetic algorithm mechanisms
所以稍后，当你了解遗传算法机制时

69
00:10:30,000 --> 00:10:33,000
 a little bit more, then you begin to see, you know,
再多一点，然后你就会开始看到，你知道，

70
00:10:33,000 --> 00:10:39,000
 where the aspects of learning comes about.
学习的各个方面发生的地方。

71
00:10:39,000 --> 00:10:41,000
 GA is good, right?
GA 很好，对吧？

72
00:10:41,000 --> 00:10:43,000
 But it's not good for everything.
但这并不代表一切都好。

73
00:10:43,000 --> 00:10:47,000
 Just like machine learning may not be good for everything, right?
就像机器学习可能并不适合所有事情，对吧？

74
00:10:47,000 --> 00:10:50,000
 So sometimes maybe we overdo it.
所以有时候我们可能做得太过分了。

75
00:10:50,000 --> 00:10:53,000
 So same thing with GA also, right?
GA 也同样如此，对吧？

76
00:10:53,000 --> 00:10:58,000
 So as the term implies, you begin to wonder how did it come about?
因此，正如该术语所暗示的那样，您开始想知道它是如何产生的？

77
00:10:58,000 --> 00:11:06,000
 The word genetic probably has some natural so-called association with nature,
遗传这个词可能与自然有某种所谓的自然联系，

78
00:11:06,000 --> 00:11:10,000
 and we will see why, you know, that is the case, right?
我们会明白为什么会出现这种情况，对吗？

79
00:11:10,000 --> 00:11:13,000
 So you have the term genetic algorithm.
所以就有了遗传算法这个术语。

80
00:11:13,000 --> 00:11:17,000
 So it's good to have an understanding of the background,
所以了解一下背景是有好处的

81
00:11:17,000 --> 00:11:19,000
 how this comes about, and so on, right?
这是怎么回事，等等吧？

82
00:11:19,000 --> 00:11:23,000
 So certainly without any doubt, it's very closely linked.
因此，毫无疑问，它们之间的联系非常紧密。

83
00:11:23,000 --> 00:11:26,000
 It's just another method or approach.
这只是另一种方法或途径。

84
00:11:26,000 --> 00:11:32,000
 It's not one of the two in your bag that allows you to solve different types of problems, okay?
它不是你包里的两个可以让你解决不同类型问题的之一，好吗？

85
00:11:32,000 --> 00:11:42,000
 So that is the basis of this course here.
这就是本课程的基础。

86
00:11:42,000 --> 00:11:51,000
 I think it is reasonable to assume that you will be concerned about how your grades
我认为有理由假设您会关心自己的成绩

87
00:11:51,000 --> 00:11:54,000
 is going to be determined, right?
即将确定，对吗？

88
00:11:54,000 --> 00:12:01,000
 And of course exam is part and parcel of the evaluation process.
当然，考试是评估过程的重要组成部分。

89
00:12:01,000 --> 00:12:06,000
 So the final exam is a three-hour exam.
所以期末考试是三个小时的考试。

90
00:12:06,000 --> 00:12:12,000
 It constitutes 60% of the grade.
占成绩的60%。

91
00:12:12,000 --> 00:12:16,000
 So because I take only three weeks, I will say roughly one quarter,
因为我只花了三个星期，所以我会说大约四分之一，

92
00:12:16,000 --> 00:12:19,000
 so I'll contribute one question.
所以我会提出一个问题。

93
00:12:19,000 --> 00:12:23,000
 I leave it to you to decide whether it's significant or not.
我让你来决定它是否重要。

94
00:12:23,000 --> 00:12:29,000
 If you feel that 25% is not so significant, you can put less emphasis.
如果你觉得25%不是那么重要，你可以少强调一点。

95
00:12:29,000 --> 00:12:33,000
 But nevertheless, that is what it is, 25%.
但无论如何，事实就是如此，25%。

96
00:12:33,000 --> 00:12:36,000
 So one of the questions.
所以问题之一。

97
00:12:36,000 --> 00:12:40,000
 Now continuous assessment is also part of it.
现在持续评估也是其中的一部分。

98
00:12:40,000 --> 00:12:50,000
 So continuous assessment consists of usually homework assignment as well as quiz.
因此，持续评估通常包括家庭作业和测验。

99
00:12:50,000 --> 00:12:55,000
 So for now, for this semester, I'm just going to do with quiz.
所以现在，这个学期，我只会进行测验。

100
00:12:55,000 --> 00:12:59,000
 There won't be any homework assignment.
不会有任何家庭作业。

101
00:12:59,000 --> 00:13:03,000
 I'm not sure you see that as good or bad.
我不确定你认为这是好是坏。

102
00:13:03,000 --> 00:13:06,000
 You may shout, hey, no homework.
你可能会大喊，嘿，没有作业。

103
00:13:06,000 --> 00:13:08,000
 So nice.
真好。

104
00:13:08,000 --> 00:13:10,000
 But don't be too comfortable, right?
但别太舒服了，对吧？

105
00:13:10,000 --> 00:13:12,000
 No homework whatsoever.
没有任何作业。

106
00:13:12,000 --> 00:13:17,000
 Perhaps what it means is that you've got to use your own initiative to practice.
也许这意味着你必须用你自己的主动性去练习。

107
00:13:17,000 --> 00:13:23,000
 Go and look for questions or problems and discuss.
去寻找疑问或问题并进行讨论。

108
00:13:23,000 --> 00:13:26,000
 So there's no homework assignment, but this is a quiz.
所以没有家庭作业，但这是一个测验。

109
00:13:26,000 --> 00:13:32,000
 So the quiz I will conduct because I have three weeks of lesson.
所以我将进行测验，因为我有三周的课程。

110
00:13:32,000 --> 00:13:35,000
 So I'll conduct on the third week.
所以我将在第三周进行。

111
00:13:35,000 --> 00:13:41,000
 So this is week one, and then next week, and then the final week.
这是第一周，然后是下周，然后是最后一周。

112
00:13:41,000 --> 00:13:43,000
 So there's week three.
那么第三周就到了。

113
00:13:43,000 --> 00:13:48,000
 It will be around 15 minutes.
大约需要 15 分钟。

114
00:13:48,000 --> 00:13:52,000
 The venue, I will let you know where the venue is.
地点，我会告诉你地点在哪里。

115
00:13:52,000 --> 00:13:57,000
 It won't be in this LT because there's a bigger group.
它不会出现在这个 LT 中，因为有一个更大的组。

116
00:13:57,000 --> 00:14:01,000
 There's another group that needs to take the quiz or so.
还有另一组需要参加测验等等。

117
00:14:01,000 --> 00:14:13,000
 Timing wise, it will be the second half of the lecture towards the last hour of the lecture.
从时间上来说，这将是讲座的后半部分，接近讲座的最后一个小时。

118
00:14:13,000 --> 00:14:14,000
 Clear?
清除？

119
00:14:14,000 --> 00:14:16,000
 That's how we're going to do the assessment.
这就是我们要进行评估的方式。

120
00:14:16,000 --> 00:14:18,000
 All right?
好的？

121
00:14:18,000 --> 00:14:33,000
 So let's go to the term, let's begin by talking about genetic algorithm or evolutionary computing.
那么让我们开始讨论这个术语，让我们首先讨论遗传算法或进化计算。

122
00:14:33,000 --> 00:14:42,000
 So the term evolutionary computing, computing you know, computers.
所以术语进化计算，你知道的计算，计算机。

123
00:14:42,000 --> 00:14:47,000
 Evolutionary, there are two meanings to it.
进化论，有两层含义。

124
00:14:47,000 --> 00:14:57,000
 If you look within the context of nature, all right, then so-called evolutionary process in nature comes to mind.
如果你在自然的背景下观察，好吧，那么自然中所谓的进化过程就会浮现在脑海中。

125
00:14:57,000 --> 00:15:05,000
 For example, how species evolve with time, you know, how it adapts to environment.
例如，物种如何随时间进化，你知道，它如何适应环境。

126
00:15:05,000 --> 00:15:10,000
 So there is a meaning of so-called evolution.
所以就有了所谓进化的意义。

127
00:15:10,000 --> 00:15:16,000
 Now the other angle of it, you can look at evolution in a very generic sense, right?
现在从另一个角度来看，你可以从一个非常普遍的意义上来看待进化，对吗？

128
00:15:16,000 --> 00:15:26,000
 In a sense that for example, you know, I could say things like, oh gee, you know, I've known you since like 20 years ago.
从某种意义上说，例如，你知道，我可以说这样的话，哦天啊，你知道，我从 20 年前就认识你了。

129
00:15:26,000 --> 00:15:33,000
 Over the years I've seen, I'm amazed at how you evolve into a perfect gentleman.
在我所见的这些年里，我很惊讶你如何成长为一个完美的绅士。

130
00:15:33,000 --> 00:15:40,000
 So what that means is that it is so-called a gradual development or changes over time.
所以这就是所谓的随着时间的推移逐渐发展或变化的意思。

131
00:15:40,000 --> 00:15:49,000
 All right, so in that sense there are two angles as you can see the meaning of the word evolution.
好吧，从这个意义上来说，你可以从两个角度来理解“进化”这个词的含义。

132
00:15:49,000 --> 00:15:56,000
 All right, so when you put together evolutionary computing, all right, computing has to do with programs.
好吧，所以当你把进化计算放在一起时，好吧，计算与程序有关。

133
00:15:56,000 --> 00:16:02,000
 Okay, so basically when you link the two, all it means is that you're going to use a computer.
好吧，基本上，当你将两者联系起来时，就意味着你将使用计算机。

134
00:16:02,000 --> 00:16:09,000
 I'm meaning through your program, you're going to code it such that the approach will be somewhat synonymous
我的意思是通过你的程序，你将对其进行编码，以便该方法在某种程度上是同义的

135
00:16:09,000 --> 00:16:17,000
 to how evolution happens, the process of evolution.
进化是如何发生的，进化的过程。

136
00:16:17,000 --> 00:16:27,000
 Okay, so when we talk about genetic algorithm, all right, so in future, you don't have to, if we talk, we say genetic algorithm,
好的，所以当我们谈论遗传算法时，好吧，所以将来，你不必，如果我们谈论，我们说遗传算法，

137
00:16:27,000 --> 00:16:33,000
 we say evolutionary algorithm, evolutionary computing, we are basically talking about the same thing.
我们说进化算法、进化计算，我们基本上在谈论同一件事。

138
00:16:33,000 --> 00:16:40,000
 All right, later on I'll explain a little bit clearer why that is so.
好吧，稍后我会更清楚地解释为什么会这样。

139
00:16:40,000 --> 00:16:49,000
 So some of you may want to know or I have been asked a few times, is there a textbook?
你们中有些人可能想知道，或者我已经被问过几次了，有教科书吗？

140
00:16:49,000 --> 00:17:02,000
 So the textbook I use is, the textbook I use, let's just make sure I write it now.
所以我使用的教科书是我使用的教科书，让我们确保我现在就写它。

141
00:17:19,000 --> 00:17:46,000
 Okay, I use the textbook, the title, introduction to evolutionary computing.
好吧，我用课本，标题，进化计算导论。

142
00:17:46,000 --> 00:17:56,000
 So this book is authored by Iben and Jim Smith.
这本书的作者是伊本·史密斯和吉姆·史密斯。

143
00:17:56,000 --> 00:18:04,000
 Smith is a good friend, right, so I've asked him permission to say, gee, you know, I cannot get my students to buy any of this book.
史密斯是个好朋友，对吧，所以我请求他允许我说，哎呀，你知道，我不能让我的学生购买这本书。

144
00:18:04,000 --> 00:18:13,000
 He said it's perfectly all right, right, so the nice thing is that this is available online, right, you can download it and read it,
他说完全可以啊，所以好在这个是可以在网上看的，对吧，你可以下载看一下，

145
00:18:13,000 --> 00:18:18,000
 or you can go according to my lecture and try to understand the concepts, all right.
或者你可以按照我的讲座尝试理解其中的概念，好吧。

146
00:18:18,000 --> 00:18:30,000
 So the best is, hopefully through the lecture, it strikes a greater curiosity and you would read further from the textbook.
所以最好的是，希望通过讲座，它能够激发更大的好奇心，并且您可以进一步阅读教科书。

147
00:18:30,000 --> 00:18:42,000
 So it's available online, right, you go online, it is not something that I should freely send to you or anything like that.
所以它可以在网上找到，对吧，你上网，这不是我应该免费发送给你或类似的东西。

148
00:18:43,000 --> 00:19:05,000
 Okay, let's talk about, let's begin, right, by going into trying to understand the big picture of what we are trying to do, right.
好吧，让我们来谈谈，让我们开始，对吧，尝试理解我们正在尝试做的事情的大局，对吧。

149
00:19:05,000 --> 00:19:11,000
 So all of you are engineers, you know, what do you do?
所以你们都是工程师，你知道，你们是做什么的？

150
00:19:11,000 --> 00:19:23,000
 Basically you solve problems, right, whatever you do, be it a programmer, engineer, you're given a problem, you want to solve problems, right.
基本上你解决问题，对吧，无论你做什么，无论是程序员、工程师，你都会遇到问题，你想要解决问题，对吧。

151
00:19:23,000 --> 00:19:30,000
 So is it wrong to say that what we are doing is actually problem solving, all right.
那么说我们正在做的实际上是解决问题是不是错了，好吧。

152
00:19:30,000 --> 00:19:41,000
 Okay, so if you're doing problem solving, it only makes sense to try and understand the nature of the problem, all right, and I'm going to do exactly that.
好吧，如果你正在解决问题，那么只有尝试理解问题的本质才有意义，好吧，我会这么做。

153
00:19:41,000 --> 00:19:49,000
 So let's take a big picture look at how, what the problems entails, right, okay.
因此，让我们从大的角度来看看问题是如何发生的，会带来什么问题，对吧，好吧。

154
00:19:49,000 --> 00:19:58,000
 So we will classify the problems according to these four different categories.
因此，我们将根据这四个不同类别对问题进行分类。

155
00:19:58,000 --> 00:20:11,000
 One is the back box modeling and then the other is a search problem and third one is optimization versus constraint satisfaction.
一是后盒建模，二是搜索问题，三是优化与约束满足。

156
00:20:11,000 --> 00:20:19,000
 And the last one is an NP, NP stands for non-deterministic polynomial problems.
最后一个是NP，NP代表非确定性多项式问题。

157
00:20:19,000 --> 00:20:24,000
 Okay, let's try and understand what all this means.
好吧，让我们尝试理解这一切意味着什么。

158
00:20:29,000 --> 00:20:47,000
 You have a system, right, a system that you can very easily or simply be modeled as such.
你有一个系统，对吧，一个你可以非常容易地或简单地建模的系统。

159
00:20:47,000 --> 00:20:52,000
 You have your input, you have your output, and then you have the model, all right.
你有你的输入，你有你的输出，然后你就有了模型，好吧。

160
00:20:52,000 --> 00:21:03,000
 So the model is an encapsulation of the technique, the approaches on how you derive the output from your input.
因此，模型是技术的封装，是如何从输入导出输出的方法。

161
00:21:03,000 --> 00:21:07,000
 Okay, so essentially there are three components.
好的，基本上由三个组成部分组成。

162
00:21:07,000 --> 00:21:16,000
 You have your input, the model, and the output.
您有输入、模型和输出。

163
00:21:16,000 --> 00:21:22,000
 So depending on these three, right, what are we solving for?
那么，根据这三个因素，我们要解决什么问题？

164
00:21:22,000 --> 00:21:28,000
 Are we looking for the input? Are we looking for the model? Are we looking for the output?
我们正在寻找输入吗？我们正在寻找模型吗？我们在寻找输出吗？

165
00:21:28,000 --> 00:21:34,000
 That's the basis we're going to use to so-called categorize accordingly.
这就是我们将用来进行所谓相应分类的基础。

166
00:21:35,000 --> 00:21:48,000
 So the first thing we can do is take away the input.
所以我们能做的第一件事就是拿走输入。

167
00:21:48,000 --> 00:21:51,000
 The model and the desired output is known.
模型和所需的输出是已知的。

168
00:21:51,000 --> 00:21:55,000
 You know what the model, you know the output.
你知道模型是什么，你就知道输出。

169
00:21:55,000 --> 00:22:00,000
 What are you looking for? You're looking for the inputs.
你要买什么？您正在寻找输入。

170
00:22:00,000 --> 00:22:03,000
 Quite clear, okay, you're looking for the inputs.
非常清楚，好吧，您正在寻找输入。

171
00:22:03,000 --> 00:22:12,000
 So then we question, okay, what kind of problems falls into this category to illustrate what this means.
那么我们就问，好吧，什么样的问题属于这一类，以说明这意味着什么。

172
00:22:17,000 --> 00:22:22,000
 So some examples, the timetables.
一些例子，时间表。

173
00:22:22,000 --> 00:22:25,000
 Do you all have a timetable?
大家都有时间表吗？

174
00:22:26,000 --> 00:22:33,000
 Timetable tells you what time, the time, and the class that you have.
时间表告诉您什么时间、上课时间和班级。

175
00:22:33,000 --> 00:22:38,000
 So of course finally your timetable allows you to go through your whole program accordingly.
当然，最后你的时间表可以让你相应地完成整个计划。

176
00:22:38,000 --> 00:22:44,000
 But what's the process of scheduling this timetable?
但这个时间表的安排过程是怎样的呢？

177
00:22:46,000 --> 00:22:52,000
 So you'll be looking for a set of the inputs that fits the criteria.
因此，您将寻找一组符合条件的输入。

178
00:22:55,000 --> 00:23:03,000
 Design specifications, I have a certain specifications.
设计规范，我有一定的规范。

179
00:23:03,000 --> 00:23:10,000
 Give me the design that can fulfill this, satisfy these requirements or specifications.
给我可以实现这一点、满足这些要求或规格的设计。

180
00:23:13,000 --> 00:23:17,000
 TSB, the traveling salesman problem.
TSB，旅行商问题。

181
00:23:17,000 --> 00:23:20,000
 It's classical computer science problem.
这是经典的计算机科学问题。

182
00:23:20,000 --> 00:23:24,000
 That is known to be NP in nature.
这本质上是已知的 NP。

183
00:23:24,000 --> 00:23:32,000
 So basically the traveling salesman problem, if you talk about N-city traveling salesman problem,
所以基本上就是旅行商问题，如果你谈论N个城市的旅行商问题，

184
00:23:32,000 --> 00:23:36,000
 basically the problem can be formulated as such.
基本上这个问题可以这样表述。

185
00:23:36,000 --> 00:23:46,000
 There are N number of cities and the salesman is supposed to visit each and every city once and only once.
有 N 个城市，推销员应该访问每个城市一次且仅一次。

186
00:23:46,000 --> 00:23:51,000
 Such that the distance is minimized.
从而使距离最小化。

187
00:23:52,000 --> 00:24:00,000
 Then you begin to think about it, you know, looks like a toy problem or too simple a problem.
然后你开始思考它，你知道，看起来像一个玩具问题或一个太简单的问题。

188
00:24:00,000 --> 00:24:08,000
 But yet from a computational point of view, we still put it as a class that belongs to the NP problems.
但从计算的角度来看，我们仍然把它归为一类属于NP问题。

189
00:24:08,000 --> 00:24:13,000
 And you understand later what NP means or the significance of NP.
然后你就会明白NP是什么意思或者NP的意义。

190
00:24:13,000 --> 00:24:17,000
 And furthermore, this is a classical computer science problem.
此外，这是一个经典的计算机科学问题。

191
00:24:17,000 --> 00:24:28,000
 We started it because many real world practical problems can be transformed or mapped into the traveling salesman problem.
我们开始它是因为许多现实世界的实际问题可以转化或映射为旅行商问题。

192
00:24:28,000 --> 00:24:38,000
 Every day your logistics, the transportation logistics, very similar to the so-called the traveling salesman problem.
每天你的物流，运输物流，很类似于所谓的旅行商问题。

193
00:24:38,000 --> 00:24:42,000
 And many more examples.
还有更多的例子。

194
00:24:42,000 --> 00:24:50,000
 And I will use the eight queens quite a lot in this subject.
在这个主题中我会大量使用八皇后。

195
00:24:50,000 --> 00:24:55,000
 So the eight queens problem, very easy to understand.
所以八皇后问题，很容易理解。

196
00:24:55,000 --> 00:25:02,000
 I can spend one minute tell you and then you know what the eight queens problem is.
我可以花一分钟告诉你，然后你就知道八皇后问题是什么。

197
00:25:02,000 --> 00:25:11,000
 So let's take a look at some of these examples and talk a little bit more about each one of these.
因此，让我们看一下其中的一些示例，并进一步讨论其中的每一个。

198
00:25:12,000 --> 00:25:19,000
 Okay. Optimization. Let's take a look at timetable, right?
好的。优化。我们看一下时间表吧？

199
00:25:19,000 --> 00:25:26,000
 University timetable, huge search space, right?
大学时间表，搜索空间巨大吧？

200
00:25:26,000 --> 00:25:33,000
 So what are the things that you're trying to search for?
那么您想要寻找的东西是什么？

201
00:25:33,000 --> 00:25:38,000
 What are the constraints or requirements?
有什么限制或要求？

202
00:25:38,000 --> 00:25:44,000
 What are the resources that you have? Let's begin my next.
你有什么资源？让我们开始我的下一个吧。

203
00:25:44,000 --> 00:25:57,000
 The number of classrooms, all right, the physical venues. What else?
教室的数量，好吧，还有场地。还有什么？

204
00:25:57,000 --> 00:26:01,000
 The time slots. You have limited number of time slots.
时间段。您的时间段数量有限。

205
00:26:01,000 --> 00:26:10,000
 Correct? All right. And number of teachers, limited also.
正确的？好的。而教师的数量，也有限。

206
00:26:10,000 --> 00:26:17,000
 Or a few other constraints, the few other so-called resources available.
或者还有其他一些限制，以及其他一些所谓的可用资源。

207
00:26:17,000 --> 00:26:24,000
 So what do you understand by resources?
那么你理解的资源是什么？

208
00:26:24,000 --> 00:26:36,000
 That's what you have, right? Okay. We optimize because we have limited resources.
这就是你所拥有的，对吧？好的。我们进行优化是因为我们的资源有限。

209
00:26:36,000 --> 00:26:40,000
 If resources is enough, there's no worry. Okay.
如果资源足够，就不用担心。好的。

210
00:26:40,000 --> 00:26:47,000
 So the way you optimize because there's resources is limited, right?
所以你优化的方式是因为资源是有限的，对吧？

211
00:26:47,000 --> 00:26:52,000
 And therefore you want to make the most efficient use of the resources.
因此，您希望最有效地利用资源。

212
00:26:52,000 --> 00:26:59,000
 Okay. So you have all these resources, classrooms and so on, right?
好的。所以你拥有所有这些资源、教室等等，对吧？

213
00:26:59,000 --> 00:27:08,000
 Now, timetable must be good. Good is defined by a number of competing criteria, right?
现在，时间表一定很好。好是由许多相互竞争的标准来定义的，对吗？

214
00:27:08,000 --> 00:27:13,000
 And timetables must be feasible, right?
而且时间表必须是可行的，对吧？

215
00:27:13,000 --> 00:27:22,000
 Let's ask ourselves, what is the meaning? How do you define a good timetable?
我们问问自己，这句话的意义是什么？如何定义一个好的时间表？

216
00:27:22,000 --> 00:27:25,000
 A timetable must be feasible, right?
时间表一定是可行的吧？

217
00:27:25,000 --> 00:27:29,000
 Feasible means that it must be a workable timetable.
可行是指它必须是一个可行的时间表。

218
00:27:29,000 --> 00:27:35,000
 For example, you cannot have a timetable that makes you have two classes at the same time slot.
例如，您的时间表不能使您在同一时间段上两堂课。

219
00:27:35,000 --> 00:27:40,000
 That is not feasible. It's a timetable, but it's not a feasible timetable.
那是不可行的。这是一个时间表，但不是一个可行的时间表。

220
00:27:40,000 --> 00:27:47,000
 Or you cannot assign the same lecturer to teach in two classes at the same time.
或者您不能指派同一位讲师同时在两个班级授课。

221
00:27:47,000 --> 00:27:52,000
 So quite clearly, right, you know what the meaning of feasible.
那么很清楚了，对吧，你知道什么是可行的意思。

222
00:27:52,000 --> 00:27:57,000
 What about the different criteria?
不同的标准又如何呢？

223
00:27:57,000 --> 00:28:07,000
 So in order to understand this, you must distinguish between the hard and the soft criteria or constraints.
因此，为了理解这一点，您必须区分硬标准或软标准或约束。

224
00:28:07,000 --> 00:28:11,000
 Hard constraints must be satisfied.
必须满足硬约束。

225
00:28:11,000 --> 00:28:19,000
 Hard constraints is what makes a timetable feasible or infeasible.
硬约束决定了时间表可行或不可行。

226
00:28:19,000 --> 00:28:29,000
 As long as this hard constraint is violated or not satisfied, it's not a feasible timetable.
只要这个硬约束被违反或不满足，它就不是一个可行的时间表。

227
00:28:29,000 --> 00:28:32,000
 Now, what about soft constraints?
现在，软约束怎么样？

228
00:28:38,000 --> 00:28:48,000
 As the name soft implies, soft is a constraint where you try to satisfy.
正如名称“soft”所暗示的那样，“soft”是您试图满足的约束。

229
00:28:48,000 --> 00:28:53,000
 But if you cannot find it, you cannot satisfy it well, you can live it.
但如果你找不到它，你就不能很好地满足它，你就可以活下去。

230
00:28:53,000 --> 00:28:56,000
 So there's a soft constraint.
所以有一个软约束。

231
00:28:56,000 --> 00:29:03,000
 For example, let's say I'm teaching.
例如，假设我正在教书。

232
00:29:03,000 --> 00:29:10,000
 If I'm assigning, let's say, six classes in a row, is doable?
如果我连续分配六个班级，可行吗？

233
00:29:10,000 --> 00:29:15,000
 All right, one after another, is doable.
好吧，一个接着一个，是可行的。

234
00:29:15,000 --> 00:29:18,000
 But do you think that's a preference?
但你认为这是一种偏好吗？

235
00:29:18,000 --> 00:29:20,000
 Definitely not.
绝对不是。

236
00:29:21,000 --> 00:29:26,000
 So it would be a situation where if really have to, there's no other way out.
因此，如果确实有必要，那就会出现这样的情况：没有其他出路。

237
00:29:26,000 --> 00:29:29,000
 I have no choice, you know, that would be the timetable.
我别无选择，你知道，这就是时间表。

238
00:29:29,000 --> 00:29:33,000
 But to me, that's not a good timetable.
但对我来说，这不是一个好的时间表。

239
00:29:33,000 --> 00:29:38,000
 You see the difference between the hard and the soft constraints.
您会看到硬约束和软约束之间的差异。

240
00:29:38,000 --> 00:29:48,000
 And also, I also know of, let's say, some colleagues who say, hey, can you put me all my classes on the same day?
而且，我还知道，有些同事会说，嘿，你能把我所有的课程安排在同一天吗？

241
00:29:48,000 --> 00:29:57,000
 Or at most two days, so that he doesn't have to, he can have the rest of the week to do his own work.
或者最多两天，这样他就不用了，一周剩下的时间可以做自己的工作。

242
00:29:57,000 --> 00:30:06,000
 So of course, when the viewpoint is scheduling it or planning the timetable, you will try and accede to that request.
所以，当然，当观点正在安排它或计划时间表时，你会尝试并同意该请求。

243
00:30:06,000 --> 00:30:13,000
 But if indeed, because of these constraints imposed, you cannot find a feasible solution,
但如果确实由于这些限制而无法找到可行的解决方案，

244
00:30:13,000 --> 00:30:15,000
 then you've got to relax these constraints.
那么你就必须放宽这些限制。

245
00:30:15,000 --> 00:30:20,000
 These are so-called soft constraints.
这些就是所谓的软约束。

246
00:30:20,000 --> 00:30:34,000
 All right, so now my question is, OK, optimization means you have to define what is good, what is bad.
好吧，现在我的问题是，好的，优化意味着你必须定义什么是好的，什么是坏的。

247
00:30:34,000 --> 00:30:40,000
 So how do you tell how good the timetable is?
那么如何判断时间表的好坏呢？

248
00:30:40,000 --> 00:30:47,000
 Or how bad the timetable is?
或者时间表有多糟糕？

249
00:30:47,000 --> 00:30:58,000
 Based on the two so-called constraints category I told you, hard constraints cannot, so-called not negotiable.
基于我告诉你的两个所谓的约束类别，硬约束不能，所谓不可协商。

250
00:30:58,000 --> 00:31:00,000
 But it's a soft constraint.
但这是一个软约束。

251
00:31:00,000 --> 00:31:03,000
 For example, you can have hundreds of soft constraints.
例如，您可以有数百个软约束。

252
00:31:03,000 --> 00:31:13,000
 A good timetable will be the one that so-called fulfill most of the other constraints, the soft constraints.
一个好的时间表将是所谓满足大多数其他约束（软约束）的时间表。

253
00:31:13,000 --> 00:31:21,000
 All right, so when you talk about optimization, the question is always, OK, how do you know this is good?
好吧，所以当你谈论优化时，问题总是，好吧，你怎么知道这是好的？

254
00:31:22,000 --> 00:31:29,000
 There must be some measure of goodness of how good that solution is.
必须有某种衡量解决方案的好坏的标准。

255
00:31:29,000 --> 00:31:40,000
 So there's optimization.
所以就有了优化。

256
00:31:40,000 --> 00:31:47,000
 So optimization of satellite structure.
从而优化卫星结构。

257
00:31:48,000 --> 00:31:55,000
 So when you design a satellite, there are many infinite number of possibilities of the structure.
所以当你设计一颗卫星时，结构有无限多种可能性。

258
00:31:55,000 --> 00:32:04,000
 But because of the physics behind it, certain structures will give you better characteristics.
但由于其背后的物理原理，某些结构会给你带来更好的特性。

259
00:32:04,000 --> 00:32:18,000
 So one way is, of course, a human would design this structure and then test out how resistant it is to vibrations.
当然，一种方法是由人类设计这种结构，然后测试它的抗振动能力。

260
00:32:18,000 --> 00:32:22,000
 So that's how a human would do it.
人类就是这么做的。

261
00:32:22,000 --> 00:32:25,000
 Why not use a program to evolve it?
为什么不使用程序来进化它呢？

262
00:32:25,000 --> 00:32:31,000
 Use a genetic algorithm or evolutionary algorithm to evolve the design structures.
使用遗传算法或进化算法来进化设计结构。

263
00:32:31,000 --> 00:32:37,000
 Since you understand the physics of it, you can formulate it.
既然你了解了它的物理原理，你就可以用公式表达它。

264
00:32:37,000 --> 00:32:44,000
 You can model the vibration and then test out.
您可以对振动进行建模，然后进行测试。

265
00:32:44,000 --> 00:32:47,000
 So which gives you the so-called the fitness.
这给了你所谓的健身。

266
00:32:47,000 --> 00:32:58,000
 The fitness, I see my arrow here, but it doesn't show here.
健身，我在这里看到我的箭头，但这里没有显示。

267
00:32:58,000 --> 00:33:08,000
 So you can see the fitness, which is according to its vibration resistance.
所以你可以看到适合度，这是根据它的抗振性。

268
00:33:08,000 --> 00:33:09,000
 So that's quite clear.
所以这很清楚。

269
00:33:09,000 --> 00:33:15,000
 You just evolve the structures and then you measure the fitness.
你只需发展结构，然后衡量适应性。

270
00:33:15,000 --> 00:33:22,000
 Now, what is so special about evolutionary algorithm or genetic algorithm?
那么，进化算法或遗传算法有什么特别之处呢？

271
00:33:22,000 --> 00:33:27,000
 What's so special about doing it this way?
这样做有什么特别之处？

272
00:33:28,000 --> 00:33:36,000
 Many people do not realize it's the creativity aspect, the evolutionary creativity.
许多人没有意识到这是创造力的一面，即进化的创造力。

273
00:33:36,000 --> 00:33:39,000
 Let me explain what this means.
让我解释一下这意味着什么。

274
00:33:39,000 --> 00:33:45,000
 When you design, normally what's your thought process?
当你设计时，通常你的思维过程是怎样的？

275
00:33:45,000 --> 00:33:49,000
 You have the specifications.
你有规格。

276
00:33:49,000 --> 00:33:54,000
 So chances are you look back at what are the existing designs.
因此，您很可能会回顾一下现有的设计。

277
00:33:55,000 --> 00:34:03,000
 And then you will tweak or make modifications or use that as a reference to come up with another design.
然后您将进行调整或修改，或将其作为参考来提出另一个设计。

278
00:34:03,000 --> 00:34:09,000
 So not wrong to say that it's likely to be our thought process, isn't it?
所以说这可能是我们的思维过程并没有错，不是吗？

279
00:34:09,000 --> 00:34:20,000
 So if that's your thought process, do you foresee that whatever your design would just be a variation of what is existing?
那么，如果这就是您的思考过程，您是否预见到您的设计将只是现有设计的变体？

280
00:34:20,000 --> 00:34:23,000
 Quite similar.
非常相似。

281
00:34:23,000 --> 00:34:25,000
 You understand my point?
你明白我的意思吗？

282
00:34:25,000 --> 00:34:30,000
 Because that is what as a designer, that's your thought process.
因为这就是作为设计师的想法，这就是你的思维过程。

283
00:34:30,000 --> 00:34:39,000
 So based on existing design, so you're going to change, you're going to modify, and then you come up with something new or different.
所以基于现有的设计，所以你要改变，你要修改，然后你想出一些新的或不同的东西。

284
00:34:39,000 --> 00:34:44,000
 That fulfills the specifications or the requirements.
满足规格或要求。

285
00:34:44,000 --> 00:34:46,000
 Correct?
正确的？

286
00:34:46,000 --> 00:34:51,000
 So chances are your design won't be too different.
所以你的设计很可能不会有太大不同。

287
00:34:51,000 --> 00:34:55,000
 That will be quite similar in that sense.
从这个意义上说，这将非常相似。

288
00:34:55,000 --> 00:35:04,000
 So from an optimization viewpoint, you will be searching only along a small section of the possibility.
因此，从优化的角度来看，您将仅沿着可能性的一小部分进行搜索。

289
00:35:04,000 --> 00:35:09,000
 You'll be exploring only a small segment of the possibility.
您将只探索可能性的一小部分。

290
00:35:09,000 --> 00:35:17,000
 But in your genetic algorithm, does it care what the structure is?
但在你的遗传算法中，它关心结构是什么吗？

291
00:35:17,000 --> 00:35:18,000
 It doesn't really care.
它并不真正关心。

292
00:35:18,000 --> 00:35:22,000
 It will just evolve the different structures.
它只会演化出不同的结构。

293
00:35:22,000 --> 00:35:27,000
 It will just come out with different structures, and then all it cares about is fitness.
它只会产生不同的结构，然后它所关心的就是健身。

294
00:35:27,000 --> 00:35:29,000
 Is it good enough?
够好吗？

295
00:35:29,000 --> 00:35:34,000
 Is it vibration resistance?
是抗振性吗？

296
00:35:34,000 --> 00:35:45,000
 So what this means is that from an optimization point of view, in your evolutionary algorithm, it's going to search a wider range of possibilities.
所以这意味着从优化的角度来看，在你的进化算法中，它将搜索更广泛的可能性。

297
00:35:45,000 --> 00:35:49,000
 That is what we mean by creativity.
这就是我们所说的创造力。

298
00:35:49,000 --> 00:36:00,000
 So to put it another way, evolutionary algorithm allows you to explore solutions that you otherwise would never have thought of.
换句话说，进化算法可以让你探索以前从未想到的解决方案。

299
00:36:00,000 --> 00:36:05,000
 That's the power of it.
这就是它的力量。

300
00:36:05,000 --> 00:36:16,000
 So this can be optimization problem.
所以这可能是优化问题。

301
00:36:16,000 --> 00:36:20,000
 Okay, the egg-queen problem.
好吧，蛋皇后问题。

302
00:36:20,000 --> 00:36:25,000
 How can it be optimization problem?
怎么会是优化问题呢？

303
00:36:25,000 --> 00:36:29,000
 Well, before that, let's understand the egg-queen problem.
好吧，在此之前，我们先来了解一下蛋王问题。

304
00:36:29,000 --> 00:36:34,000
 Egg by egg chess board and egg queens.
鸡蛋棋盘和鸡蛋皇后。

305
00:36:34,000 --> 00:36:37,000
 If you play chess, for sure you will know what this means.
如果你下棋，你肯定会知道这意味着什么。

306
00:36:37,000 --> 00:36:42,000
 But if you don't play chess, it's not difficult to understand.
但如果你不下棋，也不难理解。

307
00:36:42,000 --> 00:36:53,000
 A queen is a piece that commands horizontal, vertical, and diagonal.
皇后是控制水平、垂直和对角线的棋子。

308
00:36:53,000 --> 00:36:56,000
 That's a queen.
那是一位女王。

309
00:36:56,000 --> 00:37:03,000
 So in this problem here, the challenge is to put the egg queens on the chess board without any conflict.
因此，在这个问题中，挑战是将蛋皇后放在棋盘上而不发生任何冲突。

310
00:37:03,000 --> 00:37:09,000
 Conflict means two queens attacking each other.
冲突是指两个皇后互相攻击。

311
00:37:09,000 --> 00:37:13,000
 For example, if you have two queens on the same row, there's a conflict.
例如，如果同一行有两个皇后，就会发生冲突。

312
00:37:13,000 --> 00:37:20,000
 If you have two queens on the same column, there's a conflict.
如果同一列中有两个皇后，则会发生冲突。

313
00:37:20,000 --> 00:37:27,000
 Or you have two queens on the same diagonal, there's also a conflict.
或者你有两个皇后在同一条对角线上，也会有冲突。

314
00:37:27,000 --> 00:37:32,000
 So it's not difficult to understand what the egg-queen problem is.
所以就不难理解什么是蛋皇后问题了。

315
00:37:32,000 --> 00:37:37,000
 So two queens incomplete if they share the same row, column, or diagonal.
因此，如果两个皇后共享相同的行、列或对角线，那么它们就是不完整的。

316
00:37:37,000 --> 00:37:43,000
 Can it be extended to an egg-queen problem? Definitely can.
它可以扩展到蛋皇后问题吗？绝对可以。

317
00:37:43,000 --> 00:37:52,000
 So optimization means what?
那么优化意味着什么呢？

318
00:37:52,000 --> 00:37:59,000
 To find the best solution. What is the best solution?
寻找最佳解决方案。最好的解决方案是什么？

319
00:37:59,000 --> 00:38:06,000
 When you have zero conflicts, no queens mutually attacking.
当冲突为零时，就没有皇后相互攻击。

320
00:38:06,000 --> 00:38:11,000
 So when you optimize, you have a certain figure of merit.
因此，当您进行优化时，您就有一定的品质因数。

321
00:38:11,000 --> 00:38:16,000
 You understand the figure of merit? A measurement to say, oh, this is good, or this is better than this, and so on.
你了解品质因数吗？一种衡量标准，可以说，哦，这很好，或者这比这更好，等等。

322
00:38:16,000 --> 00:38:20,000
 How do you measure?
你如何测量？

323
00:38:20,000 --> 00:38:26,000
 According to the number of queens that are not in conflict.
根据不冲突的皇后数量。

324
00:38:26,000 --> 00:38:35,000
 So that will be the so-called how you will measure the goodness of the egg queens.
这就是所谓的衡量蛋皇后好坏的方法。

325
00:38:35,000 --> 00:38:57,000
 Is this configuration, are there any conflicts?
这个配置有冲突吗？

326
00:38:57,000 --> 00:39:11,000
 Any conflicts?
有冲突吗？

327
00:39:11,000 --> 00:39:20,000
 No conflicts?
没有冲突吗？

328
00:39:20,000 --> 00:39:38,000
 No? Good.
不？好的。

329
00:39:38,000 --> 00:39:46,000
 Any conflict? Any conflict in this configuration?
有冲突吗？这个配置有冲突吗？

330
00:39:46,000 --> 00:39:52,000
 Yes? No? No?
是的？不？不？

331
00:39:52,000 --> 00:40:02,000
 Anybody say yes? Yes? Good.
有人说是吗？是的？好的。

332
00:40:02,000 --> 00:40:06,000
 Two. Two means what? Two conflicts, right?
二。二是什么意思？两个冲突吧？

333
00:40:07,000 --> 00:40:11,000
 Can you see? Oh, I cannot.
你能看到吗？哦，我不能。

334
00:40:11,000 --> 00:40:27,000
 Can you see the second queen here? This queen and this queen?
你能在这里看到第二位女王吗？这个女王和这个女王？

335
00:40:27,000 --> 00:40:39,000
 This queen, this column, and this column.
这位女王，这列，还有这列。

336
00:40:39,000 --> 00:40:46,000
 What are the so-called requirements? What does it mean to be in conflict?
所谓的要求是什么？冲突是什么意思？

337
00:40:46,000 --> 00:41:01,000
 Row, column, diagonal. Can you see?
行、列、对角线。你能看到吗？

338
00:41:01,000 --> 00:41:11,000
 So you understand what the so-called egg queens problem is.
这样你就明白什么是所谓的蛋皇后问题了。

339
00:41:11,000 --> 00:41:17,000
 To find a configuration where none of the queens are mutually attacking each other.
找到一个没有皇后互相攻击的配置。

340
00:41:17,000 --> 00:41:25,000
 So if I give you another configuration and there are four queens that are mutually attacking,
所以如果我给你另一个配置并且有四个皇后互相攻击，

341
00:41:25,000 --> 00:41:29,000
 so which one do you think would be better?
那么您认为哪一个更好呢？

342
00:41:29,000 --> 00:41:32,000
 Of course this one. This one, there are only two queens.
当然是这个。这一位，只有两位皇后。

343
00:41:32,000 --> 00:41:44,000
 So what I'm trying to say is that in optimization, we have to have a way to ascertain or distinguish the goodness of the solution.
所以我想说的是，在优化中，我们必须有一种方法来确定或区分解决方案的优劣。

344
00:41:44,000 --> 00:41:46,000
 That's optimization.
这就是优化。

345
00:41:46,000 --> 00:41:56,000
 And I think if I say objective function, if you have done basic mathematics before, you understand what that means.
我想如果我说目标函数，如果你以前学过基础数学，你就会明白这意味着什么。

346
00:41:56,000 --> 00:42:04,000
 So you want to try one more because I'm going to use the egg queens problem a lot.
所以你想再尝试一个，因为我将经常使用蛋皇后问题。

347
00:42:04,000 --> 00:42:08,000
 So it's good to get really, really familiar.
所以非常非常熟悉是件好事。

348
00:42:08,000 --> 00:42:19,000
 So that later when we formulate it, you'll understand what it means.
这样当我们稍后制定它时，您就会明白它的含义。

349
00:42:19,000 --> 00:42:27,000
 So are there any valid non-attacking configurations?
那么有没有有效的非攻击性配置呢？

350
00:42:27,000 --> 00:42:41,000
 Meaning like zero queens attacking?
意思是零皇后攻击？

351
00:42:41,000 --> 00:43:00,000
 Spend a couple of minutes. Tell me.
花几分钟。告诉我。

352
00:43:00,000 --> 00:43:05,000
 Let me explain what this means.
让我解释一下这意味着什么。

353
00:43:05,000 --> 00:43:20,000
 I should explain.
我应该解释一下。

354
00:43:20,000 --> 00:43:45,000
 Okay. So when you have
好的。所以当你有

355
00:43:45,000 --> 00:44:14,000
 three, five, seven, one, six, four, two, eight, six, four, two, eight.
三、五、七、一、六、四、二、八、六、四、二、八。

356
00:44:14,000 --> 00:44:36,000
 So this is for the first one. Three, five, seven, one, six.
这是第一个。三、五、七、一、六。

357
00:44:36,000 --> 00:44:50,000
 So out of this six layout of egg queens, are there any that are non-attacking?
那么在这六种蛋皇后布局中，有没有非攻击性的呢？

358
00:45:06,000 --> 00:45:19,000
 So the first one, have you working out?
那么第一个问题，你锻炼了吗？

359
00:45:19,000 --> 00:45:23,000
 First one, attacking.
第一个，进攻。

360
00:45:23,000 --> 00:45:26,000
 First one is no good, right?
第一个不太好，对吧？

361
00:45:26,000 --> 00:45:30,000
 No good means they are queens attacking, right?
不好意味着他们是皇后进攻，对吧？

362
00:45:30,000 --> 00:45:31,000
 Okay.
好的。

363
00:45:31,000 --> 00:45:33,000
 First one good, no good.
第一个好，不好。

364
00:45:33,000 --> 00:45:35,000
 No good.
不好。

365
00:45:35,000 --> 00:45:41,000
 Second one.
第二个。

366
00:45:41,000 --> 00:45:55,000
 Okay, get used to it.
好吧，习惯了。

367
00:45:55,000 --> 00:45:56,000
 So get used to it.
所以要习惯它。

368
00:45:56,000 --> 00:46:03,000
 If exam I give you 12 queens, you know, then it's going to be very easily.
如果考试我给你 12 个皇后，你知道，那会很容易。

369
00:46:03,000 --> 00:46:05,000
 Second one.
第二个。

370
00:46:33,000 --> 00:46:36,000
 Okay.
好的。

371
00:47:03,000 --> 00:47:16,000
 So be good.
所以要乖。

372
00:47:16,000 --> 00:47:22,000
 Is be good?
是好吗？

373
00:47:22,000 --> 00:47:45,000
 Good.
好的。

374
00:47:46,000 --> 00:47:56,000
 Okay.
好的。

375
00:48:17,000 --> 00:48:21,000
 So be, who says is good?
那么，谁说好呢？

376
00:48:21,000 --> 00:48:24,000
 Good.
好的。

377
00:48:24,000 --> 00:48:26,000
 Okay.
好的。

378
00:48:26,000 --> 00:48:33,000
 No mutually attacking?
不互相攻击吗？

379
00:48:33,000 --> 00:48:36,000
 Okay, be is good, right?
好吧，be 很好，对吧？

380
00:48:36,000 --> 00:48:41,000
 So, okay, one more, then the rest I leave it to you to do on your own time.
那么，好吧，再来一件事，剩下的我就留给你自己安排时间去做。

381
00:48:41,000 --> 00:48:45,000
 C, C?
丙，丙？

382
00:48:45,000 --> 00:48:47,000
 C no good.
C 不好。

383
00:48:47,000 --> 00:48:49,000
 Okay.
好的。

384
00:48:49,000 --> 00:48:51,000
 So what about D?
那么D呢？

385
00:48:51,000 --> 00:48:57,000
 Maybe let's go through D.
也许我们来看看D。

386
00:48:57,000 --> 00:48:59,000
 D?
D？

387
00:48:59,000 --> 00:49:02,000
 No.
不。

388
00:49:02,000 --> 00:49:04,000
 No.
不。

389
00:49:04,000 --> 00:49:05,000
 Right?
正确的？

390
00:49:05,000 --> 00:49:07,000
 So D is no good.
所以D不好。

391
00:49:07,000 --> 00:49:09,000
 What about E?
那么E呢？

392
00:49:09,000 --> 00:49:10,000
 No.
不。

393
00:49:10,000 --> 00:49:12,000
 No.
不。

394
00:49:12,000 --> 00:49:14,000
 Okay.
好的。

395
00:49:14,000 --> 00:49:15,000
 Okay.
好的。

396
00:49:15,000 --> 00:49:19,000
 What about F?
F呢？

397
00:49:19,000 --> 00:49:22,000
 What about F?
F呢？

398
00:49:42,000 --> 00:49:52,000
 F, good.
弗，很好。

399
00:49:52,000 --> 00:49:54,000
 No good.
不好。

400
00:49:54,000 --> 00:49:56,000
 Good.
好的。

401
00:49:56,000 --> 00:50:00,000
 F, good.
弗，很好。

402
00:50:00,000 --> 00:50:02,000
 Okay, F is good.
好吧，F不错。

403
00:50:02,000 --> 00:50:04,000
 Right?
正确的？

404
00:50:04,000 --> 00:50:08,000
 So B and F is good.
所以B和F都不错。

405
00:50:08,000 --> 00:50:10,000
 Okay.
好的。

406
00:50:10,000 --> 00:50:12,000
 So what do I do, right?
那我该怎么办，对吗？

407
00:50:12,000 --> 00:50:13,000
 Okay.
好的。

408
00:50:13,000 --> 00:50:19,000
 If I were to ask you to formulate this, right, in terms of equations, how to know,
如果我要你用方程来表达这个，对吧，如何知道，

409
00:50:19,000 --> 00:50:25,000
 because chances are you probably have to draw out the configuration, right?
因为您可能必须绘制出配置，对吧？

410
00:50:25,000 --> 00:50:28,000
 And then to see whether it's in conflict or not.
然后再看看有没有冲突。

411
00:50:28,000 --> 00:50:31,000
 It's very, so there's another point you need to know.
非常，所以还有一点你需要知道。

412
00:50:31,000 --> 00:50:38,000
 It's very easy to see that a configuration is no good, correct?
很容易看出配置不好，对吗？

413
00:50:38,000 --> 00:50:45,000
 If you see one poop in conflict, you already proven that this is no good, right?
如果你看到一便便​​发生冲突，你就已经证明这不好，对吧？

414
00:50:45,000 --> 00:50:54,000
 To prove that this is a valid configuration, you have to check everyone, right?
为了证明这是一个有效的配置，你必须检查每个人，对吧？

415
00:50:54,000 --> 00:50:56,000
 Correct?
正确的？

416
00:50:56,000 --> 00:50:58,000
 To prove that it's valid.
为了证明它是有效的。

417
00:50:58,000 --> 00:51:05,000
 So if you have a thousand queens, you do it a thousand times, right?
所以如果你有一千个皇后，你就会做一千次，对吧？

418
00:51:05,000 --> 00:51:12,000
 So keep that thought in mind later when we, so-called, let's say you have a solution, right?
因此，当我们所谓的，假设你有解决方案时，请记住这个想法，对吧？

419
00:51:12,000 --> 00:51:15,000
 How do you prove or show that it is good?
你如何证明或表明它是好的？

420
00:51:15,000 --> 00:51:19,000
 Whether it's optimum or not optimum, okay?
不管它是最优还是非最优，好吗？

421
00:51:19,000 --> 00:51:25,000
 So think about how you would formulate it, right, in terms of equation,
所以想想你会如何用方程来表达它，对吧，

422
00:51:25,000 --> 00:51:30,000
 meaning that if I give you a string like that, right, you can go,
意思是如果我给你一个这样的字符串，你就可以走了，

423
00:51:30,000 --> 00:51:37,000
 based on the equation or formulation, then you can check whether it is valid or not,
基于方程或公式，然后你可以检查它是否有效，

424
00:51:37,000 --> 00:51:39,000
 whether it's attacking or not.
无论是否攻击。

425
00:51:39,000 --> 00:51:44,000
 I mean, you know, right, if you can formulate it, you can put it into an algorithm.
我的意思是，你知道，对，如果你能将它表述出来，你就可以将它放入算法中。

426
00:51:44,000 --> 00:51:46,000
 That's all the idea, okay?
这就是全部的想法，好吗？

427
00:51:46,000 --> 00:51:54,000
 I will show you next week after you've tried it.
当你尝试过之后，我会在下周向你展示。

428
00:51:54,000 --> 00:52:02,000
 Okay, let's talk about modeling.
好吧，我们来谈谈建模。

429
00:52:02,000 --> 00:52:06,000
 Okay, so we look at optimization.
好的，我们来看看优化。

430
00:52:06,000 --> 00:52:09,000
 Now let's take a look at modeling, right?
现在我们来看看建模吧？

431
00:52:09,000 --> 00:52:17,000
 So based on the black box, you have three entities, as we say, the input and then the output and the model, right?
因此，基于黑匣子，您拥有三个实体，正如我们所说，输入，然后是输出和模型，对吗？

432
00:52:17,000 --> 00:52:28,000
 So what if you know your, you have your input, you have your output, but the model is not known?
那么，如果你知道你的、你有你的输入、你有你的输出，但模型不知道怎么办？

433
00:52:28,000 --> 00:52:32,000
 So this course is about machine learning, right?
所以这门课程是关于机器学习的，对吧？

434
00:52:32,000 --> 00:52:37,000
 So later on, I think Prof. Malgatso is going to tell you a lot about neural networks and so on.
所以稍后，我想 Malgatso 教授会告诉你们很多关于神经网络等等的内容。

435
00:52:37,000 --> 00:52:42,000
 So when you do training on your neural networks, right?
那么当你对神经网络进行训练时，对吧？

436
00:52:42,000 --> 00:52:45,000
 So your network consists of multiple layers.
所以你的网络由多层组成。

437
00:52:45,000 --> 00:52:53,000
 What are you trying to solve when you do machine learning in your neural network?
当你在神经网络中进行机器学习时，你想解决什么问题？

438
00:52:53,000 --> 00:53:00,000
 You're trying to build or find the weights, the connection between the different neurons, right?
你正在尝试建立或找到权重以及不同神经元之间的连接，对吧？

439
00:53:00,000 --> 00:53:04,000
 So normally in your training process, you will do it iteratively.
所以通常在你的训练过程中，你会迭代地进行。

440
00:53:04,000 --> 00:53:16,000
 So you will iterate until you find a set of weights that correctly associate your output and the input.
因此，您将进行迭代，直到找到一组正确关联输出和输入的权重。

441
00:53:16,000 --> 00:53:21,000
 So for example, when you do image recognition or character recognition, right?
例如，当你进行图像识别或字符识别时，对吧？

442
00:53:21,000 --> 00:53:29,000
 You have a set of your training sample, could be you have your inputs, which are all the images of your characters, right?
你有一组训练样本，可能有你的输入，它们都是你的角色的图像，对吗？

443
00:53:29,000 --> 00:53:31,000
 And then you would have labeled them.
然后你就会给它们贴上标签。

444
00:53:31,000 --> 00:53:35,000
 Okay, this image is A, this image is B and so on.
好吧，这张图片是A，这张图片是B，依此类推。

445
00:53:35,000 --> 00:53:43,000
 So based on this image here, you, you will iteratively, right?
所以基于这里的这个图像，你，你会迭代，对吧？

446
00:53:43,000 --> 00:53:49,000
 So-called find the weights that can correct correctly associate between the inputs and outputs.
所谓找到能够正确关联输入和输出的权重。

447
00:53:49,000 --> 00:53:53,000
 That's the basis of machine learning, right?
这就是机器学习的基础，对吗？

448
00:53:53,000 --> 00:53:54,000
 In neural network.
在神经网络中。

449
00:53:55,000 --> 00:54:04,000
 So if you think in this model here, all right?
那么如果你在这个模型中思考，好吗？

450
00:54:04,000 --> 00:54:10,000
 So basically what you're doing is that when you find the weights, you're finding the model for that.
所以基本上你所做的就是当你找到权重时，你就找到了它的模型。

451
00:54:10,000 --> 00:54:14,000
 Typically that is what you do, okay?
通常这就是你所做的，好吗？

452
00:54:14,000 --> 00:54:16,000
 So you do it iteratively.
所以你迭代地做。

453
00:54:16,000 --> 00:54:20,000
 Can you use a GA to do it?
可以用GA来做吗？

454
00:54:21,000 --> 00:54:25,000
 Yes, you can.
是的，你可以。

455
00:54:25,000 --> 00:54:30,000
 So you can, modeling problems can be transformed into optimization problems.
这样就可以，建模问题可以转化为优化问题。

456
00:54:30,000 --> 00:54:38,000
 You have all the different weights, which you normally in your deep neural network, you will iteratively train it, right?
你有所有不同的权重，通常在深度神经网络中，你会迭代地训练它，对吗？

457
00:54:38,000 --> 00:54:40,000
 Until you get a set of weights.
直到你得到一组权重。

458
00:54:40,000 --> 00:54:43,000
 You can also optimize it.
您还可以对其进行优化。

459
00:54:43,000 --> 00:54:46,000
 I evolve the set of weights.
我改进了权重集。

460
00:54:46,000 --> 00:54:51,000
 I will evolve the set of weights until there is a set of weights, right?
我将演化这组权重，直到出现一组权重，对吗？

461
00:54:51,000 --> 00:54:54,000
 That very closely, right?
非常接近，对吧？

462
00:54:54,000 --> 00:54:57,000
 Model the inputs and outputs.
对输入和输出建模。

463
00:54:57,000 --> 00:55:02,000
 Okay, so we can also transform it into optimization problems or so.
好吧，那么我们也可以把它转化为优化问题等等。

464
00:55:02,000 --> 00:55:04,000
 Now.
现在。

465
00:55:08,000 --> 00:55:11,000
 So that's on machine learning.
这就是机器学习。

466
00:55:11,000 --> 00:55:16,000
 Predicting stock exchange.
预测股票交易。

467
00:55:16,000 --> 00:55:20,000
 In your stock market, you have historical data.
在你的股票市场中，你有历史数据。

468
00:55:20,000 --> 00:55:24,000
 We call it the valuation of the equity.
我们称之为股权估值。

469
00:55:24,000 --> 00:55:29,000
 So you have this historical time series data.
所以你有这个历史时间序列数据。

470
00:55:29,000 --> 00:55:32,000
 Can I build a model?
我可以建立一个模型吗？

471
00:55:32,000 --> 00:55:35,000
 According to this historical data, right?
根据这个历史数据，对吗？

472
00:55:35,000 --> 00:55:38,000
 To find a model, right?
找个模型吧？

473
00:55:38,000 --> 00:55:48,000
 That will closely predict, does approximation of the trend of the stock.
这将密切预测、近似股票的趋势。

474
00:55:48,000 --> 00:55:49,000
 Same thing, right?
同样的事情，对吧？

475
00:55:49,000 --> 00:55:51,000
 We're just looking for a model.
我们只是在寻找一个模型。

476
00:55:51,000 --> 00:56:01,000
 So that becomes a model for predicting the price of the stock.
因此，这成为预测股票价格的模型。

477
00:56:01,000 --> 00:56:04,000
 In your smart homes, you have so-called your...
在您的智能家居中，您拥有所谓的...

478
00:56:04,000 --> 00:56:07,000
 Let's say your IoT, right?
假设您的物联网，对吧？

479
00:56:07,000 --> 00:56:10,000
 Or at home, let's say your voice control.
或者在家里，比如说你的语音控制。

480
00:56:10,000 --> 00:56:15,000
 Can you train your device, your controller, to understand certain commands?
您可以训练您的设备、控制器来理解某些命令吗？

481
00:56:15,000 --> 00:56:22,000
 Then, likes on, you know, then the output will be associated to a so-called switching on,
然后，喜欢，你知道，然后输出将与所谓的打开相关联，

482
00:56:22,000 --> 00:56:25,000
 a particular switch, and so on, right?
特定的开关等等，对吗？

483
00:56:25,000 --> 00:56:31,000
 So basically, essentially what you're doing is finding a model.
所以基本上，你所做的就是寻找一个模型。

484
00:56:31,000 --> 00:56:42,000
 All right?
好的？

485
00:56:42,000 --> 00:56:52,000
 Okay, another example of model is your so-called load, not load.
好吧，模型的另一个例子是你所谓的负载，而不是负载。

486
00:56:52,000 --> 00:56:55,000
 Loan, loan-applicant credibility.
贷款，贷款申请人的信誉。

487
00:56:55,000 --> 00:56:57,000
 Okay?
好的？

488
00:56:57,000 --> 00:57:00,000
 So when you want to get a load, all right?
那么当你想要负载时，好吗？

489
00:57:00,000 --> 00:57:03,000
 The bank is taking a risk on you.
银行正在为你承担风险。

490
00:57:03,000 --> 00:57:05,000
 Okay?
好的？

491
00:57:05,000 --> 00:57:08,000
 So the bank would...
那么银行会...

492
00:57:08,000 --> 00:57:16,000
 Ideally, the bank only want to loan you if they believe that you have so-called the capability to repay the loan.
理想情况下，银行只有在相信您有所谓的偿还贷款的能力时才愿意向您贷款。

493
00:57:16,000 --> 00:57:17,000
 All right?
好的？

494
00:57:17,000 --> 00:57:19,000
 So how do you evaluate, all right?
那你怎么评价呢？

495
00:57:19,000 --> 00:57:24,000
 So in the old days, I remember when I go to the bank, right, to get a loan,
所以在过去，我记得当我去银行，对，去贷款的时候，

496
00:57:24,000 --> 00:57:28,000
 you literally have a bank officer to sit down and ask you a series of questions.
实际上，有一位银行官员会坐下来问你一系列问题。

497
00:57:28,000 --> 00:57:36,000
 And based on the questions, according to how I answer or the profile, they will give a score.
然后根据问题，根据我的回答方式或个人资料，他们会给出评分。

498
00:57:36,000 --> 00:57:37,000
 All right?
好的？

499
00:57:37,000 --> 00:57:44,000
 So essentially what the loan officer has is a model, all right?
所以本质上信贷员拥有的是一个模型，好吗？

500
00:57:44,000 --> 00:57:52,000
 They have a model to so-called determine the credit-worthiness of the loan-applicant, all right?
他们有一个模型来所谓确定贷款申请人的信用度，好吗？

501
00:57:52,000 --> 00:57:55,000
 Now, this is, of course, a lot of it can be done by machines.
当然，现在很多工作都可以由机器来完成。

502
00:57:55,000 --> 00:57:58,000
 All these can be automated, all right?
所有这些都可以自动化，好吗？

503
00:57:58,000 --> 00:58:10,000
 So by the same token, you can also use your event-based algorithm to come up with a model for this prediction.
因此，出于同样的原因，您也可以使用基于事件的算法来提出此预测的模型。

504
00:58:10,000 --> 00:58:13,000
 So to come up with a model, all right?
所以想出一个模型，好吗？

505
00:58:13,000 --> 00:58:23,000
 So you will base your accuracy on the historical data of what happens based on the profile of the different loan applicants and so on.
因此，您的准确性将基于不同贷款申请人的资料等所发生情况的历史数据。

506
00:58:23,000 --> 00:58:24,000
 All right?
好的？

507
00:58:24,000 --> 00:58:39,000
 So this will fall very nicely into a so-called black box model where we are trying to find the model.
因此，这将很好地落入所谓的黑盒模型中，我们试图在其中找到模型。

508
00:58:39,000 --> 00:58:48,000
 So the third category on your black, according to the black box, would be the simulation.
因此，根据黑匣子，黑色的第三类是模拟。

509
00:58:48,000 --> 00:58:57,000
 So in simulation, you have a situation where you know the input, all right?
所以在模拟中，你会遇到一种情况，你知道输入，好吗？

510
00:58:57,000 --> 00:59:02,000
 And then you know the model, but what you don't know is the output.
然后你知道了模型，但你不知道的是输出。

511
00:59:02,000 --> 00:59:03,000
 All right?
好的？

512
00:59:03,000 --> 00:59:05,000
 What you don't know is the output.
你不知道的是输出。

513
00:59:05,000 --> 00:59:12,000
 So this is very good, all right?
所以这非常好，好吗？

514
00:59:12,000 --> 00:59:20,000
 To answer in scenarios where you have that, to answer what if kind of a scenario, right?
在有这种情况的情况下回答，回答如果是一种情况会怎样，对吧？

515
00:59:20,000 --> 00:59:25,000
 For example, in economics and artificial life, all right?
例如，在经济学和人工生命中，好吗？

516
00:59:25,000 --> 00:59:34,000
 So if you are a so-called a planner, right, you are in an economic planning unit, for example, all right?
那么如果你是一个所谓的计划员，对吧，比如说你在一个经济计划单位，好吗？

517
00:59:34,000 --> 00:59:38,000
 So you change a certain policy.
所以你改变了某个政策。

518
00:59:38,000 --> 00:59:43,000
 Do you know what the result or the repercussion of this change in policy?
您知道这一政策变化的结果或影响是什么吗？

519
00:59:43,000 --> 00:59:46,000
 You don't know because you cannot test it out.
你不知道，因为你无法测试它。

520
00:59:46,000 --> 00:59:50,000
 You cannot experiment it.
你无法尝试它。

521
00:59:50,000 --> 00:59:51,000
 All right?
好的？

522
00:59:51,000 --> 00:59:53,000
 So what's the next best course?
那么下一个最好的课程是什么？

523
00:59:53,000 --> 00:59:55,000
 You simulate it, all right?
你模拟一下好吗？

524
00:59:55,000 --> 00:59:57,000
 You simulate it.
你模拟一下。

525
00:59:57,000 --> 01:00:05,000
 Or you want to do a prediction on the population growth, all right?
或者你想预测人口增长，好吗？

526
01:00:05,000 --> 01:00:15,000
 According to the so-called different parameters or policies or texts, your text policy or text regime and so on.
根据所谓不同的参数或政策或文本，你的文本政策或文本制度等等。

527
01:00:15,000 --> 01:00:21,000
 So you want to find out what the output is.
所以你想知道输出是什么。

528
01:00:21,000 --> 01:00:23,000
 So you cannot actually test it out, all right?
所以你不能实际测试它，好吗？

529
01:00:23,000 --> 01:00:24,000
 So what do you do?
那么你做什么呢？

530
01:00:24,000 --> 01:00:27,000
 You use simulation to do it, okay?
你用模拟来做到这一点，好吗？

531
01:00:27,000 --> 01:00:34,000
 So you are very applicable in evolutionary economics, artificial life, right?
所以你在进化经济学、人工生命方面非常适用，对吗？

532
01:00:34,000 --> 01:00:37,000
 Or in your weather forecast systems, all right?
或者在你的天气预报系统中，好吗？

533
01:00:37,000 --> 01:00:44,000
 And also the, let's say, impact analysis on the new text systems and so on.
还有，比如说，对新文本系统的影响分析等等。

534
01:00:44,000 --> 01:00:52,000
 Let's talk a little bit about the evolving artificial life, all right?
我们来谈谈不断进化的人工生命，好吗？

535
01:00:52,000 --> 01:00:58,000
 So this book by Epstein, it's a good book that talks a lot about this, right?
爱泼斯坦的这本书是一本很好的书，其中讨论了很多这个问题，对吧？

536
01:00:58,000 --> 01:01:00,000
 If you're interested, you can look into this.
如果你有兴趣的话，你可以研究一下这个。

537
01:01:00,000 --> 01:01:04,000
 So you can simulate trade, economic competition, all right?
所以你可以模拟贸易、经济竞争，好吗？

538
01:01:04,000 --> 01:01:08,000
 And then to calibrate the models, okay?
然后校准模型，好吗？

539
01:01:08,000 --> 01:01:14,000
 So when you think about it, it would be a situation where you cannot actually test it out, right?
那么你想想，这会是一种你无法实际测试的情况，对吗？

540
01:01:14,000 --> 01:01:18,000
 In many problems, you can't actually test it out, all right?
在很多问题中，你无法实际测试出来，好吗？

541
01:01:18,000 --> 01:01:25,000
 So therefore you rely on some kind of simulation model, all right, to predict what the output is.
因此，您可以依靠某种模拟模型来预测输出是什么。

542
01:01:25,000 --> 01:01:33,000
 And then from the output, you would use it to, so-called, to calibrate the parameters, okay?
然后从输出中，你可以用它来校准参数，好吗？

543
01:01:33,000 --> 01:01:43,000
 So very useful, for example, to optimize strategies and policies and so on, all right?
非常有用，例如，优化战略和政策等，好吗？

544
01:01:43,000 --> 01:01:50,000
 And the other example you can talk about from a biological point of view, all right?
你可以从生物学的角度来谈谈另一个例子，好吗？

545
01:01:50,000 --> 01:01:56,000
 We know that incest prevention keeps evolution from rapid degeneration.
我们知道，乱伦预防可以防止进化迅速退化。

546
01:01:56,000 --> 01:01:59,000
 We all know this, all right?
我们都知道这一点，好吗？

547
01:01:59,000 --> 01:02:01,000
 Can we test it?
我们可以测试一下吗？

548
01:02:01,000 --> 01:02:02,000
 No, all right?
不，好吗？

549
01:02:02,000 --> 01:02:05,000
 It's simulated.
这是模拟的。

550
01:02:05,000 --> 01:02:08,000
 What about multi-paran reproduction?
多重繁殖又如何呢？

551
01:02:08,000 --> 01:02:16,000
 Multi-paran reproduction makes evolution more efficient.
多重繁殖使进化更加高效。

552
01:02:16,000 --> 01:02:19,000
 Can never happen, all right?
永远不会发生，好吗？

553
01:02:19,000 --> 01:02:27,000
 So therefore the only request is to simulate, okay?
因此，唯一的要求就是模拟，好吗？

554
01:02:27,000 --> 01:02:35,000
 No picture to show on this.
没有图片可以显示这一点。

555
01:02:35,000 --> 01:02:42,000
 Okay, so we are looking at the black box categorization.
好的，我们正在研究黑盒分类。

556
01:02:42,000 --> 01:02:45,000
 Let's think in terms of the search problems, all right?
让我们考虑一下搜索问题，好吗？

557
01:02:45,000 --> 01:02:50,000
 Let's look from the viewpoint of it being a search problem.
让我们从搜索问题的角度来看。

558
01:02:50,000 --> 01:02:59,000
 So you can see from our earlier discussion, simulation is very different from optimization and modeling, all right?
所以你可以从我们之前的讨论中看到，模拟与优化和建模有很大不同，好吗？

559
01:02:59,000 --> 01:03:07,000
 So in simulation, all right, we actually, as compared to optimization and modeling,
所以在模拟中，好吧，我们实际上，与优化和建模相比，

560
01:03:07,000 --> 01:03:13,000
 you can see the difference from what we have looked, talked about earlier on.
你可以看到与我们之前讨论过的内容的不同之处。

561
01:03:13,000 --> 01:03:21,000
 So optimization and modeling problems search through the huge search possibilities, all right?
因此，优化和建模问题需要通过巨大的搜索可能性进行搜索，好吗？

562
01:03:21,000 --> 01:03:25,000
 So when we talk about the search possibilities, you are talking about a search space.
因此，当我们谈论搜索可能性时，您谈论的是搜索空间。

563
01:03:25,000 --> 01:03:32,000
 So search space is the so-called solution, the landscape, the possibilities that is available.
所以搜索空间就是所谓的解决方案、景观、可用的可能性。

564
01:03:32,000 --> 01:03:39,000
 So this is a collection of all objects of interest, including the desired solution.
所以这是所有感兴趣对象的集合，包括所需的解决方案。

565
01:03:39,000 --> 01:03:47,000
 Now the question we want to ask is how big, how complex is the search space?
现在我们要问的问题是搜索空间有多大、有多复杂？

566
01:03:47,000 --> 01:03:52,000
 So how complex, how large is the search space?
那么有多复杂，搜索空间有多大？

567
01:03:52,000 --> 01:04:00,000
 So to be able to classify this problem, that helps us to decide what is a good tool,
因此，能够对这个问题进行分类，可以帮助我们决定什么是一个好的工具，

568
01:04:00,000 --> 01:04:05,000
 the tools that we can use to solve this problem.
我们可以用来解决这个问题的工具。

569
01:04:05,000 --> 01:04:13,000
 Okay, so understanding of the nature of the search space that we are talking about,
好的，了解我们正在讨论的搜索空间的本质，

570
01:04:13,000 --> 01:04:32,000
 that will help us, or that provide us with so-called information on how to deal with the problem.
这将帮助我们，或者为我们提供如何处理问题的所谓信息。

571
01:04:32,000 --> 01:04:39,000
 All right, in our categorization also, we have this optimization versus constraint satisfaction.
好吧，在我们的分类中，我们也有这种优化与约束满足。

572
01:04:40,000 --> 01:04:47,000
 So far we have looked at, basically we mentioned about objective function.
到目前为止，我们基本上已经提到了目标函数。

573
01:04:47,000 --> 01:05:00,000
 So basically it is for us to assign a value or a figure of merit to reflect the quality on a scale.
所以基本上我们需要指定一个值或品质因数来反映规模上的质量。

574
01:05:00,000 --> 01:05:04,000
 So for example, in the n-quins problem, or a-quins problem,
例如，在 n-quins 问题或 a-quins 问题中，

575
01:05:04,000 --> 01:05:10,000
 so the objective function could be based on the number of unchecked queens.
因此目标函数可以基于未经检查的皇后的数量。

576
01:05:10,000 --> 01:05:18,000
 From the examples that you have seen, if I ask you which layout or configuration is better,
从你看到的例子来看，如果我问你哪种布局或配置更好，

577
01:05:18,000 --> 01:05:25,000
 so you can tell me which is better according to the number of queens that are not attacking each other.
所以你可以根据不互相攻击的皇后数量来告诉我哪个更好。

578
01:05:25,000 --> 01:05:30,000
 That will be the goodness measure of the configuration.
这将是配置的优劣度量。

579
01:05:31,000 --> 01:05:37,000
 So we can also think of the traveling salesman problem.
所以我们也可以想到旅行商问题。

580
01:05:37,000 --> 01:05:46,000
 The objective function of the traveling salesman problem will be based on the tour length, the distance traveled.
旅行商问题的目标函数将基于旅行长度、旅行距离。

581
01:05:46,000 --> 01:05:53,000
 So the length of a tour, visiting given set of cities, what is the objective?
那么，旅行的长度、访问给定的城市的目的是什么？

582
01:05:53,000 --> 01:05:59,000
 We want to minimize the cost, which is the distance.
我们希望最小化成本，即距离。

583
01:06:01,000 --> 01:06:03,000
 That is objective function.
这就是目标函数。

584
01:06:03,000 --> 01:06:05,000
 You clear the objective function?
目标函数你清楚了吗？

585
01:06:05,000 --> 01:06:10,000
 It is a function to measure the figure, the goodness of a solution.
它是一个衡量数字、解决方案优劣的函数。

586
01:06:11,000 --> 01:06:15,000
 Now on the other side of it, we have constraint.
现在，在它的另一边，我们有约束。

587
01:06:17,000 --> 01:06:28,000
 Constraint is something that is a binary evaluation telling whether a given requirement holds or not.
约束是一种二元评估，可以判断给定的要求是否成立。

588
01:06:29,000 --> 01:06:32,000
 It is something that you can answer yes, no.
你可以回答是或否。

589
01:06:32,000 --> 01:06:35,000
 Yes means it satisfies the constraint.
Yes 表示满足约束条件。

590
01:06:35,000 --> 01:06:37,000
 No means it doesn't satisfy.
不，代表不满足。

591
01:06:40,000 --> 01:06:48,000
 So for example, in the eight queens problem, you are finding a configuration of eight queens on the chess board,
例如，在八皇后问题中，您要在棋盘上找到八皇后的配置，

592
01:06:48,000 --> 01:06:51,000
 such that no two queens attack each other.
这样就不会出现两个皇后互相攻击的情况。

593
01:06:52,000 --> 01:07:00,000
 So if I give you two queens a position of it, you can answer me yes, they are attacking or no, they are not mutually attacking.
所以如果我给你两个皇后的位置，你可以回答我是，他们正在攻击，或者不是，他们不是互相攻击。

594
01:07:00,000 --> 01:07:04,000
 That is the implication or meaning of constraint.
这就是约束的含义或含义。

595
01:07:07,000 --> 01:07:18,000
 In the traveling salesman problem, constraint, an example of a constraint is you want to find a tour
在旅行商问题中，约束，约束的一个例子是你想找到一个旅行团

596
01:07:19,000 --> 01:07:25,000
 with minimal length where x is visited after city y.
具有最小长度，其中 x 在城市 y 之后访问。

597
01:07:28,000 --> 01:07:31,000
 It is just like you are a delivery truck, so you are doing a delivery.
就像你是一辆送货卡车，所以你正在送货。

598
01:07:33,000 --> 01:07:39,000
 So your solution must be such that you visit x after city y.
所以你的解决方案必须是你在城市 y 之后访问 x。

599
01:07:40,000 --> 01:07:42,000
 Then you ask why?
那你问为什么？

600
01:07:42,000 --> 01:07:44,000
 Why must it be the case?
为什么一定是这样呢？

601
01:07:45,000 --> 01:07:49,000
 Perhaps x is a more important customer.
也许x是一个更重要的客户。

602
01:07:50,000 --> 01:07:52,000
 So you have to make sure you visit x.
所以你必须确保你访问了x。

603
01:07:53,000 --> 01:07:55,000
 After that, you visit y.
之后，您访问 y。

604
01:07:57,000 --> 01:08:02,000
 So these are constraints that can be incorporated in a practical scenario.
因此，这些都是可以纳入实际场景中的约束。

605
01:08:03,000 --> 01:08:15,000
 So between your objective function and your constraint, we can put together a simple table.
因此，在您的目标函数和约束之间，我们可以制作一个简单的表格。

606
01:08:20,000 --> 01:08:31,000
 So you have your constraints in red, yes, no, and then you have your objective function.
所以你的约束是红色的，是的，不是，然后你就有了你的目标函数。

607
01:08:33,000 --> 01:08:44,000
 So based on these two categorizations of yes and no for the constraint and objective function, you have four possibilities.
因此，基于约束和目标函数的“是”和“否”这两种分类，您有四种可能性。

608
01:08:45,000 --> 01:08:56,000
 The first one when you have yes for objective function and constraints, you have what we call constraint optimization problem.
第一个当你的目标函数和约束条件为“是”时，你就遇到了我们所说的约束优化问题。

609
01:08:57,000 --> 01:09:02,000
 C O P, objective function and then you have constraint.
COP、目标函数，然后就有约束。

610
01:09:03,000 --> 01:09:06,000
 Constraint optimization problem.
约束优化问题。

611
01:09:09,000 --> 01:09:22,000
 When you only have your constraints, the first row under constraints yes and then objective function no.
当您只有约束时，约束下的第一行是，然后目标函数为否。

612
01:09:22,000 --> 01:09:27,000
 That is a CS constraint satisfaction problem, CST.
这就是 CS 约束满足问题，CST。

613
01:09:29,000 --> 01:09:33,000
 And the next one is free optimization problem.
下一个是自由优化问题。

614
01:09:35,000 --> 01:09:39,000
 So let's think about the eight queens problem.
那么我们来思考一下八皇后问题。

615
01:09:42,000 --> 01:09:47,000
 How do you formulate it as constraint satisfaction problem?
你如何将其表述为约束满足问题？

616
01:09:48,000 --> 01:09:52,000
 How does it become a constraint satisfaction problem?
它如何成为约束满足问题？

617
01:09:56,000 --> 01:09:58,000
 The eight queens problem.
八皇后问题。

618
01:10:10,000 --> 01:10:13,000
 Think about the six examples I gave you.
想想我给你的六个例子。

619
01:10:14,000 --> 01:10:21,000
 So out of the six examples, you pointed out two are valid.
因此，在六个示例中，您指出了两个是有效的。

620
01:10:22,000 --> 01:10:26,000
 So therefore only two solutions are feasible.
因此只有两种解决方案是可行的。

621
01:10:27,000 --> 01:10:29,000
 The rest are not acceptable.
其余的都不能接受。

622
01:10:30,000 --> 01:10:33,000
 Why are the two, I think it's B and F.
为什么是两个呢，我觉得是B和F。

623
01:10:34,000 --> 01:10:38,000
 Why are B and F acceptable?
为什么B和F可以接受？

624
01:10:39,000 --> 01:10:41,000
 Because you satisfy all the constraints.
因为你满足了所有的约束。

625
01:10:42,000 --> 01:10:44,000
 So there is a constraint satisfaction.
所以存在一个约束满足。

626
01:10:45,000 --> 01:10:47,000
 The rest of it are not admissible.
其余部分不予受理。

627
01:10:52,000 --> 01:10:58,000
 So what about free optimization problem?
那么自由优化问题呢？

628
01:11:01,000 --> 01:11:07,000
 How do you formulate the eight queens as a free optimization problem?
如何将八皇后表述为自由优化问题？

629
01:11:12,000 --> 01:11:17,000
 Remember your free optimization, you only have objective function.
记住你的自由优化，你只有目标函数。

630
01:11:18,000 --> 01:11:20,000
 There are no constraints.
没有任何限制。

631
01:11:22,000 --> 01:11:23,000
 How do you formulate it?
你如何表述它？

632
01:11:23,000 --> 01:11:28,000
 Or tell me or put to me the question is what am I trying to solve for?
或者告诉我或向我提出问题是我要解决什么问题？

633
01:11:29,000 --> 01:11:31,000
 Or how would it be formulated?
或者说如何表述？

634
01:11:41,000 --> 01:11:42,000
 Any thoughts?
有什么想法吗？

635
01:11:50,000 --> 01:11:59,000
 So when I ask you, when we are comparing the layout of the eight queens,
所以当我问你，当我们在比较八个皇后的布局时，

636
01:12:00,000 --> 01:12:03,000
 so I ask you is this better or is this better?
所以我问你这个更好还是这个更好？

637
01:12:06,000 --> 01:12:10,000
 So you must have a way of measuring which is better, isn't it?
所以你必须有一种衡量哪种方法更好的方法，不是吗？

638
01:12:10,000 --> 01:12:11,000
 How do you measure?
你如何测量？

639
01:12:14,000 --> 01:12:15,000
 The what?
什么？

640
01:12:17,000 --> 01:12:24,000
 Last queens, max queens not attacking, right?
最后的皇后，最大的皇后没有进攻，对吧？

641
01:12:25,000 --> 01:12:28,000
 So they are the maximum number of queens that is not attacking.
所以它们是不攻击的皇后的最大数量。

642
01:12:29,000 --> 01:12:30,000
 Correct?
正确的？

643
01:12:30,000 --> 01:12:32,000
 So that becomes your objective function.
这就是你的目标函数。

644
01:12:34,000 --> 01:12:37,000
 So you may not appreciate because it's only eight queens.
所以你可能不会欣赏，因为它只有八个皇后。

645
01:12:37,000 --> 01:12:40,000
 But what if it's a 2,000 queens?
但如果是 2,000 个皇后呢？

646
01:12:43,000 --> 01:12:47,000
 So you run it as a free optimization problem.
所以你把它作为一个免费的优化问题来运行。

647
01:12:47,000 --> 01:12:50,000
 All you want is that for your algorithm just give me the maximum.
您想要的只是为您的算法提供最大值。

648
01:12:52,000 --> 01:13:01,000
 Find a configuration that has the maximum number of queens that are not attacking.
找到一个配置，其中不攻击的皇后数量最多。

649
01:13:02,000 --> 01:13:03,000
 All right.
好的。

650
01:13:06,000 --> 01:13:14,000
 Now what about the COP constraint optimization problem?
那么 COP 约束优化问题呢？

651
01:13:17,000 --> 01:13:20,000
 How do you formulate the eight queens?
八位皇后是如何组成的？

652
01:13:24,000 --> 01:13:28,000
 Remember constraint optimization, you have constraints,
记住约束优化，你有约束，

653
01:13:28,000 --> 01:13:31,000
 you also have objective function.
你也有目标函数。

654
01:14:29,000 --> 01:14:35,000
 Phrase it to be such that it is COP constraint optimization.
将其表述为 COP 约束优化。

655
01:14:43,000 --> 01:14:44,000
 Maximum?
最大限度？

656
01:14:46,000 --> 01:14:49,000
 So why is it a constraint optimization?
那么为什么是约束优化呢？

657
01:14:59,000 --> 01:15:11,000
 So the maximum number of queens, okay, you are right, right?
那么皇后的最大数量，好吧，你是对的，对吧？

658
01:15:12,000 --> 01:15:16,000
 But the objective function, okay, maybe I should ask you this question.
但是目标函数，好吧，也许我应该问你这个问题。

659
01:15:16,000 --> 01:15:18,000
 How do you formulate the objective function?
你如何制定目标函数？

660
01:15:24,000 --> 01:15:26,000
 Would it be based on the number of constraints that is fine?
它会基于约束的数量吗？

661
01:15:29,000 --> 01:15:37,000
 In other words, the objective function tells you how good a solution is, right?
换句话说，目标函数告诉您解决方案有多好，对吗？

662
01:15:38,000 --> 01:15:42,000
 So if I ask you how good it is, you say this is eight.
所以如果我问你有多好，你会说这是八。

663
01:15:43,000 --> 01:15:48,000
 The measurement of how good it is, the fineness of it is eight and so on.
衡量其好坏的标准，其细度是八等等。

664
01:15:48,000 --> 01:15:50,000
 How do you measure this eight?
你如何衡量这八个？

665
01:15:50,000 --> 01:15:52,000
 It would be based on the number of queens.
这将基于皇后的数量。

666
01:15:52,000 --> 01:15:53,000
 Am I correct?
我说得对吗？

667
01:15:53,000 --> 01:15:54,000
 That are not attacking.
那不是攻击。

668
01:15:58,000 --> 01:16:01,000
 So inherently the objective function is part of the constraint.
因此，目标函数本质上是约束的一部分。

669
01:16:01,000 --> 01:16:07,000
 Can you make it into a more clear-cut constraint optimization?
能不能把它变成一个更明确的约束优化？

670
01:16:13,000 --> 01:16:14,000
 Come, give me an example.
来来来，给我举个例子。

671
01:16:17,000 --> 01:16:19,000
 Stay close together.
保持紧密的联系。

672
01:16:20,000 --> 01:16:27,000
 As close like based on the distance possible, right?
根据距离尽可能接近，对吗？

673
01:16:28,000 --> 01:16:37,000
 Like find me a configuration, a non-attacking configuration where the queens are near to each other, right?
就像给我找一个配置，一个皇后彼此靠近的非攻击配置，对吗？

674
01:16:38,000 --> 01:16:39,000
 Any other variations?
还有其他变化吗？

675
01:16:43,000 --> 01:16:44,000
 The number of configurations?
配置数量？

676
01:16:50,000 --> 01:16:56,000
 No queens attacking each other.
没有皇后互相攻击。

677
01:16:57,000 --> 01:17:00,000
 So that will be a measure for objective function, right?
那么这将是目标函数的衡量标准，对吧？

678
01:17:06,000 --> 01:17:11,000
 The number of queens satisfied?
有多少皇后满意？

679
01:17:20,000 --> 01:17:21,000
 Uh-huh.
嗯嗯。

680
01:17:26,000 --> 01:17:28,000
 How many parts are satisfied?
有多少部分是满意的？

681
01:17:32,000 --> 01:17:38,000
 That will also be the objective function, right?
这也是目标函数，对吗？

682
01:17:39,000 --> 01:17:49,000
 How about if I tell you, okay, can you find me a configuration where the first queen must be in column three?
如果我告诉你，好吧，你能给我找到一个配置，其中第一个皇后必须在第三列吗？

683
01:17:51,000 --> 01:17:52,000
 How about that?
怎么样？

684
01:17:53,000 --> 01:17:54,000
 All right?
好的？

685
01:17:56,000 --> 01:18:00,000
 Or you could use this to your advantage if you have a 2,000 queens, for example.
或者，例如，如果您有 2,000 个皇后，您可以利用这一点。

686
01:18:00,000 --> 01:18:01,000
 All right?
好的？

687
01:18:01,000 --> 01:18:05,000
 I'm going to fix half of it to a certain position.
我要把它的一半固定到某个位置。

688
01:18:05,000 --> 01:18:08,000
 Then when I solve it, I solve a smaller scale problem.
然后当我解决它时，我解决了一个较小规模的问题。

689
01:18:10,000 --> 01:18:12,000
 So there's a, in a way, there's constraint.
所以，在某种程度上，存在着限制。

690
01:18:18,000 --> 01:18:19,000
 Okay?
好的？

691
01:18:19,000 --> 01:18:23,000
 You may not be very clear right now, but the last thing about the traveling salesman problem.
你现在可能还不是很清楚，但是关于旅行商问题的最后一点。

692
01:18:23,000 --> 01:18:25,000
 Traveling salesman problem.
旅行商问题。

693
01:18:26,000 --> 01:18:32,000
 How do we go about making it into a free optimization problem?
我们如何将其变成一个自由优化问题？

694
01:18:33,000 --> 01:18:40,000
 In the context of a traveling salesman problem, how is it a free optimization problem?
在旅行商问题的背景下，它如何成为一个自由优化问题？

695
01:18:51,000 --> 01:18:56,000
 Remember, free optimization problem, only the objective function.
请记住，自由优化问题，只有目标函数。

696
01:18:56,000 --> 01:18:57,000
 All right?
好的？

697
01:19:02,000 --> 01:19:18,000
 So, you have n number of cities, right?
那么，你有 n 个城市，对吧？

698
01:19:18,000 --> 01:19:20,000
 Find me a tour sequence.
给我找一个游览顺序。

699
01:19:20,000 --> 01:19:26,000
 So just to be sure you know, you are clear about the traveling salesman.
所以为了确保你知道，你对旅行推销员很清楚。

700
01:19:32,000 --> 01:19:41,000
 So, for example, you have, right?
那么，举例来说，你有，对吧？

701
01:19:41,000 --> 01:19:54,000
 8 city, 3, 6, F, G, H, right?
8个城市，3、6、F、G、H，对吧？

702
01:19:54,000 --> 01:20:18,000
 So, a tour sequence could mean like, say, A, D, H, F, C, G, E, N, B.
因此，游览顺序可能意味着 A、D、H、F、C、G、E、N、B。

703
01:20:18,000 --> 01:20:20,000
 That could be a tour sequence.
这可能是一个巡演序列。

704
01:20:20,000 --> 01:20:21,000
 All right?
好的？

705
01:20:21,000 --> 01:20:47,000
 So what this means is this is A to D, and then D to H, and then H to F, F to C, and then C to G, and then B, and then B.
所以这意味着这是A到D，然后D到H，然后H到F，F到C，然后C到G，然后B，然后B。

706
01:20:48,000 --> 01:20:50,000
 That will be the end.
那将是结束。

707
01:20:50,000 --> 01:20:58,000
 But normally when we go back to the original point, just like in distribution, you have to go back to the headquarter, right?
但通常我们回到原点，就像分销一样，你必须回到总部，对吧？

708
01:20:58,000 --> 01:21:08,000
 So when it goes back to the original, we call it a closed circuit.
所以当它回到原来的时候，我们称之为闭路。

709
01:21:09,000 --> 01:21:10,000
 All right?
好的？

710
01:21:10,000 --> 01:21:18,000
 So it visits each and every node once and only once, and then goes back to the original starting point.
因此它会访问每个节点一次且仅一次，然后返回到原始起点。

711
01:21:18,000 --> 01:21:27,000
 So the cost function will be the total distance that it has to travel.
因此，成本函数将是它必须行驶的总距离。

712
01:21:27,000 --> 01:21:28,000
 All right?
好的？

713
01:21:28,000 --> 01:21:44,000
 Now, so I'm asking you, can you formulate this, or what would make it into a free optimization problem?
现在，我问你，你能把这个公式表述出来吗？或者什么可以使它成为一个自由优化问题？

714
01:21:44,000 --> 01:21:47,000
 Minimize the cost, all right?
把成本降到最低，好吗？

715
01:21:47,000 --> 01:21:49,000
 Minimize the distance.
尽量缩短距离。

716
01:21:49,000 --> 01:21:51,000
 Free optimization, all right?
免费优化可以吗？

717
01:21:51,000 --> 01:21:54,000
 Only 8 city, not difficult.
只有8个城市，不难。

718
01:21:54,000 --> 01:21:57,000
 But what if it's a 10,000 city?
但如果这是一个 10,000 人的城市呢？

719
01:21:57,000 --> 01:22:00,000
 You may not know what's the best.
你可能不知道什么是最好的。

720
01:22:00,000 --> 01:22:01,000
 All right?
好的？

721
01:22:01,000 --> 01:22:06,000
 So my problem is just find me the best.
所以我的问题是找到最好的。

722
01:22:06,000 --> 01:22:07,000
 All right?
好的？

723
01:22:07,000 --> 01:22:09,000
 I don't know what's the best, all right?
我不知道什么是最好的，好吗？

724
01:22:09,000 --> 01:22:11,000
 But I just need a good solution.
但我只需要一个好的解决方案。

725
01:22:11,000 --> 01:22:12,000
 So just find me the best.
所以找我最好的。

726
01:22:12,000 --> 01:22:18,000
 Free optimization.
免费优化。

727
01:22:18,000 --> 01:22:20,000
 Okay?
好的？

728
01:22:21,000 --> 01:22:28,000
 How about your constraint optimization problem?
你的约束优化问题怎么样？

729
01:22:38,000 --> 01:22:44,000
 Find specific cities.
查找特定城市。

730
01:22:45,000 --> 01:22:54,000
 So, okay.
那么，好吧。

731
01:22:54,000 --> 01:23:00,000
 Like visiting a certain city first, like what we said, right?
就像我们说的，先参观某个城市，对吗？

732
01:23:00,000 --> 01:23:03,000
 X before Y, okay?
X 在 Y 之前，好吗？

733
01:23:03,000 --> 01:23:06,000
 So very practical, right?
非常实用，对吧？

734
01:23:06,000 --> 01:23:10,000
 Because in logistics, quite common inside that.
因为在物流里面，这很常见。

735
01:23:10,000 --> 01:23:15,000
 So find me a minimum tour, all right?
所以给我找一个最低限度的旅行，好吗？

736
01:23:15,000 --> 01:23:23,000
 Where city X or city D must be visited first before G.
必须先访问城市 X 或城市 D，然后再访问城市 G。

737
01:23:23,000 --> 01:23:29,000
 And that's the constraint.
这就是限制。

738
01:23:29,000 --> 01:23:38,000
 What about CSP?
那么 CSP 呢？

739
01:23:38,000 --> 01:23:40,000
 Constraint satisfaction?
约束满足？

740
01:23:40,000 --> 01:23:47,000
 If you look at the table, only got constraints.
如果你看一下表格，就会发现只有约束。

741
01:23:47,000 --> 01:23:51,000
 Don't care about minimum.
不关心最低限度。

742
01:23:51,000 --> 01:23:53,000
 Don't care about minimum, all right?
不要关心最低限度，好吗？

743
01:23:53,000 --> 01:23:56,000
 I have a certain constraint, all right?
我有一定的限制，好吗？

744
01:23:56,000 --> 01:24:00,000
 Maybe a certain sequence of constraints.
也许有一定的约束顺序。

745
01:24:00,000 --> 01:24:03,000
 Just find me a solution, all right?
给我一个解决办法，好吗？

746
01:24:03,000 --> 01:24:09,000
 As long as it satisfies that constraint, it's a good solution.
只要满足这个约束，它就是一个很好的解决方案。

747
01:24:09,000 --> 01:24:13,000
 So it's just like your traveling salesman problem, for example,
这就像你的旅行推销员问题，例如，

748
01:24:13,000 --> 01:24:18,000
 in your delivery truck, where you have a big truck,
在你的送货卡车里，你有一辆大卡车，

749
01:24:18,000 --> 01:24:24,000
 you want to deliver 120 items, all right?
您想配送 120 件物品，可以吗？

750
01:24:24,000 --> 01:24:28,000
 So the way you put the items in the truck,
所以你把物品放进卡车的方式

751
01:24:28,000 --> 01:24:34,000
 what will be your consideration?
你会考虑什么？

752
01:24:34,000 --> 01:24:36,000
 You know what's a truck, right?
你知道什么是卡车吧？

753
01:24:36,000 --> 01:24:40,000
 So where you put things, you stack things in.
所以你把东西放在哪里，你就把东西堆放在哪里。

754
01:24:40,000 --> 01:24:47,000
 So the first one you come, the first one you want to deliver, all right?
所以你来的第一个，你想交付的第一个，好吗？

755
01:24:47,000 --> 01:24:50,000
 Hopefully it will be at the end of the truck.
希望它会在卡车的尽头。

756
01:24:50,000 --> 01:24:56,000
 You don't want to go all the way to the back, you know, to dig it out.
你知道，你不想一直走到后面去把它挖出来。

757
01:24:56,000 --> 01:25:00,000
 So that means that there will be a certain so-called
所以这意味着将会有某种所谓的

758
01:25:00,000 --> 01:25:05,000
 the way you plan your traveling, okay?
你计划旅行的方式，好吗？

759
01:25:05,000 --> 01:25:10,000
 You have to consider that, okay?
你必须考虑这一点，好吗？

760
01:25:10,000 --> 01:25:20,000
 So this is how we categorize according to the optimization and constraints.
这就是我们根据优化和约束进行分类的方式。

761
01:25:20,000 --> 01:25:24,000
 Okay.
好的。

762
01:25:24,000 --> 01:25:29,000
 So we have, so far, just classified the problems, all right?
到目前为止，我们刚刚对问题进行了分类，好吗？

763
01:25:29,000 --> 01:25:32,000
 We talked about the different types of problems, you know,
我们讨论了不同类型的问题，你知道，

764
01:25:32,000 --> 01:25:38,000
 how we can actually approach or formulate it, all right?
我们如何实际处理或制定它，好吗？

765
01:25:38,000 --> 01:25:41,000
 So we haven't talked about the problem solvers, all right?
所以我们还没有讨论问题解决者，好吗？

766
01:25:41,000 --> 01:25:46,000
 We didn't really consider the methods of how we're going to solve it, okay?
我们并没有真正考虑过如何解决这个问题，好吗？

767
01:25:46,000 --> 01:25:58,000
 So in order to classify it, all right, according to the MP-ness of the problem,
所以为了对它进行分类，好吧，根据问题的 MP-ness，

768
01:25:58,000 --> 01:26:03,000
 so we need to know the properties of the problem solvers.
所以我们需要了解问题解决者的属性。

769
01:26:03,000 --> 01:26:11,000
 So MP stands for non-deterministic polynomial.
所以MP代表非确定性多项式。

770
01:26:11,000 --> 01:26:15,000
 You all know what a polynomial is, right?
大家都知道什么是多项式吧？

771
01:26:15,000 --> 01:26:31,000
 For example, if I tell you fn equal to n to the power of 48 plus 72n
例如，如果我告诉你 fn 等于 n 的 48 次方加 72n

772
01:26:31,000 --> 01:26:39,000
 to the power of 7 plus 1 million.
7 次方加 100 万。

773
01:26:39,000 --> 01:26:43,000
 That's a polynomial, all right?
这是一个多项式，好吗？

774
01:26:43,000 --> 01:26:45,000
 What's the polynomial?
多项式是什么？

775
01:26:45,000 --> 01:26:51,000
 Degree to the power of 48.
度数的 48 次方。

776
01:26:51,000 --> 01:26:55,000
 Then you say non-deterministic polynomial.
然后你说非确定性多项式。

777
01:26:55,000 --> 01:27:00,000
 What does that mean?
这意味着什么？

778
01:27:00,000 --> 01:27:08,000
 Non-deterministic.
不确定性。

779
01:27:08,000 --> 01:27:12,000
 I don't really know this.
我真的不知道这个。

780
01:27:12,000 --> 01:27:14,000
 I don't know.
我不知道。

781
01:27:14,000 --> 01:27:18,000
 Then you ask me if you have a problem to solve, you ask me,
然后你问我是否有问题需要解决，你问我，

782
01:27:18,000 --> 01:27:20,000
 okay, how long is it going to solve?
好的，请问多久能解决？

783
01:27:20,000 --> 01:27:24,000
 If I know, I can tell you, yeah, this is the worst case, right?
如果我知道，我可以告诉你，是的，这是最坏的情况，对吗？

784
01:27:24,000 --> 01:27:27,000
 According to n, all right?
根据n，可以吗？

785
01:27:27,000 --> 01:27:30,000
 The complexity of this is according to n.
这个的复杂度取决于n。

786
01:27:30,000 --> 01:27:35,000
 But if it is an MP, non-deterministic polynomial,
但如果它是一个 MP、非确定性多项式，

787
01:27:35,000 --> 01:27:39,000
 and then you ask me, okay, how long is it going to solve this problem?
然后你问我，好吧，这个问题需要多长时间才能解决？

788
01:27:39,000 --> 01:27:43,000
 Well, gee, I don't know, all right, because it's non-deterministic.
好吧，哎呀，我不知道，好吧，因为它是不确定的。

789
01:27:43,000 --> 01:27:48,000
 I haven't found a polynomial algorithm.
我还没有找到多项式算法。

790
01:27:48,000 --> 01:27:55,000
 So that's the class of types of problems that we are talking about.
这就是我们正在讨论的一类问题类型。

791
01:27:55,000 --> 01:28:03,000
 Basically, what we want to do is to be able to know how difficult the problem is, right?
基本上，我们想要做的就是能够知道问题有多困难，对吗？

792
01:28:03,000 --> 01:28:07,000
 Now, this is very useful.
现在，这非常有用。

793
01:28:07,000 --> 01:28:10,000
 There are two classes of problems.
有两类问题。

794
01:28:10,000 --> 01:28:17,000
 One is a discrete problem, and one is a continuous problem, right?
一种是离散问题，一种是连续问题，对吗？

795
01:28:17,000 --> 01:28:25,000
 So the discrete problems, right, the solution is in discrete spaces.
所以离散问题，对吧，解决方案是在离散空间中。

796
01:28:25,000 --> 01:28:29,000
 For example, the traveling salesman problem, the way we have formulated it,
例如，旅行商问题，我们表述它的方式，

797
01:28:29,000 --> 01:28:31,000
 it is a discrete problem, right?
这是一个离散问题，对吗？

798
01:28:31,000 --> 01:28:33,000
 It's a discrete problem.
这是一个离散问题。

799
01:28:33,000 --> 01:28:38,000
 It is a discrete combinatorial problem.
这是一个离散组合问题。

800
01:28:38,000 --> 01:28:44,000
 We are basically finding out from the set of finite possibilities of combinations, right?
我们基本上是从一组有限的组合可能性中找出答案，对吗？

801
01:28:45,000 --> 01:28:48,000
 Like the n-queens problem.
就像 n 皇后问题一样。

802
01:28:48,000 --> 01:28:53,000
 So there is a discrete combinatorial problem.
因此存在离散组合问题。

803
01:28:53,000 --> 01:28:58,000
 The other type of problem is a continuous problem.
另一种类型的问题是连续问题。

804
01:28:58,000 --> 01:29:04,000
 For example, you want to tune your PID controller, right?
例如，您想调整 PID 控制器，对吧？

805
01:29:04,000 --> 01:29:11,000
 You want to set, you want to determine so-called optimal parameters, right?
你要设定、你要确定所谓的最优参数，对吗？

806
01:29:11,000 --> 01:29:15,000
 So that can be a continuous problem because you are finding a variable.
所以这可能是一个持续的问题，因为你正在寻找一个变量。

807
01:29:15,000 --> 01:29:23,000
 The values of the so-called parameters could be 0.2178, you know, or 1.766 and so on.
所谓的参数值可以是 0.2178，或者 1.766 等等。

808
01:29:23,000 --> 01:29:25,000
 So it's all a continuous space.
所以这都是一个连续的空间。

809
01:29:25,000 --> 01:29:30,000
 So there's a continuous type of problem, right?
所以问题是持续存在的，对吧？

810
01:29:30,000 --> 01:29:35,000
 So you have so-called discrete as well as a continuous.
所以你有所谓的离散和连续。

811
01:29:35,000 --> 01:29:47,000
 Now, the theory of NP-ness is very useful, particularly for discrete type of problem.
现在，NP 性理论非常有用，特别是对于离散类型的问题。

812
01:29:47,000 --> 01:29:49,000
 There are many examples of discrete problem.
离散问题的例子有很多。

813
01:29:49,000 --> 01:29:57,000
 The two we talk about would be the so-called n-queens and the traveling salesman problem.
我们讨论的两个问题就是所谓的 n 皇后问题和旅行商问题。

814
01:29:57,000 --> 01:30:04,000
 Now, based on NP, we can have an understanding on how difficult the problem is
现在，根据NP，我们可以了解问题的难度

815
01:30:04,000 --> 01:30:11,000
 or how do we so-called characterize the complexity of the problem.
或者说我们如何所谓描述问题的复杂性。

816
01:30:11,000 --> 01:30:26,000
 So in order to categorize it, we think about so-called the problem size.
因此，为了对其进行分类，我们会考虑所谓的问题大小。

817
01:30:26,000 --> 01:30:30,000
 So problem size is the dimensionality of the problem I can
所以问题大小是我可以解决的问题的维度

818
01:30:30,000 --> 01:30:36,000
 and the number of different values of the problem variables.
以及问题变量的不同值的数量。

819
01:30:36,000 --> 01:30:42,000
 In your 8-queens problem, what is the dimension?
在你的 8 皇后问题中，维度是多少？

820
01:30:42,000 --> 01:30:44,000
 8, right?
8，对吗？

821
01:30:44,000 --> 01:30:47,000
 The n would be equal to 8.
n 将等于 8。

822
01:30:47,000 --> 01:30:56,000
 If it's a thousand queen, thousand, the traveling salesman problem, right?
如果是千皇后，千，旅行商问题，对吗？

823
01:30:57,000 --> 01:31:02,000
 50 city, dimension would be 50, right?
50个城市，维度就是50，对吗？

824
01:31:02,000 --> 01:31:04,000
 And so on.
等等。

825
01:31:04,000 --> 01:31:07,000
 And then we consider the running time.
然后我们考虑运行时间。

826
01:31:07,000 --> 01:31:13,000
 There's a number of operations the algorithm takes to terminate.
该算法需要执行许多操作才能终止。

827
01:31:13,000 --> 01:31:20,000
 So what we want to know as far as the running time is concerned, running time is concerned, right?
那么我们想知道的是运行时间，运行时间，对吧？

828
01:31:20,000 --> 01:31:24,000
 The worst case is a function of the problem size, right?
最坏的情况是问题大小的函数，对吗？

829
01:31:24,000 --> 01:31:27,000
 There's a polynomial algorithm or not.
有或没有多项式算法。

830
01:31:27,000 --> 01:31:32,000
 Ideally, if there's a polynomial algorithm, that problem is easy.
理想情况下，如果有多项式算法，那么这个问题就很容易解决。

831
01:31:32,000 --> 01:31:37,000
 For example, if I ask you to do a sorting, what's so difficult?
比如说我让你做一个排序，有什么难的呢？

832
01:31:37,000 --> 01:31:40,000
 At most, it's n squared.
最多是n平方。

833
01:31:40,000 --> 01:31:45,000
 That's definitely a polynomial algorithm, correct?
这绝对是一个多项式算法，对吗？

834
01:31:45,000 --> 01:31:51,000
 Or is it a super polynomial or is it an exponential?
或者它是一个超多项式还是一个指数？

835
01:31:51,000 --> 01:32:03,000
 So in your traveling salesman problem, what's the size or what's the number of possibilities of your traveling salesman problem?
那么，在你的旅行推销员问题中，你的旅行推销员问题的规模或可能性有多少？

836
01:32:03,000 --> 01:32:09,000
 If you are looking for the sequence.
如果您正在寻找顺序。

837
01:32:09,000 --> 01:32:13,000
 If I give you 8 city, how many possible combinations?
如果我给你8个城市，有多少种可能的组合？

838
01:32:23,000 --> 01:32:27,000
 Let's say you have an 8 city traveling salesman problem, right?
假设您有一个 8 个城市的旅行商问题，对吧？

839
01:32:40,000 --> 01:32:48,000
 Can you say this is 8 factorial, right?
你能说这是 8 的阶乘吗？

840
01:32:48,000 --> 01:32:52,000
 8 times 7, 1.
8 乘以 7, 1。

841
01:32:52,000 --> 01:33:01,000
 You have 50 city, 50 factorial, right?
你有 50 个城市，50 个阶乘，对吧？

842
01:33:01,000 --> 01:33:06,000
 Can you see the way it increased?
你能看到它增加的方式吗？

843
01:33:06,000 --> 01:33:10,000
 It's not linear, okay?
这不是线性的，好吗？

844
01:33:10,000 --> 01:33:15,000
 So that's one of the reasons why it's considered as intractable, right?
这就是为什么它被认为是棘手的原因之一，对吧？

845
01:33:15,000 --> 01:33:21,000
 As the size of the so-called problem increases.
随着所谓问题的规模增加。

846
01:33:21,000 --> 01:33:24,000
 So we consider also the running time.
所以我们还考虑运行时间。

847
01:33:24,000 --> 01:33:27,000
 So normally in an algorithm, right?
通常在算法中，对吧？

848
01:33:27,000 --> 01:33:30,000
 When you look at an algorithm, you look for the steps.
当您查看算法时，您会寻找步骤。

849
01:33:30,000 --> 01:33:35,000
 Usually there's a part, the iteration part that gives on repeating, right?
通常有一个部分，迭代部分会重复，对吧？

850
01:33:35,000 --> 01:33:42,000
 So you look for the most so-called prominent or crucial step, right?
所以你寻找的是最所谓的最突出或最关键的一步，对吗？

851
01:33:42,000 --> 01:33:56,000
 Where the repetition of the algorithm, for example, may be going through a trillion times, for example.
例如，算法的重复可能会经历一万亿次。

852
01:33:56,000 --> 01:34:06,000
 And the third point we want to, when we talk about emptiness, will be the problem reduction, right?
我们要讲的第三点，当我们谈论空性时，问题会减少，对吧？

853
01:34:06,000 --> 01:34:13,000
 So transforming current problems onto another wire mapping.
因此，将当前问题转化为另一个接线图。

854
01:34:13,000 --> 01:34:16,000
 There are many problems that are already known.
有许多问题是已知的。

855
01:34:16,000 --> 01:34:21,000
 We already, we have good understanding of the problem.
我们已经对这个问题有了很好的理解。

856
01:34:21,000 --> 01:34:25,000
 For example, the traveling salesman problem.
例如，旅行商问题。

857
01:34:25,000 --> 01:34:29,000
 Classical computer science problem, right?
经典计算机科学问题，对吧？

858
01:34:29,000 --> 01:34:33,000
 We have good understanding of the traveling salesman problem, okay?
我们对旅行商问题已经很了解了，好吗？

859
01:34:33,000 --> 01:34:40,000
 We study it because it is very relevant to many practical scenarios, right?
我们研究它是因为它与很多实际场景非常相关，对吗？

860
01:34:40,000 --> 01:34:48,000
 So when you're out there, for example, your boss asks you to solve a particular problem or formulate a particular problem, right?
例如，当你在外面时，你的老板要求你解决一个特定的问题或提出一个特定的问题，对吧？

861
01:34:48,000 --> 01:34:53,000
 So you have all these descriptions of what the requirements are and so on.
因此，您已经了解了所有这些要求的描述等等。

862
01:34:53,000 --> 01:34:58,000
 Now, if you are so-called a programmer or practitioner, right?
现在，如果你是所谓的程序员或从业者，对吧？

863
01:34:58,000 --> 01:35:09,000
 So very likely what you would do is that you will find maybe a relevant, well-studied or known problem.
因此，您很可能会发现一个相关的、经过充分研究的或已知的问题。

864
01:35:10,000 --> 01:35:15,000
 So let's say the problem that you have, right?
那么让我们说一下你遇到的问题吧？

865
01:35:15,000 --> 01:35:20,000
 You can map it into a traveling salesman problem or TSP.
您可以将其映射到旅行商问题或 TSP。

866
01:35:20,000 --> 01:35:28,000
 Then you can apply the method and the approaches that you already know or you already have it, right?
然后你就可以应用你已经知道或者已经有了的方法和途径，对吧？

867
01:35:28,000 --> 01:35:31,000
 And then to solve the problem, okay?
然后再去解决问题，好吗？

868
01:35:31,000 --> 01:35:41,000
 So in the theory of NpNAS, right, we look for such so-called such kind of problems, right?
那么在NpNAS的理论中，对吧，我们寻找这样的所谓的这类问题，对吧？

869
01:35:41,000 --> 01:35:46,000
 So that's what we call the NP completeness, okay?
这就是我们所说的 NP 完备性，好吗？

870
01:35:46,000 --> 01:35:59,000
 So, you know, we look at the categorization on how we categorize according to the NP characteristics, okay?
所以，你知道，我们看看如何根据 NP 特征进行分类，好吗？

871
01:35:59,000 --> 01:36:02,000
 So let's take a break, right?
那么我们休息一下吧？

872
01:36:02,000 --> 01:36:08,000
 And then we come back before 8.30.
然后我们在8.30之前回来。

873
01:36:08,000 --> 01:36:10,000
 Does that all right?
这样可以吗？

874
01:36:29,000 --> 01:36:31,000
 Thank you.
谢谢。

875
01:36:59,000 --> 01:37:02,000
 Thank you.
谢谢。

876
01:37:29,000 --> 01:37:32,000
 Thank you.
谢谢。

877
01:37:59,000 --> 01:38:01,000
 Thank you.
谢谢。

878
01:38:29,000 --> 01:38:32,000
 Thank you.
谢谢。

879
01:38:59,000 --> 01:39:01,000
 Thank you.
谢谢。

880
01:39:29,000 --> 01:39:32,000
 Thank you.
谢谢。

881
01:39:59,000 --> 01:40:01,000
 Thank you.
谢谢。

882
01:40:29,000 --> 01:40:32,000
 Thank you.
谢谢。

883
01:40:59,000 --> 01:41:01,000
 Thank you.
谢谢。

884
01:41:29,000 --> 01:41:31,000
 Thank you.
谢谢。

885
01:41:59,000 --> 01:42:01,000
 Thank you.
谢谢。

886
01:42:29,000 --> 01:42:31,000
 Thank you.
谢谢。

887
01:42:59,000 --> 01:43:01,000
 Thank you.
谢谢。

888
01:43:29,000 --> 01:43:31,000
 Thank you.
谢谢。

889
01:43:59,000 --> 01:44:01,000
 Thank you.
谢谢。

890
01:44:29,000 --> 01:44:31,000
 Thank you.
谢谢。

891
01:44:59,000 --> 01:45:01,000
 Thank you.
谢谢。

892
01:45:29,000 --> 01:45:31,000
 Thank you.
谢谢。

893
01:45:59,000 --> 01:46:01,000
 Thank you.
谢谢。

894
01:46:29,000 --> 01:46:31,000
 Thank you.
谢谢。

895
01:46:59,000 --> 01:47:01,000
 Thank you.
谢谢。

896
01:47:29,000 --> 01:47:31,000
 Thank you.
谢谢。

897
01:47:59,000 --> 01:48:01,000
 Thank you.
谢谢。

898
01:48:29,000 --> 01:48:31,000
 Thank you.
谢谢。

899
01:48:59,000 --> 01:49:01,000
 Thank you.
谢谢。

900
01:49:29,000 --> 01:49:31,000
 Thank you.
谢谢。

901
01:49:59,000 --> 01:50:01,000
 Thank you.
谢谢。

902
01:50:29,000 --> 01:50:31,000
 Thank you.
谢谢。

903
01:50:59,000 --> 01:51:01,000
 Thank you.
谢谢。

904
01:51:29,000 --> 01:51:31,000
 Thank you.
谢谢。

905
01:51:59,000 --> 01:52:01,000
 Thank you.
谢谢。

906
01:52:29,000 --> 01:52:31,000
 Thank you.
谢谢。

907
01:52:59,000 --> 01:53:01,000
 Thank you.
谢谢。

908
01:53:29,000 --> 01:53:31,000
 Thank you.
谢谢。

909
01:53:59,000 --> 01:54:01,000
 Thank you.
谢谢。

910
01:54:29,000 --> 01:54:31,000
 Thank you.
谢谢。

911
01:54:59,000 --> 01:55:01,000
 Thank you.
谢谢。

912
01:55:29,000 --> 01:55:31,000
 Thank you.
谢谢。

913
01:55:59,000 --> 01:56:01,000
 Thank you.
谢谢。

914
01:56:29,000 --> 01:56:31,000
 Thank you.
谢谢。

915
01:56:59,000 --> 01:57:01,000
 Thank you.
谢谢。

916
01:57:29,000 --> 01:57:31,000
 Thank you.
谢谢。

917
01:57:59,000 --> 01:58:01,000
 Thank you.
谢谢。

918
01:58:29,000 --> 01:58:31,000
 Thank you.
谢谢。

919
01:58:59,000 --> 01:59:01,000
 Thank you.
谢谢。

920
01:59:29,000 --> 01:59:31,000
 Thank you.
谢谢。

921
01:59:54,000 --> 01:59:56,000
 Okay.
好的。

922
01:59:56,000 --> 01:59:57,000
 We are back.
我们回来了。

923
01:59:57,000 --> 02:00:26,000
 So let's pick up from where we left off.
那么让我们从上次停下的地方继续。

924
02:00:27,000 --> 02:00:28,000
 Okay.
好的。

925
02:00:28,000 --> 02:00:40,000
 We are into trying to classify or categorize the problems.
我们正在尝试对问题进行分类或归类。

926
02:00:40,000 --> 02:00:46,000
 So we have looked at from the angle of the types of problems that we can deal with and
因此，我们从我们可以处理的问题类型的角度进行了研究，

927
02:00:46,000 --> 02:00:47,000
 so on.
很快。

928
02:00:47,000 --> 02:00:51,000
 Now let's take a look at another angle.
现在我们再换一个角度来看一下。

929
02:00:51,000 --> 02:00:52,000
 That's the NP.
这就是NP。

930
02:00:52,000 --> 02:00:54,000
 What does NP stand for?
NP 代表什么？

931
02:00:54,000 --> 02:00:56,000
 What I just told you.
我刚才告诉你的。

932
02:00:56,000 --> 02:01:01,000
 NP stands for?
NP代表什么？

933
02:01:01,000 --> 02:01:12,000
 Non-polynomial.
非多项式。

934
02:01:12,000 --> 02:01:16,000
 NP stands for non-deterministic polynomial.
NP 代表非确定性多项式。

935
02:01:16,000 --> 02:01:17,720
 All right?
好的？

936
02:01:17,720 --> 02:01:20,000
 You know what a polynomial is.
你知道什么是多项式。

937
02:01:20,000 --> 02:01:21,000
 Okay.
好的。

938
02:01:21,000 --> 02:01:25,000
 Example, I give you n to the power of 17 plus n squared.
例如，我给你 n 的 17 次方加上 n 的平方。

939
02:01:25,000 --> 02:01:27,000
 That's a polynomial.
这是一个多项式。

940
02:01:27,000 --> 02:01:28,000
 All right?
好的？

941
02:01:28,000 --> 02:01:36,000
 Now, non-deterministic means you cannot fix a number to it.
现在，非确定性意味着您无法为其确定一个数字。

942
02:01:36,000 --> 02:01:37,000
 All right?
好的？

943
02:01:37,000 --> 02:01:39,000
 Or you can put it in this way.
或者你可以这样说。

944
02:01:39,000 --> 02:01:43,000
 If you have a problem, then you categorize it as NP.
如果你有问题，那么你将其归类为 NP。

945
02:01:43,000 --> 02:01:48,000
 So what it means is that if you were to ask me how long it takes to solve this problem
所以这意味着如果你问我解决这个问题需要多长时间

946
02:01:48,000 --> 02:01:56,000
 or how much computational resources it takes to solve this problem, if it is polynomial,
或者解决这个问题需要多少计算资源，如果它是多项式，

947
02:01:56,000 --> 02:02:02,000
 I could tell you, okay, this is n to the power of 13, for example.
我可以告诉你，好吧，例如，这是 13 的 n 次方。

948
02:02:02,000 --> 02:02:04,000
 So it depends on n.
所以这取决于n。

949
02:02:04,000 --> 02:02:05,000
 All right?
好的？

950
02:02:05,000 --> 02:02:09,000
 Or if it's non-deterministic, I say, gee, I don't really know.
或者，如果它是不确定的，我会说，哎呀，我真的不知道。

951
02:02:09,000 --> 02:02:10,000
 You know?
你知道？

952
02:02:10,000 --> 02:02:11,000
 It's non-deterministic.
这是不确定的。

953
02:02:11,000 --> 02:02:12,000
 Okay?
好的？

954
02:02:12,000 --> 02:02:18,000
 So what is the kind of problems or so-called types of problems that we want to deal with?
那么我们要处理的问题类型是什么呢？

955
02:02:18,000 --> 02:02:24,000
 So accordingly, we consider the size of a problem, the running time, and so on.
因此，我们相应地考虑问题的大小、运行时间等等。

956
02:02:24,000 --> 02:02:31,000
 Now, we also mentioned about two types.
现在，我们还提到了两种类型。

957
02:02:31,000 --> 02:02:34,000
 That is the discrete problem and the continuous problem.
这就是离散问题和连续问题。

958
02:02:34,000 --> 02:02:40,000
 So this NP-ness is particularly useful for the discrete type of problem.
因此，这种 NP 性质对于离散类型的问题特别有用。

959
02:02:40,000 --> 02:02:48,000
 For example, as I said or said it many times, examples, the eight queens or the traveling salesman problem.
例如，正如我说过或说过很多次的那样，八皇后或旅行商问题。

960
02:02:48,000 --> 02:02:49,000
 All right?
好的？

961
02:02:49,000 --> 02:02:56,000
 So what we want to know is the understanding in terms of complexity based on the dimensionality.
所以我们想知道的是基于维度的复杂性的理解。

962
02:02:56,000 --> 02:03:03,000
 If it is a traveling salesman problem, how would it increase according to n?
如果是旅行商问题，如何根据n增加？

963
02:03:03,000 --> 02:03:04,000
 All right?
好的？

964
02:03:04,000 --> 02:03:07,000
 So it's certainly not linear or polynomial.
所以它肯定不是线性或多项式的。

965
02:03:07,000 --> 02:03:08,000
 All right?
好的？

966
02:03:08,000 --> 02:03:15,000
 So far, I don't think we have a polynomial algorithm to solve it yet.
到目前为止，我认为我们还没有多项式算法来解决它。

967
02:03:15,000 --> 02:03:24,000
 You can find a polynomial algorithm to solve the simple so-called problem, like, for example,
您可以找到一个多项式算法来解决简单的所谓问题，例如，

968
02:03:24,000 --> 02:03:27,000
 to find the distance between two points.
找到两点之间的距离。

969
02:03:27,000 --> 02:03:28,000
 All right?
好的？

970
02:03:28,000 --> 02:03:30,000
 That's a polynomial.
这是一个多项式。

971
02:03:30,000 --> 02:03:37,000
 But to find the so-called shortest distance for the traveling salesman problem, it's certainly NP.
但对于旅行商问题来说，要找到所谓的最短距离，那肯定是NP问题。

972
02:03:37,000 --> 02:03:38,000
 All right?
好的？

973
02:03:38,000 --> 02:03:40,000
 Again, I put it this way.
我再说一遍。

974
02:03:40,000 --> 02:03:41,000
 I cannot tell you.
我不能告诉你。

975
02:03:41,000 --> 02:03:42,000
 All right?
好的？

976
02:03:42,000 --> 02:03:47,000
 Or I cannot give you a polynomial categorization of it.
或者我无法给你它的多项式分类。

977
02:03:47,000 --> 02:03:56,000
 So henceforth, we can categorize the problem according to these classes.
所以从今以后，我们可以根据这些类别对问题进行分类。

978
02:03:56,000 --> 02:04:01,000
 So the class P algorithm.
所以P类算法。

979
02:04:02,000 --> 02:04:08,000
 So accordingly, it's an algorithm can solve the problem in polynomial time.
因此，它是一种可以在多项式时间内解决问题的算法。

980
02:04:08,000 --> 02:04:09,000
 All right?
好的？

981
02:04:09,000 --> 02:04:15,000
 So the worst case running time for problem size n is less than fn for some polynomial
因此，对于某些多项式，问题大小 n 的最坏情况运行时间小于 fn

982
02:04:15,000 --> 02:04:17,000
 formula.
公式。

983
02:04:17,000 --> 02:04:21,000
 So just to impress on you a little bit.
所以只是为了给你留下一点印象。

984
02:04:21,000 --> 02:04:29,000
 So this fn, all right?
所以这个fn，好吗？

985
02:04:29,000 --> 02:04:41,000
 It can be any polynomial, for example, n to the power of 136 plus 78, for example.
它可以是任何多项式，例如n的136次方加78。

986
02:04:41,000 --> 02:04:43,000
 All right?
好的？

987
02:04:43,000 --> 02:04:47,000
 Is this deterministic?
这是确定性的吗？

988
02:04:47,000 --> 02:04:48,000
 Deterministic.
确定性的。

989
02:04:48,000 --> 02:04:49,000
 All right?
好的？

990
02:04:49,000 --> 02:04:54,000
 You might get scared, gee, it's 136.
你可能会害怕，天哪，现在是 136。

991
02:04:54,000 --> 02:05:02,000
 But really what we want is from the viewpoint of problem solving, if we know, all right,
但我们真正想要的是从解决问题的角度出发，如果我们知道，好吧，

992
02:05:02,000 --> 02:05:05,000
 that is what is more important.
这才是更重要的。

993
02:05:05,000 --> 02:05:09,000
 Because if I know this is the complexity, at least I can tell my boss, you know, it's
因为如果我知道这就是复杂性，至少我可以告诉我的老板，你知道，这是

994
02:05:09,000 --> 02:05:14,000
 going to take us like 88 hours just to compute one solution.
仅计算一个解决方案就需要我们 88 小时。

995
02:05:14,000 --> 02:05:15,000
 All right?
好的？

996
02:05:15,000 --> 02:05:17,000
 That's all I can tell my boss.
这就是我能告诉我老板的一切。

997
02:05:17,000 --> 02:05:20,000
 Or I could plan my computational resources.
或者我可以规划我的计算资源。

998
02:05:20,000 --> 02:05:21,000
 All right?
好的？

999
02:05:21,000 --> 02:05:23,000
 Now I know this is the complexity.
现在我知道这就是复杂性。

1000
02:05:23,000 --> 02:05:30,000
 So I can farm it out to, let's say, 10,000 computing nodes to solve the problem.
所以我可以将其外包给 10,000 个计算节点来解决问题。

1001
02:05:30,000 --> 02:05:31,000
 All right?
好的？

1002
02:05:31,000 --> 02:05:32,000
 Why?
为什么？

1003
02:05:32,000 --> 02:05:33,000
 Because I know.
因为我知道。

1004
02:05:33,000 --> 02:05:34,000
 I know.
我知道。

1005
02:05:34,000 --> 02:05:36,000
 All right?
好的？

1006
02:05:36,000 --> 02:05:45,000
 If it is NP, well, I don't know.
如果是NP的话，我不知道。

1007
02:05:45,000 --> 02:05:52,000
 Some problems, the worst case could be some polynomial which is unknown to me.
有些问题，最坏的情况可能是一些我不知道的多项式。

1008
02:05:53,000 --> 02:05:55,000
 That's where the difficulty lies.
这就是困难所在。

1009
02:05:55,000 --> 02:05:56,000
 Okay?
好的？

1010
02:05:56,000 --> 02:05:58,000
 So there's a class of problems that we talk about.
所以我们讨论了一类问题。

1011
02:05:58,000 --> 02:06:05,000
 Now, so accordingly, if you look at the class P, you can solve the problem in polynomial
现在，相应地，如果你看一下 P 类，你可以用多项式来解决这个问题

1012
02:06:05,000 --> 02:06:06,000
 time.
时间。

1013
02:06:06,000 --> 02:06:09,000
 For example, the solving problem.
例如，解决问题。

1014
02:06:09,000 --> 02:06:10,000
 All right?
好的？

1015
02:06:10,000 --> 02:06:13,000
 N squared or n log n.
N 平方或 n log n。

1016
02:06:13,000 --> 02:06:15,000
 Very easy.
很容易。

1017
02:06:15,000 --> 02:06:16,000
 Okay?
好的？

1018
02:06:16,000 --> 02:06:17,000
 Okay?
好的？

1019
02:06:17,000 --> 02:06:26,000
 Now, the other type is our class NP, non-detonistic polynomial.
现在，另一种类型是我们的 NP 类，非道论多项式。

1020
02:06:26,000 --> 02:06:27,000
 Right?
正确的？

1021
02:06:27,000 --> 02:06:29,000
 Problem can be solved.
问题可以解决。

1022
02:06:29,000 --> 02:06:31,000
 All right?
好的？

1023
02:06:31,000 --> 02:06:39,000
 And any solution can be verified within polynomial time by some other algorithm.
并且任何解决方案都可以通过其他算法在多项式时间内验证。

1024
02:06:39,000 --> 02:06:42,000
 All right?
好的？

1025
02:06:42,000 --> 02:06:44,000
 So it's a class NP.
所以这是一个NP类。

1026
02:06:44,000 --> 02:06:45,000
 All right?
好的？

1027
02:06:45,000 --> 02:06:47,000
 And I say it's the kind of problem that I don't know.
我说这是我不知道的问题。

1028
02:06:47,000 --> 02:06:52,000
 I don't have a so-called polynomial algorithm to solve it.
我没有所谓的多项式算法来解决它。

1029
02:06:52,000 --> 02:06:53,000
 All right?
好的？

1030
02:06:53,000 --> 02:06:59,000
 So we put them under the class NP, right?
所以我们把它们放在 NP 类下，对吗？

1031
02:06:59,000 --> 02:07:06,000
 If, all right, if I give you a solution, you can solve it within polynomial time.
如果，好吧，如果我给你一个解决方案，你可以在多项式时间内解决它。

1032
02:07:06,000 --> 02:07:11,000
 That's a class NP.
这是一个NP类。

1033
02:07:11,000 --> 02:07:12,000
 All right?
好的？

1034
02:07:12,000 --> 02:07:17,000
 So I'm not sure if you so-called appreciate the implication of this, right?
所以我不确定你是否理解这其中的含义，对吗？

1035
02:07:17,000 --> 02:07:22,000
 Now, normally when you solve, for example, if I give you a solution, all right, you come
现在，通常当你解决问题时，例如，如果我给你一个解决方案，好吧，你来

1036
02:07:22,000 --> 02:07:27,000
 up with the so-called a figure of merit or fitness.
达到所谓的品质因数或适合度。

1037
02:07:27,000 --> 02:07:32,000
 Now, if you compare, for example, let's say in order to calculate the fitness, all I
现在，如果你进行比较，例如，为了计算适应度，我所有的

1038
02:07:32,000 --> 02:07:36,000
 need to do is I add 50 numbers.
我需要做的是添加 50 个数字。

1039
02:07:36,000 --> 02:07:37,000
 All right?
好的？

1040
02:07:37,000 --> 02:07:44,000
 So I just add, as compared to another algorithm or another problem where in order to find
所以我只是添加，与另一个算法或另一个问题相比，为了找到

1041
02:07:44,000 --> 02:07:49,000
 the fitness, I have to multiply the 15 numbers.
健身，我必须乘以15个数字。

1042
02:07:49,000 --> 02:07:51,000
 Which one is more expensive?
哪一款更贵？

1043
02:07:51,000 --> 02:07:56,000
 Obviously the one that you do the multiplication.
显然是你做乘法的那个。

1044
02:07:56,000 --> 02:07:57,000
 All right?
好的？

1045
02:07:57,000 --> 02:08:01,000
 Remember when you solve a problem, you do a so-called, you're in the process of solving
请记住，当你解决问题时，你做了所谓的事情，你正在解决问题的过程中

1046
02:08:01,000 --> 02:08:02,000
 a problem.
一个问题。

1047
02:08:02,000 --> 02:08:06,000
 You will probably do it a million times or billion times or trillion times.
你可能会这样做一百万次、十亿次或万亿次。

1048
02:08:06,000 --> 02:08:09,000
 So that can be quite serious.
所以这可能是相当严重的。

1049
02:08:09,000 --> 02:08:11,000
 All right?
好的？

1050
02:08:11,000 --> 02:08:20,000
 So in the class NP, we say the solution can be verified in polynomial time.
所以在NP类中，我们说解可以在多项式时间内验证。

1051
02:08:20,000 --> 02:08:22,000
 So let me give you a hint.
那么让我给你一个提示。

1052
02:08:22,000 --> 02:08:28,000
 For example, let's say in the traveling salesman problem, all right?
例如，假设在旅行推销员问题中，好吗？

1053
02:08:28,000 --> 02:08:32,000
 I give you a solution.
我给你一个解决方案。

1054
02:08:32,000 --> 02:08:34,000
 I give you a sequence.
我给你一个顺序。

1055
02:08:34,000 --> 02:08:37,000
 Now I ask you, is this minimum?
现在我问你，这是最低限度吗？

1056
02:08:37,000 --> 02:08:41,000
 Can you think about it?
你能想一下吗？

1057
02:08:41,000 --> 02:08:48,000
 Is this minimum?
这是最小值吗？

1058
02:08:48,000 --> 02:08:51,000
 Do you know it's minimum?
你知道这是最低限度吗？

1059
02:08:51,000 --> 02:08:56,000
 Okay, you prove that it's not minimum.
好吧，你证明它不是最小值。

1060
02:08:56,000 --> 02:09:08,000
 You can, but how?
可以，但是怎么办？

1061
02:09:08,000 --> 02:09:13,000
 Still the traveling salesman problem, you know what the traveling TSP is.
仍然是旅行推销员问题，你知道旅行推销员是什么。

1062
02:09:13,000 --> 02:09:14,000
 All right?
好的？

1063
02:09:14,000 --> 02:09:20,000
 So the free optimizer, just try to find the so-called shortest distance and so on.
所以免费的优化器，只是尝试寻找所谓的最短距离等等。

1064
02:09:20,000 --> 02:09:24,000
 Now let's take this problem, say.
现在我们就来说说这个问题。

1065
02:09:24,000 --> 02:09:28,000
 So now I give you this to a sequence.
现在我给你一个序列。

1066
02:09:28,000 --> 02:09:38,000
 Now my question is, is this minimum?
现在我的问题是，这是最小值吗？

1067
02:09:38,000 --> 02:09:43,000
 If it's minimum, can you prove it?
如果是最小值，你能证明吗？

1068
02:09:43,000 --> 02:09:50,000
 So you will prove it, how do you prove it?
那么你要证明这一点，你怎么证明呢？

1069
02:09:50,000 --> 02:10:03,000
 You can only prove it as minimum if it tests out all the possibilities.
如果它测试了所有可能性，你只能证明它是最小的。

1070
02:10:03,000 --> 02:10:04,000
 All right?
好的？

1071
02:10:04,000 --> 02:10:06,000
 There it goes.
就这样。

1072
02:10:06,000 --> 02:10:08,000
 Is it polynomial time?
是多项式时间吗？

1073
02:10:08,000 --> 02:10:12,000
 Most of the time you can tell it's not the minimum because you know I have a better solution
大多数时候你可以看出这不是最小值，因为你知道我有更好的解决方案

1074
02:10:12,000 --> 02:10:13,000
 so you can discount it.
所以你可以打折。

1075
02:10:13,000 --> 02:10:24,000
 But there will be cases where you know you will have to so-called literally, right, test out all the possible combinations.
但在某些情况下，您知道您必须所谓的字面意义上的，对的，测试所有可能的组合。

1076
02:10:24,000 --> 02:10:25,000
 All right?
好的？

1077
02:10:25,000 --> 02:10:32,000
 So that's why in optimization, there are many benchmarks that are created.
这就是为什么在优化过程中会创建许多基准。

1078
02:10:32,000 --> 02:10:38,000
 So they create this benchmark, the best known solution is such and such.
所以他们创建了这个基准，最著名的解决方案是这样那样的。

1079
02:10:38,000 --> 02:10:45,000
 So if you solve it, if you get a better solution, then chances are your algorithm is better.
因此，如果你解决了这个问题，如果你得到了更好的解决方案，那么你的算法很可能会更好。

1080
02:10:45,000 --> 02:10:46,000
 All right?
好的？

1081
02:10:46,000 --> 02:10:48,000
 That's the purpose of so-called benchmarks.
这就是所谓基准的目的。

1082
02:10:48,000 --> 02:10:55,000
 So the hint I give you is that definitely your TSP is not your class NP, right?
所以我给你的提示是，你的 TSP 绝对不是你的类 NP，对吗？

1083
02:10:55,000 --> 02:10:57,000
 Isn't it?
不是吗？

1084
02:10:57,000 --> 02:10:59,000
 All right?
好的？

1085
02:10:59,000 --> 02:11:11,000
 So class NP complete.
这样 NP 类就完成了。

1086
02:11:11,000 --> 02:11:15,000
 Problem belongs to class NP.
问题属于 NP 类。

1087
02:11:15,000 --> 02:11:17,000
 This part of NP, all right?
NP的这一部分，好吗？

1088
02:11:17,000 --> 02:11:20,000
 This is NP problem.
这是NP问题。

1089
02:11:20,000 --> 02:11:33,000
 And any other problem in NP can be reduced to this problem by an algorithm running in polynomial time.
NP 中的任何其他问题都可以通过在多项式时间内运行的算法来简化为该问题。

1090
02:11:33,000 --> 02:11:36,000
 In other words, you are talking about mapping.
换句话说，您正在谈论映射。

1091
02:11:36,000 --> 02:11:41,000
 In the earlier slide, we talked about mapping, right?
在前面的幻灯片中，我们讨论了映射，对吧？

1092
02:11:41,000 --> 02:11:43,000
 So we already know some of these problems.
所以我们已经知道其中一些问题。

1093
02:11:43,000 --> 02:11:46,000
 We categorize it quite well.
我们对它进行了很好的分类。

1094
02:11:46,000 --> 02:11:49,000
 For example, you are traveling still soon.
例如，您很快就要旅行。

1095
02:11:49,000 --> 02:11:58,000
 Now, here you have somebody tells you or your boss tells you, okay, this is a problem I want you to solve.
现在，有人告诉你或者你的老板告诉你，好吧，这是我希望你解决的问题。

1096
02:11:58,000 --> 02:12:04,000
 Describe to you, like for example, it's a communication problem in communication.
给你描述一下，比如说，这是沟通中的沟通问题。

1097
02:12:04,000 --> 02:12:11,000
 So the boss tells you this, that, you know, all the different nodes, right, and so on, the configuration.
所以老板告诉你这个，那个，你知道，所有不同的节点，对等等，配置。

1098
02:12:11,000 --> 02:12:19,000
 And of course, you can take the problem as it is and solve it and try and solve it, formulate it.
当然，你可以按问题本来的样子解决它，尝试解决它，制定它。

1099
02:12:19,000 --> 02:12:20,000
 All right?
好的？

1100
02:12:20,000 --> 02:12:33,000
 Saying that seems easy, but wouldn't it be easier if you can map this problem into some known problems that is already well categorized?
说起来似乎很容易，但是如果您可以将这个问题映射到一些已经很好分类的已知问题中，不是更容易吗？

1101
02:12:33,000 --> 02:12:34,000
 All right?
好的？

1102
02:12:34,000 --> 02:12:38,000
 So you map it or transform it into another type of problem.
因此，您可以将其映射或将其转化为另一种类型的问题。

1103
02:12:38,000 --> 02:12:42,000
 The advantage is very obvious because it is already well studied.
优点是非常明显的，因为它已经被充分研究过。

1104
02:12:42,000 --> 02:12:44,000
 We are understood.
我们被理解了。

1105
02:12:44,000 --> 02:12:49,000
 So you can use the approach and the algorithm to solve the problem.
所以你可以使用方法和算法来解决问题。

1106
02:12:49,000 --> 02:12:50,000
 All right?
好的？

1107
02:12:50,000 --> 02:12:52,000
 That's what MP complete means.
这就是 MP Complete 的意思。

1108
02:12:52,000 --> 02:12:53,000
 All right?
好的？

1109
02:12:53,000 --> 02:12:54,000
 You see?
你看？

1110
02:12:54,000 --> 02:12:57,000
 It belongs to class MP, all right?
它属于 MP 级，好吗？

1111
02:12:57,000 --> 02:13:08,000
 And any other problem in MP can be reduced to this problem by an algorithm running in polynomial time.
MP 中的任何其他问题都可以通过在多项式时间内运行的算法来简化为该问题。

1112
02:13:08,000 --> 02:13:09,000
 All right?
好的？

1113
02:13:09,000 --> 02:13:16,000
 So that means that that process of reduction of mapping, you have to do it in polynomial time.
这意味着减少映射的过程必须在多项式时间内完成。

1114
02:13:17,000 --> 02:13:19,000
 Which I think you can see why.
我想你可以明白为什么。

1115
02:13:19,000 --> 02:13:28,000
 If it is not in polynomial time, it doesn't make sense to do the transformation or the mapping.
如果不是在多项式时间内，则进行变换或映射是没有意义的。

1116
02:13:28,000 --> 02:13:34,000
 So there's your MP complete.
这样你的 MP 就完成了。

1117
02:13:34,000 --> 02:13:41,000
 Now, the other type is your MP hard, MP hard problem.
现在，另一种类型是你的MP困难，MP困难问题。

1118
02:13:41,000 --> 02:13:49,000
 So we say it's MP hard because problem is at least as hard as any other problem in MP complete.
所以我们说它是 MP 困难，因为问题至少与 MP 完整中的任何其他问题一样难。

1119
02:13:49,000 --> 02:13:50,000
 Okay?
好的？

1120
02:13:50,000 --> 02:13:55,000
 But solution cannot necessarily be verified within polynomial time.
但解决方案不一定能在多项式时间内得到验证。

1121
02:13:55,000 --> 02:13:59,000
 And that's MP hard.
这对国会议员来说很难。

1122
02:13:59,000 --> 02:14:06,000
 Solution cannot necessarily be verified within polynomial time.
解决方案不一定能在多项式时间内得到验证。

1123
02:14:06,000 --> 02:14:10,000
 You can general the solution, but to verify it, all right?
您可以概括解决方案，但要验证它，好吗？

1124
02:14:10,000 --> 02:14:16,000
 You may not have a, you may not necessarily have a polynomial time algorithm.
你可能没有，你不一定有多项式时间算法。

1125
02:14:16,000 --> 02:14:20,000
 So there's your MP hard.
所以你的国会议员很难。

1126
02:14:20,000 --> 02:14:21,000
 All right?
好的？

1127
02:14:21,000 --> 02:14:39,000
 So with this basic understanding, we can put together a diagram to see how we can, the link between the different types of classes.
因此，有了这个基本的了解，我们就可以制作一个图表来了解不同类型的类之间的联系。

1128
02:14:39,000 --> 02:14:47,000
 So you have two figures, one on the left, P not equal to MP.
所以你有两个数字，一个在左边，P 不等于 MP。

1129
02:14:47,000 --> 02:14:51,000
 And then on the right, P is equal to MP.
然后在右边，P 等于 MP。

1130
02:14:51,000 --> 02:14:53,000
 All right?
好的？

1131
02:14:53,000 --> 02:14:56,000
 So let's talk about the P equal to MP.
那么我们来谈谈P等于MP。

1132
02:14:56,000 --> 02:15:02,000
 Meaning we say P on the right-hand side.
这意味着我们在右侧说 P。

1133
02:15:02,000 --> 02:15:06,000
 So in computer size, all right?
那么在计算机大小中，好吗？

1134
02:15:06,000 --> 02:15:09,000
 It is, has been an open problem.
这是一个悬而未决的问题。

1135
02:15:09,000 --> 02:15:25,000
 So basically if you look at this figure here, what it's saying is that if, given an MP problem, any MP problem, any problem you're known to be MP.
所以基本上，如果你看一下这个数字，它的意思是，如果给定一个 MP 问题，任何 MP 问题，任何你知道是 MP 的问题。

1136
02:15:25,000 --> 02:15:34,000
 Now the challenge is, can you prove that there's a P algorithm that can solve this MP problem?
现在的挑战是，你能证明有一种 P 算法可以解决这个 MP 问题吗？

1137
02:15:34,000 --> 02:15:39,000
 Just for one case, can you prove?
仅举一个例子，你能证明吗？

1138
02:15:39,000 --> 02:15:40,000
 All right?
好的？

1139
02:15:40,000 --> 02:15:43,000
 I repeat, this is an MP problem.
我再说一遍，这是一个议员问题。

1140
02:15:43,000 --> 02:15:44,000
 All right?
好的？

1141
02:15:44,000 --> 02:15:48,000
 So the challenge is, it's a real challenge in computer science.
所以挑战是，这是计算机科学中真正的挑战。

1142
02:15:48,000 --> 02:15:57,000
 So the challenge is, can you find a P algorithm to solve this MP problem?
所以挑战是，你能找到一个 P 算法来解决这个 MP 问题吗？

1143
02:15:57,000 --> 02:16:01,000
 If you can prove it, right?
如果你能证明的话，对吗？

1144
02:16:01,000 --> 02:16:03,000
 Then you win the prize.
然后你就赢得了奖品。

1145
02:16:03,000 --> 02:16:06,000
 There's an open prize for it.
它有一个公开奖。

1146
02:16:06,000 --> 02:16:12,000
 Now so far, there isn't any.
现在到目前为止，还没有。

1147
02:16:12,000 --> 02:16:25,000
 Because if you have proven it, that there's, for this MP problem, if shown that there's a P algorithm to solve it, then you would have proven P equal to MP.
因为如果你已经证明，对于这个 MP 问题，如果证明有一个 P 算法可以解决它，那么你就证明了 P 等于 MP。

1148
02:16:25,000 --> 02:16:26,000
 All right?
好的？

1149
02:16:26,000 --> 02:16:28,000
 Or P can be equal to MP.
或者P可以等于MP。

1150
02:16:28,000 --> 02:16:32,000
 Then this would be the figure that you see.
那么这就是您看到的图形。

1151
02:16:32,000 --> 02:16:34,000
 This is how you would draw it.
这就是你画它的方式。

1152
02:16:34,000 --> 02:16:36,000
 P equal to MP.
P 等于 MP。

1153
02:16:36,000 --> 02:16:38,000
 I'm just proven it.
我刚刚证明了这一点。

1154
02:16:38,000 --> 02:16:39,000
 Okay?
好的？

1155
02:16:39,000 --> 02:16:44,000
 But so far, there has been no proof.
但到目前为止，还没有证据。

1156
02:16:44,000 --> 02:16:45,000
 All right?
好的？

1157
02:16:45,000 --> 02:16:48,000
 You can't prove it, or you can't show it.
你无法证明它，或者你无法展示它。

1158
02:16:48,000 --> 02:16:56,000
 So therefore, what is more likely is this figure.
因此，更有可能的是这个数字。

1159
02:16:56,000 --> 02:16:59,000
 P is not equal to MP.
P 不等于 MP。

1160
02:16:59,000 --> 02:17:01,000
 All right?
好的？

1161
02:17:01,000 --> 02:17:04,000
 So we assume P is not equal to MP.
所以我们假设 P 不等于 MP。

1162
02:17:04,000 --> 02:17:12,000
 So therefore, the way we draw or how we categorize it, we have your P, right?
因此，我们绘制的方式或分类的方式，我们有你的 P，对吧？

1163
02:17:12,000 --> 02:17:17,000
 So under the broad MP here, there's one that is NP-hard.
因此，在广泛的 MP 下，有一个是 NP 困难的。

1164
02:17:17,000 --> 02:17:18,000
 NP-hard.
NP-困难。

1165
02:17:18,000 --> 02:17:20,000
 All right?
好的？

1166
02:17:20,000 --> 02:17:25,000
 And which is why we study genetic algorithm.
这就是我们研究遗传算法的原因。

1167
02:17:25,000 --> 02:17:28,000
 Because many problems, right?
因为问题很多，对吗？

1168
02:17:28,000 --> 02:17:30,000
 They're NP-hard.
它们是 NP 困难的。

1169
02:17:30,000 --> 02:17:34,000
 And you really understood what it means to be NP, right?
你真的明白什么是 NP，对吧？

1170
02:17:34,000 --> 02:17:35,000
 And NP-hard.
并且是 NP 困难的。

1171
02:17:35,000 --> 02:17:36,000
 Okay?
好的？

1172
02:17:36,000 --> 02:17:48,000
 So that means that any deterministic or precise algorithm is unlikely to perform well.
因此，这意味着任何确定性或精确的算法都不太可能表现良好。

1173
02:17:48,000 --> 02:17:52,000
 For example, your branch and bound.
例如，您的分支和界限。

1174
02:17:53,000 --> 02:18:00,000
 Or many of your classical methods, dynamic programming, linear programming, right?
或者你的很多经典方法，动态规划，线性规划，对吧？

1175
02:18:00,000 --> 02:18:02,000
 Especially for discrete problem.
特别是对于离散问题。

1176
02:18:02,000 --> 02:18:08,000
 They are not likely to perform well in this kind of a problem.
他们不太可能在此类问题上表现良好。

1177
02:18:08,000 --> 02:18:10,000
 Therefore, right?
因此，对吗？

1178
02:18:10,000 --> 02:18:13,000
 What's the best alternative?
最好的选择是什么？

1179
02:18:13,000 --> 02:18:16,000
 P is GA.
P 是 GA。

1180
02:18:16,000 --> 02:18:20,000
 Your method heuristics.
你的方法启发式。

1181
02:18:20,000 --> 02:18:22,000
 You understand heuristics?
你了解启发式吗？

1182
02:18:22,000 --> 02:18:23,000
 What is heuristics?
什么是启发法？

1183
02:18:23,000 --> 02:18:27,000
 Heuristics are rule of thumb.
启发法是经验法则。

1184
02:18:27,000 --> 02:18:28,000
 All right?
好的？

1185
02:18:28,000 --> 02:18:36,000
 For example, if I go in the morning to Orchard Road to downtown, all right?
例如，如果我早上去乌节路去市中心，可以吗？

1186
02:18:36,000 --> 02:18:42,000
 It should take me much longer than I go after 10 o'clock.
应该比我十点以后去的时间要长得多。

1187
02:18:42,000 --> 02:18:45,000
 That's the rule of thumb, but it's not 100% true.
这是经验法则，但并不是 100% 正确。

1188
02:18:45,000 --> 02:18:47,000
 All right?
好的？

1189
02:18:47,000 --> 02:18:48,000
 Okay?
好的？

1190
02:18:48,000 --> 02:18:49,000
 But most of the time it's true.
但大多数时候这是真的。

1191
02:18:49,000 --> 02:18:50,000
 That's what we use.
这就是我们使用的。

1192
02:18:50,000 --> 02:18:53,000
 Those are precise heuristics.
这些都是精确的启发法。

1193
02:18:53,000 --> 02:19:01,000
 So method heuristics, the term method heuristics refers to genetic algorithm, like other algorithms
所以方法启发式，术语方法启发式指的是遗传算法，就像其他算法一样

1194
02:19:01,000 --> 02:19:04,000
 like N-colony, right?
就像N殖民地一样，对吧？

1195
02:19:04,000 --> 02:19:12,000
 Or B, artificial B, whale optimization, gray wolf optimization, particle swarm.
或者B，人工B，鲸鱼优化，灰狼优化，粒子群。

1196
02:19:12,000 --> 02:19:15,000
 All these are method heuristics.
所有这些都是方法启发法。

1197
02:19:15,000 --> 02:19:22,000
 So you can see that many of these algorithms are inspired by nature.
所以你可以看到很多这些算法都是受到大自然的启发。

1198
02:19:22,000 --> 02:19:32,000
 So they are inspired based on the metaphor in nature or examples that you see in nature.
所以他们的灵感来自于自然界中的隐喻或你在自然界中看到的例子。

1199
02:19:32,000 --> 02:19:33,000
 Okay?
好的？

1200
02:19:33,000 --> 02:19:44,000
 So that's why we so-called study, so-called genetic algorithm presents itself as a very
所以这就是为什么我们所谓的研究，所谓的遗传算法把自己呈现为一个非常

1201
02:19:44,000 --> 02:19:49,000
 powerful tool to deal with this NP-hard problem.
处理这个 NP 难题的强大工具。

1202
02:19:49,000 --> 02:19:59,000
 Now, let me use this excerpt from a classical text on complexity by Gary and Johnson.
现在，让我引用加里和约翰逊关于复杂性的经典文本的摘录。

1203
02:19:59,000 --> 02:20:01,000
 All right?
好的？

1204
02:20:01,000 --> 02:20:10,000
 So in this book here, it says there's a, you have, so one day you will call into your
所以在这本书里，它说有一个，你有，所以有一天你会打电话给你的

1205
02:20:10,000 --> 02:20:13,000
 boss office, all right?
老板办公室，好吗？

1206
02:20:13,000 --> 02:20:22,000
 And your boss tells you that the company is going into a bandage snatch market.
你的老板告诉你，公司正在进入绷带抢夺市场。

1207
02:20:22,000 --> 02:20:29,000
 So for this reason, we need a method to determine whether or not any given set of specifications
因此，出于这个原因，我们需要一种方法来确定任何给定的规范集是否

1208
02:20:29,000 --> 02:20:35,000
 for a new bandage snatch component can be met, all right?
换一个新的绷带抢夺组件就可以满足了，好吗？

1209
02:20:35,000 --> 02:20:39,000
 And if so, for constructing a design that meets them.
如果是这样，那么构建一个满足它们的设计。

1210
02:20:39,000 --> 02:20:49,000
 Now, because you are the chief algorithm designer, so therefore it's your task to do it.
现在，因为你是首席算法设计师，所以这就是你的任务。

1211
02:20:49,000 --> 02:20:54,000
 Because you are optimistic, so you go into your boss office.
因为你乐观，所以你走进老板办公室。

1212
02:20:54,000 --> 02:20:55,000
 Okay.
好的。

1213
02:20:55,000 --> 02:20:58,000
 You're very enthusiastic.
你很热情。

1214
02:20:58,000 --> 02:20:59,000
 All right?
好的？

1215
02:20:59,000 --> 02:21:04,000
 After consulting with the bandage snatch department to determine exactly what the problem is,
在与绷带抢夺部门协商确定问题所在后，

1216
02:21:04,000 --> 02:21:10,000
 you rush back home to your office, take out all the reference books, all right, and try
你冲回办公室，拿出所有的参考书，然后尝试

1217
02:21:10,000 --> 02:21:16,000
 to figure out, all right, because you believe or you're optimistic, there's a way you can
弄清楚，好吧，因为你相信或者你很乐观，有一种方法可以

1218
02:21:16,000 --> 02:21:21,000
 solve it, all right?
解决一下好吗？

1219
02:21:21,000 --> 02:21:29,000
 So you try a couple of weeks later, you're frustrated.
所以几周后你尝试了，但你很沮丧。

1220
02:21:29,000 --> 02:21:36,000
 Say, heck, that's just cannot find, you know, an algorithm.
说吧，哎呀，那只是找不到算法。

1221
02:21:36,000 --> 02:21:40,000
 But then it's time to see your boss to update.
但接下来是时候让你的老板更新情况了。

1222
02:21:40,000 --> 02:21:44,000
 So what do you tell your boss?
那么你会告诉你的老板什么？

1223
02:21:44,000 --> 02:21:48,000
 Well, you can look at three possible scenarios, all right?
好吧，你可以看看三种可能的情况，好吗？

1224
02:21:48,000 --> 02:21:53,000
 So you go into your boss office.
所以你走进老板办公室。

1225
02:21:53,000 --> 02:21:57,000
 You know, I just cannot find an efficient algorithm.
你知道，我就是找不到有效的算法。

1226
02:21:57,000 --> 02:21:58,000
 All right?
好的？

1227
02:21:58,000 --> 02:22:02,000
 I guess I'm just too dumb.
我想我实在是太笨了。

1228
02:22:02,000 --> 02:22:05,000
 So the scenario number one, isn't it important?
那么第一个场景，不是很重要吗？

1229
02:22:05,000 --> 02:22:07,000
 I'm just too dumb, you know, all right?
我只是太笨了，你知道吗？

1230
02:22:07,000 --> 02:22:16,000
 So that's as good as telling your boss I'm not good enough so you should fire me.
所以这就像告诉你的老板我不够好所以你应该解雇我一样。

1231
02:22:16,000 --> 02:22:23,000
 Now think about it, is that so-called a good thing to do?
现在想想，这就是所谓的好事吗？

1232
02:22:23,000 --> 02:22:26,000
 Probably not, all right?
可能不会，好吗？

1233
02:22:26,000 --> 02:22:34,000
 Or another scenario, you walk into your boss office, all right?
或者另一种情况，你走进老板办公室，好吗？

1234
02:22:34,000 --> 02:22:41,000
 You say, I can't find an efficient algorithm, all right?
你说，我找不到高效的算法，好吗？

1235
02:22:41,000 --> 02:22:47,000
 I can't find an efficient algorithm because no such algorithm is possible.
我找不到有效的算法，因为不可能有这样的算法。

1236
02:22:47,000 --> 02:22:53,000
 Hmm, your boss say, okay, I see.
嗯，你的老板说，好吧，我明白了。

1237
02:22:53,000 --> 02:22:57,000
 What does that mean?
这意味着什么？

1238
02:22:57,000 --> 02:22:59,000
 Does that mean you're not good enough?
这是不是说明你还不够好？

1239
02:22:59,000 --> 02:23:02,000
 So I should fire you and find another person?
那么我应该解雇你并另找一个人吗？

1240
02:23:02,000 --> 02:23:06,000
 They can find me the algorithm?
他们能给我找到算法吗？

1241
02:23:06,000 --> 02:23:13,000
 It's better than before but not good enough, all right?
比以前好多了，但还不够好，好吗？

1242
02:23:13,000 --> 02:23:20,000
 Now you are a learned individual, you understand about complexity.
现在你是一个博学的人，你了解复杂性。

1243
02:23:20,000 --> 02:23:29,000
 So you confidently walk into your boss office and say, look, I can't find an efficient algorithm
所以你自信地走进老板办公室说，看，我找不到有效的算法

1244
02:23:29,000 --> 02:23:35,000
 but neither can all these famous people.
但所有这些名人也不能。

1245
02:23:35,000 --> 02:23:38,000
 Hmm?
唔？

1246
02:23:38,000 --> 02:23:43,000
 So it's like telling your boss you're not going to find anybody?
这就像告诉你的老板你找不到人一样吗？

1247
02:23:43,000 --> 02:23:48,000
 You can fire me but you're not going to be able to find anybody, all right?
你可以解雇我，但你找不到任何人，好吗？

1248
02:23:48,000 --> 02:23:51,000
 Is that not better?
那不是更好吗？

1249
02:23:51,000 --> 02:23:52,000
 Okay?
好的？

1250
02:23:52,000 --> 02:23:57,000
 That's because you understand, all right, about interactability.
那是因为您了解交互性。

1251
02:23:57,000 --> 02:24:04,000
 What does it mean when you say a problem is intractable?
当你说一个问题很难解决时是什么意思？

1252
02:24:04,000 --> 02:24:05,000
 Okay?
好的？

1253
02:24:05,000 --> 02:24:13,000
 So my point is that's why it's important to understand from a complexity point of view
所以我的观点是，这就是为什么从复杂性的角度理解很重要

1254
02:24:13,000 --> 02:24:20,000
 the nature of the types of problems that you are dealing with.
您正在处理的问题类型的性质。

1255
02:24:20,000 --> 02:24:21,000
 All right?
好的？

1256
02:24:21,000 --> 02:24:34,000
 So you hopefully you have some appreciation of why we use genetic algorithm, okay?
所以希望您对我们使用遗传算法的原因有所了解，好吗？

1257
02:24:34,000 --> 02:24:47,000
 So let's try and understand a little bit how it came about.
因此，让我们尝试了解一下它是如何发生的。

1258
02:24:47,000 --> 02:24:52,000
 So we are talking about evolutionary computing.
所以我们正在谈论进化计算。

1259
02:24:52,000 --> 02:25:04,000
 So I will first let's talk a little bit about the historical perspective.
所以我首先让我们从历史的角度来谈谈。

1260
02:25:04,000 --> 02:25:05,000
 All right?
好的？

1261
02:25:05,000 --> 02:25:10,000
 So we look at a historical perspective, understand some of the background very briefly,
所以我们从历史的角度来看，非常简单地了解一些背景，

1262
02:25:10,000 --> 02:25:20,000
 some general understanding of the precursor to genetic algorithm.
对遗传算法的前身有一些一般性的了解。

1263
02:25:20,000 --> 02:25:31,000
 So of course you know by now that evolutionary computing is inspired based on the metaphor in nature.
所以你现在当然知道进化计算是基于自然界的隐喻而受到启发的。

1264
02:25:31,000 --> 02:25:32,000
 All right?
好的？

1265
02:25:32,000 --> 02:25:39,000
 Now from a biological perspective, there are actually two aspects of it that serves as
现在从生物学的角度来看，它实际上有两个方面：

1266
02:25:39,000 --> 02:25:53,000
 an inspiration for metaphorical inspiration for genetic algorithm.
遗传算法隐喻灵感的灵感。

1267
02:25:53,000 --> 02:26:00,000
 One is from Darwinian evolution theory and the other is on genetics.
一个来自达尔文进化论，另一个来自遗传学。

1268
02:26:00,000 --> 02:26:01,000
 All right?
好的？

1269
02:26:01,000 --> 02:26:05,000
 So if somebody asks you, okay, what's the background or how is it?
所以如果有人问你，好吧，背景是什么或者怎么样？

1270
02:26:05,000 --> 02:26:09,000
 Just like neural network, you know, is based on the biological brain.
就像神经网络一样，你知道，它是基于生物大脑的。

1271
02:26:09,000 --> 02:26:16,000
 It's based on the neurons in the brain and how they are connected and the firing mechanism and so on.
它基于大脑中的神经元及其连接方式和放电机制等。

1272
02:26:16,000 --> 02:26:19,000
 So how we actually come to the neural network?
那么我们实际上是如何进入神经网络的呢？

1273
02:26:19,000 --> 02:26:22,000
 Well, it's all based on the biological brain, all right?
好吧，这一切都是基于生物大脑，好吗？

1274
02:26:22,000 --> 02:26:24,000
 The inspiration of it.
它的灵感。

1275
02:26:24,000 --> 02:26:32,000
 So by the same token, genetic algorithm, Darwinian and then the genetics.
同样的道理，遗传算法，达尔文算法，然后是遗传学。

1276
02:26:32,000 --> 02:26:40,000
 And finally we quickly look at the motivation for EC.
最后，我们快速了解一下 EC 的动机。

1277
02:26:40,000 --> 02:26:59,000
 So in the early years, conceptually, there have been ideas to use evolution as a method of problem solving.
所以早些年，从概念上来说，一直有用进化论作为解决问题的方法的想法。

1278
02:26:59,000 --> 02:27:04,000
 In 48, 62, 64, 65, right?
48、62、64、65，对吗？

1279
02:27:04,000 --> 02:27:14,000
 See as early as 48, you have the so-called the genetic or evolutionary search.
早在48岁的时候，你就已经进行了所谓的遗传或进化搜索。

1280
02:27:14,000 --> 02:27:25,000
 Your genetic algorithm can trace back to 1975 based on the work by John Holland.
你的遗传算法可以追溯到 1975 年，基于 John Holland 的工作。

1281
02:27:25,000 --> 02:27:34,000
 And 1992, COSA introduced what we call the genetic programming.
1992 年，COSA 引入了我们所说的遗传编程。

1282
02:27:34,000 --> 02:27:38,000
 Now I want you to look at the timeline.
现在我想让你看一下时间线。

1283
02:27:38,000 --> 02:28:03,000
 So compare from 1948 to between 1948 and 1975, what is likely to be the different in terms of the, I say, the situation, you know, between 1948 and 1975 from computing point of view?
因此，比较 1948 年和 1948 年至 1975 年之间，从计算的角度来看，1948 年至 1975 年的情况可能有什么不同？

1284
02:28:08,000 --> 02:28:12,000
 When did you get the first PC?
您什么时候拥有第一台电脑？

1285
02:28:12,000 --> 02:28:16,000
 80s also?
80年代也是吗？

1286
02:28:16,000 --> 02:28:19,000
 So the point becomes very clear in those early days, right?
所以这一点在早期就变得非常清楚了，对吗？

1287
02:28:19,000 --> 02:28:27,000
 It was practically not implementable on computer yet.
它实际上还无法在计算机上实现。

1288
02:28:27,000 --> 02:28:31,000
 So what this means is that these were concepts.
所以这意味着这些都是概念。

1289
02:28:31,000 --> 02:28:45,000
 The concept, people have thought about the concepts of using so-called solving a problem using an evolutionary approach.
这个概念，人们思考过所谓使用进化方法解决问题的概念。

1290
02:28:45,000 --> 02:28:46,000
 Okay?
好的？

1291
02:28:46,000 --> 02:28:53,000
 So until 1975 and Holland introduced genetic algorithms, right?
所以直到 1975 年 Holland 引入了遗传算法，对吗？

1292
02:28:53,000 --> 02:28:57,000
 And after that it became so popular, right?
之后它就变得如此受欢迎，对吗？

1293
02:28:57,000 --> 02:29:14,000
 So although you have this different categorization of evolution strategies, which uses kind of a mutation kind of operations to generate alternative solutions, you have evolutionary programming, right?
因此，尽管你有不同的进化策略分类，它使用某种突变类型的操作来生成替代解决方案，但你有进化编程，对吗？

1294
02:29:14,000 --> 02:29:20,000
 That solve a problem based on so-called finite state machine, right?
那是基于所谓的有限状态机来解决问题，对吧？

1295
02:29:20,000 --> 02:29:24,000
 Formulating it as finite state machine, right?
将其表述为有限状态机，对吧？

1296
02:29:24,000 --> 02:29:28,000
 And genetic algorithm, the first version of it is binary chromosomes, right?
还有遗传算法，它的第一个版本是二元染色体，对吧？

1297
02:29:28,000 --> 02:29:33,000
 Just evolving and then doing swapping and mutation.
只是进化然后进行交换和突变。

1298
02:29:33,000 --> 02:29:40,000
 And finally the COSA on genetic programming, they evolve programs, right?
最后是关于遗传编程的 COSA，他们进化了程序，对吗？

1299
02:29:44,000 --> 02:29:45,000
 Okay?
好的？

1300
02:29:45,000 --> 02:29:53,000
 So these days we don't make distinction between this different approach.
所以现在我们不区分这种不同的方法。

1301
02:29:53,000 --> 02:29:58,000
 So quite clearly you can see there are different evolutionary approach.
所以你可以很清楚地看到有不同的进化方法。

1302
02:29:58,000 --> 02:30:01,000
 But nowadays we don't really make a distinction between this.
但现在我们并没有真正区分这两者。

1303
02:30:01,000 --> 02:30:05,000
 That's why your title is a genetic algorithm.
这就是为什么你的标题是遗传算法。

1304
02:30:05,000 --> 02:30:08,000
 Basically what we mean is just evolutionary approach.
基本上我们的意思只是进化方法。

1305
02:30:08,000 --> 02:30:09,000
 Okay?
好的？

1306
02:30:09,000 --> 02:30:15,000
 Because most of the time no matter what method you use we call it genetic algorithm.
因为大多数时候无论你使用什么方法我们都称之为遗传算法。

1307
02:30:15,000 --> 02:30:16,000
 Alright?
好吧？

1308
02:30:16,000 --> 02:30:19,000
 So there's no need to be concerned about this different categorization.
所以没有必要担心这种不同的分类。

1309
02:30:19,000 --> 02:30:21,000
 Just call it genetic algorithm.
就称之为遗传算法吧。

1310
02:30:21,000 --> 02:30:23,000
 That's fine.
没关系。

1311
02:30:23,000 --> 02:30:32,000
 But you should understand that there are these different categorization.
但你应该明白，有这些不同的分类。

1312
02:30:32,000 --> 02:30:37,000
 So Darwinian.
所以达尔文主义。

1313
02:30:37,000 --> 02:30:40,000
 The Darwinian evolution.
达尔文进化论。

1314
02:30:40,000 --> 02:30:48,000
 What's the so-called idea behind the Darwinian evolution?
所谓达尔文进化论背后的思想是什么？

1315
02:30:48,000 --> 02:30:51,000
 Survival of the fittest.
适者生存。

1316
02:30:51,000 --> 02:30:53,000
 Alright?
好吧？

1317
02:30:53,000 --> 02:30:57,000
 Why?
为什么？

1318
02:30:57,000 --> 02:30:58,000
 Alright?
好吧？

1319
02:30:58,000 --> 02:31:06,000
 Why is there so-called evolution or adaptation?
为什么会有所谓的进化或适应？

1320
02:31:06,000 --> 02:31:12,000
 Because of resources.
因为资源。

1321
02:31:12,000 --> 02:31:14,000
 Finite resources.
资源有限。

1322
02:31:14,000 --> 02:31:20,000
 As I said before we optimize because it's not enough.
正如我之前所说，我们进行优化是因为这还不够。

1323
02:31:20,000 --> 02:31:22,000
 Therefore you need to optimize.
因此你需要优化。

1324
02:31:22,000 --> 02:31:28,000
 Or we innovate because we want to improve on things or because they are limited resources.
或者我们创新是因为我们想要改进事物或者因为它们的资源有限。

1325
02:31:28,000 --> 02:31:33,000
 So all environments has finite resources.
所以所有环境的资源都是有限的。

1326
02:31:33,000 --> 02:31:34,000
 Okay?
好的？

1327
02:31:34,000 --> 02:31:36,000
 Life forms have basic instinct.
生命形式有基本的本能。

1328
02:31:36,000 --> 02:31:41,000
 Life cycles geared towards reproduction.
面向繁殖的生命周期。

1329
02:31:41,000 --> 02:31:46,000
 That means survival of the species.
这意味着物种的生存。

1330
02:31:46,000 --> 02:31:53,000
 It's about so-called ensuring the survival of the group or the species.
这是所谓的确保群体或物种的生存。

1331
02:31:53,000 --> 02:32:02,000
 So the idea is that individuals that compete for resources most effectively have increased chance of reproduction.
因此，最有效地竞争资源的个体会增加繁殖的机会。

1332
02:32:02,000 --> 02:32:06,000
 To ensure survival.
以确保生存。

1333
02:32:06,000 --> 02:32:13,000
 So in nature of course we say survival of the fittest.
所以在自然界中我们当然会说适者生存。

1334
02:32:13,000 --> 02:32:25,000
 Meaning that individuals that has the highest capability to compete for the limited resources.
这意味着具有最高能力的个人可以竞争有限的资源。

1335
02:32:25,000 --> 02:32:30,000
 Then has a higher chance of reproduction.
那么繁殖的机会就比较高。

1336
02:32:31,000 --> 02:32:38,000
 So therefore in the fitness, when we talk about fitness in evolutionary algorithm.
因此，在适应度中，当我们谈论进化算法中的适应度时。

1337
02:32:38,000 --> 02:32:41,000
 So we always have this fitness measure.
所以我们总是有这个健身措施。

1338
02:32:41,000 --> 02:32:46,000
 Just like your objective function when you say how good a solution is.
就像你说解决方案有多好时的目标函数一样。

1339
02:32:46,000 --> 02:32:49,000
 So that is equivalent to fitness.
那么这就相当于健身了。

1340
02:32:49,000 --> 02:32:53,000
 Fitness in natural evolution is derived secondary measure.
自然进化中的适应性是衍生的次要衡量标准。

1341
02:32:53,000 --> 02:32:58,000
 We humans assign a high fitness to individuals with many offspring.
我们人类赋予拥有许多后代的个体较高的适应度。

1342
02:32:58,000 --> 02:33:04,000
 In nature fitness means higher number of offspring.
在自然界中，健康意味着更多的后代。

1343
02:33:04,000 --> 02:33:14,000
 In our algorithm it is about the goodness of the solution.
在我们的算法中，它与解决方案的优劣有关。

1344
02:33:14,000 --> 02:33:18,000
 What defines the goodness depends on your problem.
什么定义了善取决于你的问题。

1345
02:33:18,000 --> 02:33:26,000
 If it's a traveling system problem the goodness of it is how short the distance is needed.
如果是行驶系统问题，那么好处就是需要多短的距离。

1346
02:33:26,000 --> 02:33:34,000
 So it depends on the problem.
所以这取决于问题。

1347
02:33:34,000 --> 02:33:46,000
 Also in the Darwinian evolution we talk about diversity.
在达尔文进化论中，我们也谈论多样性。

1348
02:33:46,000 --> 02:33:52,000
 So diversity means what?
那么多样性意味着什么呢？

1349
02:33:52,000 --> 02:33:55,000
 Greater variation.
变化更大。

1350
02:33:55,000 --> 02:33:58,000
 More diverse.
更加多样化。

1351
02:33:58,000 --> 02:34:08,000
 So in the real world there is an expression of individuals.
所以在现实世界中存在个体的表达。

1352
02:34:08,000 --> 02:34:18,000
 So that expression of the individuals is what we call the phenotypic traits.
因此，个体的表达就是我们所说的表型特征。

1353
02:34:18,000 --> 02:34:32,000
 For example in humans, black hair, long hair, no hair, blue eyes, brown eyes and so on.
例如在人类中，黑发、长发、无发、蓝眼睛、棕色眼睛等等。

1354
02:34:32,000 --> 02:34:37,000
 So those are the phenotypic traits.
这些是表型特征。

1355
02:34:37,000 --> 02:34:44,000
 So it is partly determined by inheritance and partly by factors during development.
所以它部分是由遗传决定的，部分是由发展过程中的因素决定的。

1356
02:34:44,000 --> 02:34:52,000
 It is unique to each individual as a result of random changes.
由于随机变化，它对每个人来说都是独一无二的。

1357
02:34:52,000 --> 02:35:05,000
 So in Darwinian's theory what determines the traits?
那么在达尔文的理论中，是什么决定了性状呢？

1358
02:35:05,000 --> 02:35:14,000
 It is the traits that will lead to higher chances of reproduction.
这些特征将导致更高的繁殖机会。

1359
02:35:14,000 --> 02:35:18,000
 That is the natural evolution way.
这就是自然进化的方式。

1360
02:35:18,000 --> 02:35:22,000
 And these traits can be inherited.
并且这些特征是可以遗传的。

1361
02:35:22,000 --> 02:35:26,000
 And in your genetic algorithm this is a form of learning.
在遗传算法中，这是一种学习形式。

1362
02:35:26,000 --> 02:35:42,000
 Those are good ones you will inherit.
这些都是你将继承的好东西。

1363
02:35:42,000 --> 02:35:52,000
 So quickly we talk about so-called individuals and the population.
我们很快就谈论了所谓的个人和人口。

1364
02:35:52,000 --> 02:36:00,000
 So in the Darwinian evolution, when we talk about the survival of the fitters,
所以在达尔文进化论中，当我们谈论装配者的生存时，

1365
02:36:00,000 --> 02:36:09,000
 the word fitters means that you must have a way to distinguish which is fitter.
“fitters”这个词意味着你必须有一种方法来区分哪个更合适。

1366
02:36:09,000 --> 02:36:12,000
 So because there is a basis of selection.
因为有选择的基础。

1367
02:36:12,000 --> 02:36:13,000
 Selection for what?
选拔是为了什么？

1368
02:36:13,000 --> 02:36:15,000
 Selection for reproduction.
选择进行繁殖。

1369
02:36:15,000 --> 02:36:18,000
 Or accordingly for higher chances of reproduction.
或者相应地获得更高的繁殖机会。

1370
02:36:18,000 --> 02:36:23,000
 So individuals becomes the units of selection.
因此，个人成为选择的单位。

1371
02:36:23,000 --> 02:36:31,000
 And when we talk about evolution as a whole, population is a unit of evolution.
当我们谈论整个进化时，人口是进化的一个单位。

1372
02:36:31,000 --> 02:36:42,000
 Selection is the individuals, but the evolution aspect is the population as a whole.
选择是个体，而进化则是整个种群。

1373
02:36:42,000 --> 02:36:57,000
 So one aspect of the inspiration is the Darwinian evolution.
所以灵感的一方面是达尔文进化论。

1374
02:36:57,000 --> 02:37:02,000
 Now the second aspect of the evolution is the genetics.
现在进化的第二个方面是遗传学。

1375
02:37:03,000 --> 02:37:18,000
 So putting it very simply, all our characteristic traits are encoded in what we call the DNA.
简而言之，我们所有的特征都被编码在我们所说的 DNA 中。

1376
02:37:18,000 --> 02:37:23,000
 So the DNA is like the signature of how we look.
所以DNA就像我们外表的签名。

1377
02:37:23,000 --> 02:37:35,000
 So the manifestation of the characteristic of the DNA would determine the phenotypic traits.
因此DNA特征的表现将决定表型性状。

1378
02:37:35,000 --> 02:37:48,000
 So the main point to make is that the genetic algorithms, the inspiration of it also comes from the genetics part.
所以重点说的是遗传算法，它的灵感也是来自于遗传学部分。

1379
02:37:48,000 --> 02:37:56,000
 So in your algorithm, you use concepts like chromosomes.
因此，在您的算法中，您使用染色体等概念。

1380
02:37:56,000 --> 02:38:02,000
 So you use concepts like chromosomes and genes and so on.
所以你使用染色体和基因等概念。

1381
02:38:02,000 --> 02:38:09,000
 So you have your natural evolution that determines the evolution of the selection of the individuals
所以你的自然进化决定了个体选择的进化

1382
02:38:09,000 --> 02:38:13,000
 and then survival of the fitters and so on.
然后是装配工的生存等等。

1383
02:38:13,000 --> 02:38:23,000
 Because in the genetics, it provides a blueprint for how we can actually cope these problems
因为在遗传学中，它为我们如何实际应对这些问题提供了蓝图

1384
02:38:23,000 --> 02:38:35,000
 based on the inspiration of the so-called genetics.
基于所谓遗传学的灵感。

1385
02:38:35,000 --> 02:38:39,000
 So this is from the genetics part.
所以这是来自遗传学部分。

1386
02:38:39,000 --> 02:38:45,000
 So genes are encoded in strands of DNA called chromosomes.
因此，基因被编码在称为染色体的 DNA 链中。

1387
02:38:45,000 --> 02:38:50,000
 So most cells, there are two copies of each chromosome.
所以大多数细胞中，每条染色体都有两个拷贝。

1388
02:38:50,000 --> 02:38:52,000
 So that's called a diploidy.
这就是所谓的二倍体。

1389
02:38:52,000 --> 02:38:58,000
 Now the complete genetic material in an individual genotype is called a genome.
现在，个体基因型中的完整遗传物质被称为基因组。

1390
02:38:58,000 --> 02:39:08,000
 So when we talk about the genome, it's a complete genetic material.
所以当我们谈论基因组时，它是一个完整的遗传物质。

1391
02:39:08,000 --> 02:39:16,000
 So for every species, within a species, most of the genetic material is the same.
因此，对于每个物种，在一个物种内，大部分遗传物质都是相同的。

1392
02:39:16,000 --> 02:39:24,000
 So basically two points here, from evolution standpoint, Darwinian evolution,
所以这里基本上有两点，从进化论的角度来看，达尔文进化论，

1393
02:39:24,000 --> 02:39:30,000
 from the genetics, that becomes the so-called inspiration for our genetic algorithm.
来自遗传学，这成为我们遗传算法的所谓灵感。

1394
02:39:30,000 --> 02:39:37,000
 And we also, from the genetics point, there is also the mutation.
从遗传学的角度来看，我们也存在突变。

1395
02:39:37,000 --> 02:39:48,000
 So mutation, random change or unexpected change, you talk about virus mutation and so on,
所以突变，随机变化或意外变化，你谈论病毒突变等等，

1396
02:39:48,000 --> 02:39:51,000
 I think that will give you an idea of what it means.
我想这会让你明白它的含义。

1397
02:39:51,000 --> 02:39:58,000
 So in our genetic algorithm, we also have implement a mutation process.
所以在我们的遗传算法中，我们还实现了变异过程。

1398
02:39:58,000 --> 02:40:04,000
 So in the algorithm, mutation gives us the ability to vary the solution.
因此，在算法中，变异使我们能够改变解决方案。

1399
02:40:04,000 --> 02:40:08,000
 So when we vary, we increase the diversity.
因此，当我们有所不同时，我们就增加了多样性。

1400
02:40:08,000 --> 02:40:20,000
 So whenever diversity, we explore more possibilities of different solutions.
因此，每当多样性时，我们都会探索不同解决方案的更多可能性。

1401
02:40:20,000 --> 02:40:29,000
 So I think from this, I think the evolutionary computation metaphor,
所以我认为，从这一点来看，我认为进化计算的隐喻，

1402
02:40:29,000 --> 02:40:35,000
 you can kind of have a picture of what really happens in nature,
你可以大致了解自然界中真实发生的事情

1403
02:40:35,000 --> 02:40:42,000
 how we have brought it into our algorithm we are in terms of problem solving.
我们如何将其带入我们的算法中，我们是在解决问题方面。

1404
02:40:43,000 --> 02:40:51,000
 So you know, a population of individuals exists in an environment with limited resources.
所以你知道，一群人存在于一个资源有限的环境中。

1405
02:40:51,000 --> 02:40:59,000
 So as I said before, if resources is enough, there's no need to compete, because it's more than enough.
所以我之前说过，如果资源足够了，就没有必要去竞争，因为绰绰有余。

1406
02:40:59,000 --> 02:41:01,000
 And also the competition, right?
还有竞争，对吧？

1407
02:41:01,000 --> 02:41:04,000
 Competition based on fitness.
比赛以体能为主。

1408
02:41:04,000 --> 02:41:16,000
 And individuals act as seeds for generation of new individuals through recombination and mutation.
个体充当通过重组和突变产生新个体的种子。

1409
02:41:16,000 --> 02:41:21,000
 So through this information here, so when you search for a solution,
因此，通过这里的信息，当您寻找解决方案时，

1410
02:41:21,000 --> 02:41:25,000
 you are searching for different possibilities or different variations.
你正在寻找不同的可能性或不同的变化。

1411
02:41:25,000 --> 02:41:32,000
 So likewise, we're going to use recombination and mutation to generate that kind of diversity.
同样，我们将使用重组和突变来产生这种多样性。

1412
02:41:32,000 --> 02:41:39,000
 So that is like exploring the different possibilities of the solution landscape.
这就像探索解决方案的不同可能性。

1413
02:41:42,000 --> 02:41:49,000
 So you can see that if you're able to put this into a program,
所以你可以看到，如果你能够将其放入程序中，

1414
02:41:49,000 --> 02:41:56,000
 and you let the process run through this recombination and then mutation and regeneration and so on,
然后你让这个过程经历重组，然后突变和再生等等，

1415
02:41:56,000 --> 02:42:01,000
 because you have selective selection pressure in there,
因为你有选择性选择的压力，

1416
02:42:01,000 --> 02:42:03,000
 because you're going to select according to fitness.
因为你要根据身体状况来选择。

1417
02:42:03,000 --> 02:42:11,000
 Now if you do it over many, many iterations, what you foresee will happen to the overall fitness.
现在，如果您进行多次迭代，您将预见到整体适应性将会发生什么。

1418
02:42:13,000 --> 02:42:18,000
 Very naturally, the fitness, the overall fitness would improve.
很自然的，身体素质，整体的身体素质都会提高。

1419
02:42:19,000 --> 02:42:30,000
 So therefore in your algorithm, you will keep on iterating it until the fitness level reaches a certain level that is acceptable to you.
因此，在你的算法中，你将继续迭代它，直到适应度达到你可以接受的某个水平。

1420
02:42:30,000 --> 02:42:37,000
 That would mean that you have found a solution or it is a solution that is good enough.
这意味着您已经找到了解决方案，或者这是一个足够好的解决方案。

1421
02:42:37,000 --> 02:42:44,000
 That's the idea on how we solve it in algorithm.
这就是我们如何在算法中解决它的想法。

1422
02:42:48,000 --> 02:42:55,000
 So in EC, it's basically a generate and test.
所以在 EC 中，它基本上是生成和测试。

1423
02:42:55,000 --> 02:43:00,000
 A generate and test, unlike for example your branch and bound.
生成和测试，与分支定界等不同。

1424
02:43:00,000 --> 02:43:06,000
 Your branch and bound you search, and then you know what is your current bound,
你搜索你的分支和界限，然后你就知道你当前的界限是什么，

1425
02:43:06,000 --> 02:43:11,000
 and then you search until you reach a state where you cannot improve any further,
然后你不断地寻找，直到你达到一个无法再进步的状态，

1426
02:43:11,000 --> 02:43:16,000
 and then you branch out to another path.
然后你分支到另一条路。

1427
02:43:16,000 --> 02:43:23,000
 So that is more like a sequential search.
所以这更像是顺序搜索。

1428
02:43:23,000 --> 02:43:28,000
 But here in EC, or evolutionary algorithm, it's generate and test.
但在 EC，或进化算法中，它是生成和测试。

1429
02:43:28,000 --> 02:43:35,000
 Basically you just generate the different possibilities of solutions and then you test it.
基本上，您只需生成解决方案的不同可能性，然后对其进行测试。

1430
02:43:37,000 --> 02:43:40,000
 And they are stochastic population base.
他们是随机的人口基数。

1431
02:43:42,000 --> 02:43:45,000
 Stochastic means probabilistic.
随机意味着概率。

1432
02:43:47,000 --> 02:43:56,000
 You make decision based on some, for example, random or probabilistic approach.
您根据某些方法（例如随机或概率方法）做出决策。

1433
02:43:58,000 --> 02:44:06,000
 Or another way to put it is that if you compare stochastic to deterministic in stochastic algorithm,
或者另一种说法是，如果在随机算法中将随机性与确定性进行比较，

1434
02:44:06,000 --> 02:44:12,000
 every time you run it, there's a possibility you will get a different answer.
每次运行它时，您都有可能得到不同的答案。

1435
02:44:13,000 --> 02:44:17,000
 Because you use a lot of random numbers. That's stochastic behavior.
因为你使用了很多随机数。这是随机行为。

1436
02:44:20,000 --> 02:44:26,000
 And then in EC, we have our variation operators like your recombination and mutation.
然后在 EC 中，我们有变异算子，比如重组和变异。

1437
02:44:26,000 --> 02:44:29,000
 That's to create a so-called diversity.
这就是创造所谓的多样性。

1438
02:44:30,000 --> 02:44:36,000
 And selection reduces diversity and acts as a force pushing for quality.
选择减少了多样性并成为推动质量的力量。

1439
02:44:43,000 --> 02:44:49,000
 So generally you see where we are coming from.
所以一般来说你会看到我们来自哪里。

1440
02:44:49,000 --> 02:44:53,000
 The motivation behind genetic algorithm or how it comes about.
遗传算法背后的动机或者它是如何产生的。

1441
02:44:54,000 --> 02:45:02,000
 So let's begin to look at the GA, or what is evolutionary algorithm.
那么让我们开始看看GA，或者说什么是进化算法。

1442
02:45:03,000 --> 02:45:14,000
 So we're going to look at the scheme of an EA and the different components.
因此，我们将了解 EA 的方案和不同的组件。

1443
02:45:14,000 --> 02:45:29,000
 And look at some examples and then consider it from the point of global optimization and then the neighborhood search.
然后看一些例子，然后从全局优化和邻域搜索的角度来考虑。

1444
02:45:33,000 --> 02:45:51,000
 This is a very good figure that put very clearly or succinctly what the process involved in an evolutionary algorithm.
这是一个非常好的图，非常清楚或简洁地说明了进化算法所涉及的过程。

1445
02:45:52,000 --> 02:46:10,000
 And if you can see or remember this figure here, that becomes a very important baseline for you to develop a holistic understanding of genetic algorithm.
如果您可以在这里看到或记住这个数字，那么这将成为您全面了解遗传算法的非常重要的基线。

1446
02:46:11,000 --> 02:46:21,000
 Now there are three parts, the population and then the parents and the offspring.
现在分为三部分，人口，然后是父母和后代。

1447
02:46:23,000 --> 02:46:31,000
 So from an algorithm point of view, three parts. Population, parents and offspring.
所以从算法的角度来说，三个部分。人口、父母和后代。

1448
02:46:32,000 --> 02:46:41,000
 So according to this diagram here, initially when you start, you initialize the population.
因此，根据此处的图表，最初当您开始时，您将初始化种群。

1449
02:46:42,000 --> 02:46:51,000
 How do you initialize? Random? I don't know any better. Randomly generate a solution.
你如何初始化？随机的？我不知道还有什么更好的了。随机生成一个解决方案。

1450
02:46:52,000 --> 02:47:01,000
 How many do you generate? Well you determine a population size.
你产生了多少个？那么你确定人口规模。

1451
02:47:01,000 --> 02:47:09,000
 If your population is 100, so you randomly generate 100 possible solutions.
如果您的人口为 100，那么您会随机生成 100 个可能的解决方案。

1452
02:47:10,000 --> 02:47:22,000
 So the population is like sampling. You have a whole solution space.
所以总体就像抽样一样。您拥有完整的解决方案空间。

1453
02:47:22,000 --> 02:47:29,000
 So if you have 100 individuals, you are basically sampling 100 different regions.
因此，如果您有 100 个人，那么您基本上是在 100 个不同的区域进行采样。

1454
02:47:30,000 --> 02:47:41,000
 And population also gives you that so-called redundancy. It's like a strength in number. It's like a parallel search.
人口也会带来所谓的冗余。这就像数量上的力量。这就像并行搜索。

1455
02:47:43,000 --> 02:47:51,000
 So in theory you have 100 parallel search tracks. Let's say your population is 100.
因此理论上您有 100 个并行搜索轨道。假设您的人口为 100。

1456
02:47:52,000 --> 02:48:03,000
 So you initialize your population. Then after that you select the parents.
所以你初始化你的人口。然后你选择父母。

1457
02:48:05,000 --> 02:48:14,000
 You select the parents. So the word selection means that to choose, right?
你选择父母。所以选择这个词的意思就是选择，对吗？

1458
02:48:14,000 --> 02:48:24,000
 To choose means you have a basis for choosing. How do you choose? According to the fitness.
选择了就意味着有了选择的基础。你如何选择？根据身体素质。

1459
02:48:25,000 --> 02:48:32,000
 According to the goodness of the solution. So you choose according to the fitness. How do you know the fitness?
根据溶液的好坏。所以大家要根据自己的身体素质来选择。怎么知道健身情况？

1460
02:48:32,000 --> 02:48:48,000
 You have an objective function. Which in GA normally we say the fitness function.
你有一个目标函数。在遗传算法中我们通常所说的适应度函数。

1461
02:48:50,000 --> 02:48:54,000
 So you have your fitness function. Which is actually your objective function?
这样你就有了健身功能。哪个实际上是您的目标函数？

1462
02:48:55,000 --> 02:49:04,000
 Like the traveling salesman problem, the fitness will be the length of the tour. So that will be the fitness.
就像旅行推销员问题一样，适应度就是旅行的长度。这就是健身。

1463
02:49:04,000 --> 02:49:14,000
 So you choose the parents. So this pool of parents, you're going to create variation.
所以你选择了父母。所以这群父母，你将创造变化。

1464
02:49:15,000 --> 02:49:25,000
 Remember diversity? You want to create variation. So how do you create variation? You use a recombination process.
还记得多样性吗？你想要创造变化。那么如何创造变化呢？您使用重组过程。

1465
02:49:27,000 --> 02:49:36,000
 Recombination involves one or more parents. Let's say you have two parents. You're going to do maybe a swapping.
重组涉及一个或多个亲本。假设你有两个父母。你也许会做一次交换。

1466
02:49:37,000 --> 02:49:44,000
 You take one part from the first parent and then the second part from the second parent.
您从第一个父级获取一部分，然后从第二个父级获取第二部分。

1467
02:49:45,000 --> 02:49:53,000
 So the idea is that because you already selected, so the parents tend to be fitter. The good ones.
所以我们的想法是，因为你已经选择了，所以父母往往更适合。好的人。

1468
02:49:54,000 --> 02:50:02,000
 So what you have done is that you have chosen the fitter one. Give them higher chance of reproduction.
所以你所做的就是选择了更合适的那个。给它们更高的繁殖机会。

1469
02:50:03,000 --> 02:50:10,000
 So essentially what you have done is that you're passing on good characteristics. Because you select, you recombine.
所以本质上你所做的就是传递良好的品质。因为你选择，所以你重新组合。

1470
02:50:11,000 --> 02:50:20,000
 And your basis of your selection is based on fitness. So you have chosen it based on the fitness. So you're passing on good characteristics.
您选择的基础是健康状况。所以你是根据身体素质来选择的。所以你正在传递良好的特征。

1471
02:50:21,000 --> 02:50:29,000
 So that's recombination. And then you also introduce some kind of random perturbation. Mutation is random.
所以这就是重组。然后你还引入某种随机扰动。突变是随机的。

1472
02:50:30,000 --> 02:50:37,000
 Why you want randomness? Well, again to create diversity.
为什么你想要随机性？好吧，再次创造多样性。

1473
02:50:38,000 --> 02:50:47,000
 So in GA, one of the clear things you must understand about GA is there are two main operations.
因此，在 GA 中，您必须了解的关于 GA 的明确的事情之一是有两个主要操作。

1474
02:50:48,000 --> 02:50:54,000
 One is your recombination. The other is mutation. These are the two main.
一是你们的重组。另一个是突变。这是两个主要的。

1475
02:50:54,000 --> 02:51:10,000
 And if you look at the so-called, the whole concept of GA, basically it involves these two mechanisms to create the variations in the individuals.
如果你看看所谓的遗传算法的整个概念，基本上它涉及这两种机制来创造个体的变异。

1476
02:51:11,000 --> 02:51:19,000
 So after you create from the parents through this process, you create offspring.
因此，在通过这个过程从父母那里创造出来之后，你就创造了后代。

1477
02:51:24,000 --> 02:51:29,000
 So you create offspring. From the parents you have an offspring.
所以你创造了后代。从父母那里你有一个后代。

1478
02:51:30,000 --> 02:51:43,000
 So this offspring, different. So now you have two pools. You have your parents and then you have a pool of offspring.
所以这个后代，与众不同。现在你有两个池了。你有你的父母，然后你就有一群后代。

1479
02:51:44,000 --> 02:51:54,000
 Based on the parents and the offspring, you're going to create a new population. That means that it's one generation.
基于父母和后代，你将创建一个新的群体。这意味着它是一代人。

1480
02:51:55,000 --> 02:51:58,000
 So in one generation, you're going to create a new population.
因此，在一代人的时间内，您将创造出新的人口。

1481
02:51:59,000 --> 02:52:07,000
 Now if you think about this, through this thought process here, you can imagine if you do it iteratively many times,
现在如果你想一想，通过这里的这个思考过程，你可以想象如果你迭代很多次，

1482
02:52:08,000 --> 02:52:15,000
 over time the fitness of the pool of individuals would improve.
随着时间的推移，个体群体的适应性将会提高。

1483
02:52:16,000 --> 02:52:24,000
 So quite clearly this process is very intuitive and logical.
很明显，这个过程是非常直观和合乎逻辑的。

1484
02:52:25,000 --> 02:52:33,000
 So when you talk about GA, think of this figure, this picture.
所以当你谈论GA时，想想这个数字，这张图片。

1485
02:52:34,000 --> 02:52:43,000
 And then from this figure here, we will use it to expand further of the different intricacies within each of the blocks.
然后从这里的图中，我们将使用它来进一步扩展每个块内的不同复杂性。

1486
02:52:44,000 --> 02:52:50,000
 So let me stop here and then we continue again next week.
让我在这里停下来，然后我们下周再继续。

1487
02:52:54,000 --> 02:52:59,000
 Thank you.
谢谢。

1488
02:53:24,000 --> 02:53:29,000
 Thank you.
谢谢。

1489
02:53:54,000 --> 02:53:59,000
 Thank you.
谢谢。

1490
02:54:24,000 --> 02:54:29,000
 Thank you.
谢谢。

1491
02:54:54,000 --> 02:54:59,000
 Thank you.
谢谢。

1492
02:55:24,000 --> 02:55:29,000
 Thank you.
谢谢。

1493
02:55:54,000 --> 02:55:59,000
 Thank you.
谢谢。

1494
02:56:24,000 --> 02:56:29,000
 Thank you.
谢谢。

1495
02:56:54,000 --> 02:56:59,000
 Thank you.
谢谢。

1496
02:57:24,000 --> 02:57:29,000
 Thank you.
谢谢。

1497
02:57:54,000 --> 02:57:59,000
 Thank you.
谢谢。

1498
02:58:24,000 --> 02:58:29,000
 Thank you.
谢谢。

1499
02:58:54,000 --> 02:58:59,000
 Thank you.
谢谢。

1500
02:59:24,000 --> 02:59:29,000
 Thank you.
谢谢。

1501
02:59:54,000 --> 02:59:59,000
 Thank you.
谢谢。

