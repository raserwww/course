1
00:00:00,000 --> 00:00:21,440
 Hello class, can you hear me?

2
00:00:21,440 --> 00:00:23,440
 All right.

3
00:00:23,440 --> 00:00:25,440
 Okay.

4
00:00:25,440 --> 00:00:35,440
 So this is our second week for this course, introduction to AI and data mining.

5
00:00:35,440 --> 00:00:36,440
 Okay.

6
00:00:36,440 --> 00:00:38,440
 So this is a plan.

7
00:00:38,440 --> 00:00:43,440
 Hopefully we can cover all these topics today in these three hours.

8
00:00:43,440 --> 00:00:51,440
 That means I should finish off all the four algorithms on this uninformed search, or the

9
00:00:51,440 --> 00:00:53,440
 search algorithms.

10
00:00:53,440 --> 00:01:00,440
 And then we also move on to the topic tree, just touch a bit, which is informed search.

11
00:01:00,440 --> 00:01:01,440
 Okay.

12
00:01:01,440 --> 00:01:03,440
 So we start to talk about why it's heuristics.

13
00:01:03,440 --> 00:01:12,440
 We are talking about, and then some very simple idea of make use of the heuristic value.

14
00:01:12,440 --> 00:01:13,440
 Okay.

15
00:01:13,440 --> 00:01:15,440
 So this is our plan.

16
00:01:15,440 --> 00:01:17,440
 Hopefully we can go through this.

17
00:01:17,440 --> 00:01:23,440
 I understand we have exercise tool haven't covered, haven't discussed yet.

18
00:01:23,440 --> 00:01:25,440
 I ask you to go back and discuss it.

19
00:01:25,440 --> 00:01:30,440
 So we suppose you cover it later, okay, when we talk about exercises.

20
00:01:30,440 --> 00:01:35,440
 And let's focus on the algorithm, introduce the algorithm first.

21
00:01:35,440 --> 00:01:37,440
 Okay.

22
00:01:37,440 --> 00:01:40,440
 So that's that.

23
00:01:40,440 --> 00:01:46,440
 This we want to, we already introduced the state search space, right?

24
00:01:46,440 --> 00:01:48,440
 We talk about symbolic AI.

25
00:01:48,440 --> 00:01:56,440
 So we have to have the states and then specify what is the initial state, what is the goal

26
00:01:56,440 --> 00:01:58,440
 state you wish to find.

27
00:01:58,440 --> 00:02:07,440
 So then we hopefully in this, we define the operations in this, define the legal operations

28
00:02:07,440 --> 00:02:10,440
 in this problem solving space.

29
00:02:10,440 --> 00:02:17,440
 And then we specify starting states, what are the possible operation can be applied

30
00:02:17,440 --> 00:02:24,440
 to move to some of those other states, right, from one state to another.

31
00:02:24,440 --> 00:02:31,440
 And then from there, then it consists of a partial or the entire state space, right?

32
00:02:31,440 --> 00:02:35,440
 Then from there, we start from one of the possible states.

33
00:02:35,440 --> 00:02:42,440
 Then we should have a way to systematically find an answer or find one of the goal states

34
00:02:42,440 --> 00:02:44,440
 we want, right?

35
00:02:44,440 --> 00:02:46,440
 So this is the idea.

36
00:02:46,440 --> 00:02:47,440
 Okay.

37
00:02:47,440 --> 00:02:54,440
 So how to, after we have this state space, so how to systematically find the goal states?

38
00:02:54,440 --> 00:02:55,440
 Okay.

39
00:02:55,440 --> 00:02:57,440
 This is what we wish to achieve.

40
00:02:57,440 --> 00:03:05,440
 So this is under the assumption, meaning we have a sufficient computation time.

41
00:03:05,440 --> 00:03:08,440
 I mean, that makes the whole thing feasible.

42
00:03:08,440 --> 00:03:12,440
 That means the problem can be solved within the given time.

43
00:03:12,440 --> 00:03:21,440
 Then another thing is we have enough memory to hold the necessary states in the memory,

44
00:03:21,440 --> 00:03:22,440
 right?

45
00:03:22,440 --> 00:03:24,440
 So then we possibly can do this.

46
00:03:24,440 --> 00:03:25,440
 Okay.

47
00:03:25,440 --> 00:03:26,440
 So that is under the assumption.

48
00:03:26,440 --> 00:03:31,440
 So we know, you know, either you go for data driven, that means starting from the partial

49
00:03:31,440 --> 00:03:36,440
 knowledge or those states, starting from there with the supporting factors.

50
00:03:36,440 --> 00:03:41,440
 And then you move on to the direction which leads us to the goal.

51
00:03:41,440 --> 00:03:42,440
 Or you go other way around.

52
00:03:42,440 --> 00:03:49,440
 You pick one of the goal states and then you go get the supporting goal and then supporting

53
00:03:49,440 --> 00:03:52,440
 states which can achieve the goal.

54
00:03:52,440 --> 00:03:56,440
 And then you actually move kind of backwards, right?

55
00:03:56,440 --> 00:03:59,440
 So this is the two direction.

56
00:03:59,440 --> 00:04:06,440
 And we need this way, basically we need to find the algorithm which can help us to systematically

57
00:04:06,440 --> 00:04:09,440
 search the entire graph or entire search space.

58
00:04:09,440 --> 00:04:10,440
 Right?

59
00:04:10,440 --> 00:04:12,440
 So this is a key thing.

60
00:04:12,440 --> 00:04:13,440
 Okay.

61
00:04:13,440 --> 00:04:18,440
 So we also highlight why we want to use graph because this is a representation we have

62
00:04:18,440 --> 00:04:24,440
 and also the behind the theory we may need to can use the graph theory to help us to

63
00:04:24,440 --> 00:04:26,440
 do the analysis.

64
00:04:26,440 --> 00:04:27,440
 Okay.

65
00:04:27,440 --> 00:04:33,440
 Then one very powerful and important algorithm is called backtracking.

66
00:04:33,440 --> 00:04:34,440
 Okay.

67
00:04:34,440 --> 00:04:43,440
 So backtracking, actually that is algorithm can be applied or actually is more broad way

68
00:04:43,440 --> 00:04:48,440
 to search and to find the feasible solutions.

69
00:04:48,440 --> 00:04:55,440
 Not necessarily really just apply to the tree or graph but actually is one to find the possible

70
00:04:55,440 --> 00:05:02,440
 solutions or feasible solutions for those like constraints, satisfactory problem, you know,

71
00:05:02,440 --> 00:05:04,440
 this kind of search problem.

72
00:05:04,440 --> 00:05:05,440
 Okay.

73
00:05:05,440 --> 00:05:07,440
 So basically this is uninformed.

74
00:05:07,440 --> 00:05:10,440
 That means we are not using any of the heuristic value.

75
00:05:10,440 --> 00:05:13,440
 But of course later we can combine.

76
00:05:13,440 --> 00:05:18,440
 If you have a heuristic value available then you can probably also use a backtracking.

77
00:05:18,440 --> 00:05:22,440
 So that's why we say it's a broad kind of search algorithm.

78
00:05:22,440 --> 00:05:23,440
 Okay.

79
00:05:23,440 --> 00:05:32,440
 Compared to say that first or breadth first that kind of BFS or DFS search algorithms probably

80
00:05:32,440 --> 00:05:35,440
 the backtracking is a broad one.

81
00:05:35,440 --> 00:05:36,440
 Okay.

82
00:05:36,440 --> 00:05:39,440
 So let's take a look of this algorithm first.

83
00:05:39,440 --> 00:05:40,440
 Okay.

84
00:05:40,440 --> 00:05:45,440
 So here we really go into like implementation level.

85
00:05:45,440 --> 00:05:49,440
 So we are not really using recursive algorithm.

86
00:05:49,440 --> 00:05:53,440
 We actually tell you use iterative way to do it.

87
00:05:53,440 --> 00:05:54,440
 Okay.

88
00:05:54,440 --> 00:05:56,440
 So we are using tree list here.

89
00:05:56,440 --> 00:05:57,440
 Okay.

90
00:05:57,440 --> 00:05:58,440
 Tree list.

91
00:05:58,440 --> 00:06:03,440
 So you can see first list is to hold the state list.

92
00:06:03,440 --> 00:06:04,440
 Okay.

93
00:06:04,440 --> 00:06:07,440
 So it's what are the solution states.

94
00:06:07,440 --> 00:06:08,440
 Okay.

95
00:06:08,440 --> 00:06:13,440
 So the state can provide a state so that is SL.

96
00:06:13,440 --> 00:06:17,440
 Another one is a new state or actually yeah.

97
00:06:17,440 --> 00:06:21,440
 So those holding those unprocessed states.

98
00:06:21,440 --> 00:06:25,440
 And then we have another list which holds the dead end.

99
00:06:25,440 --> 00:06:29,440
 So those states that is not going to give us an answer.

100
00:06:29,440 --> 00:06:31,440
 We already checked already.

101
00:06:31,440 --> 00:06:32,440
 Okay.

102
00:06:32,440 --> 00:06:35,440
 Then another one is the current state.

103
00:06:35,440 --> 00:06:38,440
 So current state actually is not really a list.

104
00:06:38,440 --> 00:06:40,440
 It's just can be a flag.

105
00:06:40,440 --> 00:06:41,440
 Okay.

106
00:06:41,440 --> 00:06:45,440
 Just to indicate which states we are exploring now.

107
00:06:45,440 --> 00:06:46,440
 Okay.

108
00:06:46,440 --> 00:06:53,440
 So we are using this structure and then we want to go through this procedure.

109
00:06:53,440 --> 00:06:59,440
 So for example, we're using example to explain it first and then we go through the algorithm.

110
00:06:59,440 --> 00:07:00,440
 Okay.

111
00:07:00,440 --> 00:07:04,440
 So on the right hand side, that is a graph here.

112
00:07:04,440 --> 00:07:07,440
 Although it looks very much like a tree.

113
00:07:07,440 --> 00:07:08,440
 Okay.

114
00:07:08,440 --> 00:07:14,440
 Except you have some notes actually you can reach it from more than one path.

115
00:07:14,440 --> 00:07:15,440
 Right.

116
00:07:15,440 --> 00:07:19,440
 So strictly speaking, this is a graph not a tree.

117
00:07:19,440 --> 00:07:26,440
 But actually later you will see we will use words called game tree quite likely.

118
00:07:26,440 --> 00:07:30,440
 We are using game tree although it's not really a tree.

119
00:07:30,440 --> 00:07:31,440
 Okay.

120
00:07:31,440 --> 00:07:36,440
 So it's also have this more than one path can lead to the same notes.

121
00:07:36,440 --> 00:07:39,440
 So based on a no graph definition, this is not the tree.

122
00:07:39,440 --> 00:07:40,440
 It's a graph.

123
00:07:40,440 --> 00:07:45,440
 But you can probably look at as so we can still talk about branch.

124
00:07:45,440 --> 00:07:51,440
 We can still talk about siblings here because we are referring the sibling refer to the

125
00:07:51,440 --> 00:07:52,440
 notes.

126
00:07:52,440 --> 00:07:55,440
 We're actually coming from the connect to the same connector.

127
00:07:55,440 --> 00:07:56,440
 Okay.

128
00:07:56,440 --> 00:07:57,440
 So same parents.

129
00:07:57,440 --> 00:07:58,440
 Okay.

130
00:07:58,440 --> 00:08:01,440
 So if that's the case, we treat them as a sibling.

131
00:08:01,440 --> 00:08:02,440
 Okay.

132
00:08:02,440 --> 00:08:05,440
 So for example, yeah.

133
00:08:05,440 --> 00:08:11,440
 So this is a sibling of this one because they all come from these notes.

134
00:08:11,440 --> 00:08:14,440
 And also this is a sibling of this one.

135
00:08:14,440 --> 00:08:16,440
 They come from the same notes.

136
00:08:16,440 --> 00:08:19,440
 So we can treat this like this.

137
00:08:19,440 --> 00:08:20,440
 Okay.

138
00:08:20,440 --> 00:08:24,440
 So for the backtracking is in a way is a depth first search.

139
00:08:24,440 --> 00:08:32,440
 And also we basically just need to know when we when we search, when we meet the dead end,

140
00:08:32,440 --> 00:08:34,440
 how should we track?

141
00:08:34,440 --> 00:08:35,440
 Okay.

142
00:08:35,440 --> 00:08:36,440
 Track back, backtrack.

143
00:08:36,440 --> 00:08:37,440
 Okay.

144
00:08:37,440 --> 00:08:42,440
 Go back to the previous date to decide how to search make decision next.

145
00:08:42,440 --> 00:08:43,440
 Okay.

146
00:08:43,440 --> 00:08:45,440
 So this is a key idea.

147
00:08:45,440 --> 00:08:47,440
 So how to start?

148
00:08:47,440 --> 00:08:48,440
 Yeah.

149
00:08:48,440 --> 00:08:49,440
 So we're starting from the starting state.

150
00:08:49,440 --> 00:08:53,440
 So for here, suppose this is a starting state.

151
00:08:53,440 --> 00:08:55,440
 And this could be the goal state or whatever.

152
00:08:55,440 --> 00:08:56,440
 Okay.

153
00:08:56,440 --> 00:08:57,440
 We don't, we don't know yet.

154
00:08:57,440 --> 00:09:02,440
 So suppose one of the states is a goal state and we want to start from here.

155
00:09:02,440 --> 00:09:06,440
 Or actually this is a goal state we want to find.

156
00:09:06,440 --> 00:09:10,440
 So in the backtracking, how should we do it?

157
00:09:10,440 --> 00:09:13,440
 So basically branch based or depth first.

158
00:09:13,440 --> 00:09:18,440
 So you go all the way to the end of this branch.

159
00:09:18,440 --> 00:09:19,440
 Okay.

160
00:09:19,440 --> 00:09:24,440
 So that means you check one to see whether this is the goal you want to find.

161
00:09:24,440 --> 00:09:27,440
 If it is, then we can return.

162
00:09:27,440 --> 00:09:29,440
 That means we find the goal.

163
00:09:29,440 --> 00:09:33,440
 If it's not, then we check whether this state have a children.

164
00:09:33,440 --> 00:09:34,440
 Okay.

165
00:09:34,440 --> 00:09:36,440
 Is there any children related to this note?

166
00:09:36,440 --> 00:09:40,440
 If it is, then those children should be considered.

167
00:09:40,440 --> 00:09:41,440
 Okay.

168
00:09:41,440 --> 00:09:43,440
 So how to be considered?

169
00:09:43,440 --> 00:09:47,440
 We will put into this end, I mean one of the list.

170
00:09:47,440 --> 00:09:48,440
 Okay.

171
00:09:48,440 --> 00:09:51,440
 So this just now we say we have, we have three lists.

172
00:09:51,440 --> 00:09:57,440
 So we just need to put into the those unexplored it, unchecked list.

173
00:09:57,440 --> 00:09:58,440
 Okay.

174
00:09:58,440 --> 00:10:00,440
 And then we move on.

175
00:10:00,440 --> 00:10:06,440
 So we have a way to actually put this into at the, you know, dead end or actually we put

176
00:10:06,440 --> 00:10:09,440
 this into the solution list.

177
00:10:09,440 --> 00:10:10,440
 Okay.

178
00:10:10,440 --> 00:10:13,440
 And then we move on to next one.

179
00:10:13,440 --> 00:10:16,440
 And this is based on the depth first.

180
00:10:16,440 --> 00:10:17,440
 Okay.

181
00:10:17,440 --> 00:10:21,440
 So depth first, that means we probably left most branch first, for example.

182
00:10:21,440 --> 00:10:23,440
 Then we can go this way.

183
00:10:23,440 --> 00:10:28,440
 So we check this note and see if this is the solution.

184
00:10:28,440 --> 00:10:33,440
 If it is a goal, if it's not yet, then we check whether this have a children or not.

185
00:10:33,440 --> 00:10:36,440
 If no children, then we probably need to backtrack.

186
00:10:36,440 --> 00:10:37,440
 Okay.

187
00:10:37,440 --> 00:10:38,440
 Back to the previous state.

188
00:10:38,440 --> 00:10:43,440
 If we have children, children should put into the unexplored list.

189
00:10:43,440 --> 00:10:44,440
 Okay.

190
00:10:44,440 --> 00:10:45,440
 Then we do like this.

191
00:10:45,440 --> 00:10:50,440
 So until here, this is still not answered yet.

192
00:10:50,440 --> 00:10:52,440
 It's not the goal state yet.

193
00:10:52,440 --> 00:10:56,440
 And these states have no children now.

194
00:10:56,440 --> 00:10:57,440
 Okay.

195
00:10:57,440 --> 00:10:59,440
 So how to handle no children notes?

196
00:10:59,440 --> 00:11:02,440
 That means we should actually track back.

197
00:11:02,440 --> 00:11:03,440
 Okay.

198
00:11:03,440 --> 00:11:07,440
 And then see if these notes have any other branches.

199
00:11:07,440 --> 00:11:08,440
 Okay.

200
00:11:08,440 --> 00:11:11,440
 That means if these notes have a sibling.

201
00:11:11,440 --> 00:11:14,440
 So if that's a sibling, then we should go to that branch.

202
00:11:14,440 --> 00:11:15,440
 Okay.

203
00:11:15,440 --> 00:11:20,440
 If no sibling, then these notes become, these notes, the children already is broadened.

204
00:11:20,440 --> 00:11:26,440
 And this one, no sibling, then we should actually track back, track further up previous.

205
00:11:26,440 --> 00:11:27,440
 Okay.

206
00:11:27,440 --> 00:11:29,440
 Go back to the previous parents.

207
00:11:29,440 --> 00:11:32,440
 So go back to the grandparents.

208
00:11:32,440 --> 00:11:34,440
 So this is how we do it.

209
00:11:34,440 --> 00:11:35,440
 Okay.

210
00:11:35,440 --> 00:11:39,440
 So let's say for example, this one, we actually track here.

211
00:11:39,440 --> 00:11:43,440
 So after that, we go back here and this have another children.

212
00:11:43,440 --> 00:11:47,440
 So we go to this branch and this one is not goal.

213
00:11:47,440 --> 00:11:48,440
 It's not no children.

214
00:11:48,440 --> 00:11:50,440
 So we should check back.

215
00:11:50,440 --> 00:11:54,440
 And check back, we find these parents is all the children already is broadened.

216
00:11:54,440 --> 00:11:56,440
 So this is become a dead end.

217
00:11:56,440 --> 00:11:57,440
 Okay.

218
00:11:57,440 --> 00:11:59,440
 So you should move to the dead end and backtrack.

219
00:11:59,440 --> 00:12:01,440
 Backtrack here.

220
00:12:01,440 --> 00:12:05,440
 And this branch, this, this, this notes have another branch.

221
00:12:05,440 --> 00:12:07,440
 So we should go this branch.

222
00:12:07,440 --> 00:12:08,440
 Okay.

223
00:12:08,440 --> 00:12:13,440
 So this is how we come here and then go back here, then come back here.

224
00:12:13,440 --> 00:12:15,440
 Here need to be very careful.

225
00:12:15,440 --> 00:12:19,440
 Should we come back here or should we go back here?

226
00:12:19,440 --> 00:12:20,440
 Okay.

227
00:12:20,440 --> 00:12:21,440
 Yes.

228
00:12:21,440 --> 00:12:25,440
 It's coming from these parents when they expanded this F here.

229
00:12:25,440 --> 00:12:26,440
 Right.

230
00:12:26,440 --> 00:12:30,440
 So we should come back to this parents and then from here we go.

231
00:12:30,440 --> 00:12:33,440
 So now this whole two bunch is already fully exploited.

232
00:12:33,440 --> 00:12:38,440
 So we should backtrack to here and then go this way.

233
00:12:38,440 --> 00:12:41,440
 And do we need to put this in?

234
00:12:41,440 --> 00:12:48,440
 Do we need to put the F in again when we come from the C?

235
00:12:48,440 --> 00:12:49,440
 No.

236
00:12:49,440 --> 00:12:50,440
 Yes.

237
00:12:50,440 --> 00:12:51,440
 We will check the algorithm.

238
00:12:51,440 --> 00:12:52,440
 Okay.

239
00:12:52,440 --> 00:12:53,440
 Yeah.

240
00:12:53,440 --> 00:12:54,440
 Probably no.

241
00:12:54,440 --> 00:12:55,440
 Okay.

242
00:12:55,440 --> 00:12:56,440
 Because this already appear before.

243
00:12:56,440 --> 00:12:59,440
 So we already explored here before.

244
00:12:59,440 --> 00:13:01,440
 And then we are not putting.

245
00:13:01,440 --> 00:13:04,440
 So only those add payment appear.

246
00:13:04,440 --> 00:13:06,440
 Then we actually add in.

247
00:13:06,440 --> 00:13:07,440
 Okay.

248
00:13:07,440 --> 00:13:11,440
 So we go this way and then we go back and then come here.

249
00:13:11,440 --> 00:13:12,440
 Okay.

250
00:13:12,440 --> 00:13:18,440
 So this, this, this number here, they bring the sequence we are searching in this graph.

251
00:13:18,440 --> 00:13:19,440
 Okay.

252
00:13:19,440 --> 00:13:20,440
 Yeah.

253
00:13:20,440 --> 00:13:23,440
 So this is words to describe.

254
00:13:23,440 --> 00:13:28,440
 So if reach the dead end, then you should backtrack to the most recent notes on the

255
00:13:28,440 --> 00:13:34,440
 past and see whether that is an unexamined siblings of this dead end.

256
00:13:34,440 --> 00:13:35,440
 Okay.

257
00:13:35,440 --> 00:13:36,440
 Of that particular.

258
00:13:36,440 --> 00:13:37,440
 Yeah.

259
00:13:37,440 --> 00:13:39,440
 And then continue down to this branch.

260
00:13:39,440 --> 00:13:42,440
 And then actually we continue doing this.

261
00:13:42,440 --> 00:13:49,440
 So if you prefer to look at the algorithm in the exclusive, recursive way to look at.

262
00:13:49,440 --> 00:13:56,440
 So basically is you just to see the S and then check the children and then you check

263
00:13:56,440 --> 00:14:00,440
 the children one, children two, how many children you have for each of these.

264
00:14:00,440 --> 00:14:02,440
 You basically do the same thing.

265
00:14:02,440 --> 00:14:06,440
 And then until you find the answer or you find it's unsuccessful.

266
00:14:06,440 --> 00:14:07,440
 Okay.

267
00:14:07,440 --> 00:14:09,440
 So this is the idea.

268
00:14:09,440 --> 00:14:13,440
 But the algorithm we are implementing using the iterative one.

269
00:14:13,440 --> 00:14:16,440
 So again, you know, this is a key idea.

270
00:14:16,440 --> 00:14:23,440
 So we have an unprocessed notes put into the NSL and then that then put into the DE list

271
00:14:23,440 --> 00:14:29,440
 of notes, which is a solution or the state list, which is they are actually holding the

272
00:14:29,440 --> 00:14:33,440
 solution past because the solution past is useful, right?

273
00:14:33,440 --> 00:14:38,440
 Because we want to find which exactly from which goal, which past actually you find, you

274
00:14:38,440 --> 00:14:40,440
 can find the reach the goal states, right?

275
00:14:40,440 --> 00:14:41,440
 You can find the answer.

276
00:14:41,440 --> 00:14:43,440
 So it's good to keep it.

277
00:14:43,440 --> 00:14:45,440
 And so that is in a solution list.

278
00:14:45,440 --> 00:14:49,440
 And then we have another, another just a pointer, right?

279
00:14:49,440 --> 00:14:52,440
 To, to, to tell us current state.

280
00:14:52,440 --> 00:14:54,440
 Actually, you also can don't use it.

281
00:14:54,440 --> 00:14:59,440
 Just take the left most from, from the, you know, unexplored list, for example.

282
00:14:59,440 --> 00:15:00,440
 Okay.

283
00:15:00,440 --> 00:15:06,440
 But yes, to make it clear, this one have the current state pointer.

284
00:15:06,440 --> 00:15:07,440
 Okay.

285
00:15:07,440 --> 00:15:10,440
 So here is the algorithm.

286
00:15:10,440 --> 00:15:17,440
 So it puts in the beginning, yeah, solution is the, the, the solution state is a starting

287
00:15:17,440 --> 00:15:22,440
 state and then the unexplored is also the starting state to start, right?

288
00:15:22,440 --> 00:15:24,440
 So it's not explored it yet.

289
00:15:24,440 --> 00:15:26,440
 It's not checked yet.

290
00:15:26,440 --> 00:15:28,440
 And that end is empty.

291
00:15:28,440 --> 00:15:30,440
 So we have these three lists here.

292
00:15:30,440 --> 00:15:35,440
 And then this is a pointer that is a current states is pointing to the very beginning

293
00:15:35,440 --> 00:15:37,440
 that starts date.

294
00:15:37,440 --> 00:15:38,440
 Okay.

295
00:15:38,440 --> 00:15:40,440
 So we do this while loop here.

296
00:15:40,440 --> 00:15:46,440
 And then the while loop is to check whether there is any notes in the NSL.

297
00:15:46,440 --> 00:15:47,440
 Right.

298
00:15:47,440 --> 00:15:55,440
 And if none of them exists already, then we should just return fail.

299
00:15:55,440 --> 00:15:59,440
 And otherwise we should have a solution from this SL.

300
00:15:59,440 --> 00:16:00,440
 Okay.

301
00:16:00,440 --> 00:16:05,440
 So you see, if it's not empty yet, then what we need to do.

302
00:16:05,440 --> 00:16:11,440
 We get, we check whether current state, the current state, whether this is a goal already.

303
00:16:11,440 --> 00:16:12,440
 Okay.

304
00:16:12,440 --> 00:16:15,440
 So it's goal, then we return SL.

305
00:16:15,440 --> 00:16:16,440
 Okay.

306
00:16:16,440 --> 00:16:17,440
 We find the answer.

307
00:16:17,440 --> 00:16:22,440
 Then the solution state is provided in the SL.

308
00:16:22,440 --> 00:16:23,440
 Okay.

309
00:16:23,440 --> 00:16:24,440
 Go.

310
00:16:24,440 --> 00:16:32,440
 And if as the CS is not goal, but they have children, we should do this part.

311
00:16:32,440 --> 00:16:33,440
 Okay.

312
00:16:33,440 --> 00:16:34,440
 We should do this part.

313
00:16:34,440 --> 00:16:36,440
 We should do this part.

314
00:16:36,440 --> 00:16:41,440
 And if have children, this is the goal.

315
00:16:41,440 --> 00:16:42,440
 Okay.

316
00:16:42,440 --> 00:16:43,440
 We should grow.

317
00:16:43,440 --> 00:16:51,440
 So when we grow, we put into the NSL, that means un-exploit, the un-processed, un-processed

318
00:16:51,440 --> 00:16:53,440
 list.

319
00:16:53,440 --> 00:16:58,440
 We should actually do add it in like a stack.

320
00:16:58,440 --> 00:16:59,440
 Okay.

321
00:16:59,440 --> 00:17:06,440
 So like a stack, that means last in, last in, first out.

322
00:17:06,440 --> 00:17:07,440
 Yes.

323
00:17:07,440 --> 00:17:08,440
 Okay.

324
00:17:08,440 --> 00:17:09,440
 So that is L-I-F-O.

325
00:17:09,440 --> 00:17:10,440
 Okay.

326
00:17:10,440 --> 00:17:15,440
 So only thing is we need to be careful when we take care of the children.

327
00:17:15,440 --> 00:17:21,440
 We actually want to exclude those notes that already appear before.

328
00:17:21,440 --> 00:17:22,440
 Okay.

329
00:17:22,440 --> 00:17:26,440
 So in the dead end or in the SL.

330
00:17:26,440 --> 00:17:27,440
 Okay.

331
00:17:27,440 --> 00:17:30,440
 So all already appear in the NSL.

332
00:17:30,440 --> 00:17:33,440
 So we don't need to add in anymore.

333
00:17:33,440 --> 00:17:34,440
 Okay.

334
00:17:34,440 --> 00:17:35,440
 So this is a thing.

335
00:17:35,440 --> 00:17:37,440
 And then we exclude them.

336
00:17:37,440 --> 00:17:44,440
 The rest of the children, the rest of the children should add into the NSL.

337
00:17:44,440 --> 00:17:45,440
 Okay.

338
00:17:45,440 --> 00:17:49,440
 And add in from the left-hand side.

339
00:17:49,440 --> 00:17:50,440
 Okay.

340
00:17:50,440 --> 00:17:51,440
 Left.

341
00:17:51,440 --> 00:17:52,440
 Okay.

342
00:17:52,440 --> 00:17:55,440
 The first in will be the last out.

343
00:17:55,440 --> 00:17:58,440
 Or the last in will be the first out.

344
00:17:58,440 --> 00:17:59,440
 Okay.

345
00:17:59,440 --> 00:18:01,440
 So we add in from the left.

346
00:18:01,440 --> 00:18:03,440
 So this is how you add into, okay.

347
00:18:03,440 --> 00:18:04,440
 So here be careful.

348
00:18:04,440 --> 00:18:07,440
 This is add into the NSL.

349
00:18:07,440 --> 00:18:08,440
 Okay.

350
00:18:08,440 --> 00:18:10,440
 And treat the NSL as a stack.

351
00:18:10,440 --> 00:18:11,440
 Okay.

352
00:18:11,440 --> 00:18:12,440
 So we add in like that.

353
00:18:12,440 --> 00:18:16,440
 Then after that, we should take the first element.

354
00:18:16,440 --> 00:18:18,440
 That means the last in one.

355
00:18:18,440 --> 00:18:20,440
 That means the one you want to treat.

356
00:18:20,440 --> 00:18:21,440
 You want to do checking.

357
00:18:21,440 --> 00:18:22,440
 Okay.

358
00:18:22,440 --> 00:18:30,440
 So that's why you set the first elements in the NSL, the updated NSL as a current state.

359
00:18:30,440 --> 00:18:31,440
 Okay.

360
00:18:31,440 --> 00:18:34,440
 Then you add this current state into the solution.

361
00:18:34,440 --> 00:18:35,440
 Okay.

362
00:18:35,440 --> 00:18:37,440
 Treat this as a possible solution.

363
00:18:37,440 --> 00:18:38,440
 Add in first.

364
00:18:38,440 --> 00:18:40,440
 And then we go check again.

365
00:18:40,440 --> 00:18:42,440
 So that means come back to here again.

366
00:18:42,440 --> 00:18:43,440
 To check.

367
00:18:43,440 --> 00:18:44,440
 To check.

368
00:18:44,440 --> 00:18:45,440
 Sorry.

369
00:18:45,440 --> 00:18:46,440
 Yeah.

370
00:18:46,440 --> 00:18:47,440
 Here.

371
00:18:47,440 --> 00:18:48,440
 So, oh yes.

372
00:18:48,440 --> 00:18:49,440
 Sorry.

373
00:18:49,440 --> 00:18:50,440
 This is while loop.

374
00:18:50,440 --> 00:18:51,440
 Okay.

375
00:18:51,440 --> 00:18:55,440
 So we should check whether this is go.

376
00:18:55,440 --> 00:18:56,440
 Okay.

377
00:18:56,440 --> 00:19:02,440
 So this is about if it's not the goal and they have children.

378
00:19:02,440 --> 00:19:03,440
 Okay.

379
00:19:03,440 --> 00:19:04,440
 We do here.

380
00:19:04,440 --> 00:19:05,440
 We do this one.

381
00:19:05,440 --> 00:19:08,440
 What if there is no children?

382
00:19:08,440 --> 00:19:10,440
 So this is a complicated part.

383
00:19:10,440 --> 00:19:12,440
 So this is a backtracking part.

384
00:19:12,440 --> 00:19:13,440
 Okay.

385
00:19:13,440 --> 00:19:14,440
 Backtracking part.

386
00:19:14,440 --> 00:19:15,440
 So we check SL.

387
00:19:15,440 --> 00:19:22,440
 If the SL is not empty and also CS is the first element of the SL.

388
00:19:22,440 --> 00:19:25,440
 You later you see this is important.

389
00:19:25,440 --> 00:19:27,440
 We have this end condition.

390
00:19:27,440 --> 00:19:29,440
 We wanted to have this.

391
00:19:29,440 --> 00:19:32,440
 Then if this is a case we should removing, removing, removing.

392
00:19:32,440 --> 00:19:33,440
 Okay.

393
00:19:33,440 --> 00:19:36,440
 So that means the parents before already become dead end.

394
00:19:36,440 --> 00:19:38,440
 We should remove them.

395
00:19:38,440 --> 00:19:39,440
 Okay.

396
00:19:39,440 --> 00:19:41,440
 So last children check, finish checking the last children.

397
00:19:41,440 --> 00:19:43,440
 Then backtrack to the parents.

398
00:19:43,440 --> 00:19:45,440
 Parents also should be removed.

399
00:19:45,440 --> 00:19:46,440
 Okay.

400
00:19:46,440 --> 00:19:52,440
 Until the parents, parents also if all the children already exploited then they should

401
00:19:52,440 --> 00:19:53,440
 satisfy this condition.

402
00:19:53,440 --> 00:19:54,440
 Okay.

403
00:19:54,440 --> 00:19:57,440
 Then you should be removed.

404
00:19:57,440 --> 00:19:59,440
 Repeatedly removed.

405
00:19:59,440 --> 00:20:07,440
 And then, and until you know you have branch then we actually add the CS to the possible

406
00:20:07,440 --> 00:20:12,440
 state, possible solution state and then we continue from there.

407
00:20:12,440 --> 00:20:13,440
 Okay.

408
00:20:13,440 --> 00:20:16,440
 So this is a key idea.

409
00:20:16,440 --> 00:20:20,440
 The details actually quite, quite detailed steps.

410
00:20:20,440 --> 00:20:21,440
 Okay.

411
00:20:21,440 --> 00:20:26,440
 So now that's how we run it.

412
00:20:26,440 --> 00:20:27,440
 Okay.

413
00:20:27,440 --> 00:20:30,440
 So make sure we fully understand it.

414
00:20:30,440 --> 00:20:33,440
 So basically I want to put this part.

415
00:20:33,440 --> 00:20:38,440
 So this is the part when the current states have no children, or had children.

416
00:20:38,440 --> 00:20:39,440
 Sorry.

417
00:20:39,440 --> 00:20:40,440
 So we're having children.

418
00:20:40,440 --> 00:20:47,440
 So that means we should add into the NSL as a stack, you know, and then try to reset.

419
00:20:47,440 --> 00:20:50,440
 And this is a part CS has no children.

420
00:20:50,440 --> 00:20:52,440
 This is what we need to do.

421
00:20:52,440 --> 00:20:53,440
 Okay.

422
00:20:53,440 --> 00:20:55,440
 That's run it, hand run it.

423
00:20:55,440 --> 00:20:56,440
 Okay.

424
00:20:56,440 --> 00:21:02,440
 So basically first thing is we check whether current states is go or not.

425
00:21:02,440 --> 00:21:04,440
 If it's already go, yeah, good.

426
00:21:04,440 --> 00:21:05,440
 Okay.

427
00:21:05,440 --> 00:21:07,440
 So we get something from the solution list.

428
00:21:07,440 --> 00:21:09,440
 So that is one.

429
00:21:09,440 --> 00:21:13,440
 Otherwise it's very, very much totally no then it's a fail.

430
00:21:13,440 --> 00:21:14,440
 Right.

431
00:21:14,440 --> 00:21:16,440
 If the SL is empty then fail.

432
00:21:16,440 --> 00:21:17,440
 Okay.

433
00:21:17,440 --> 00:21:21,440
 So if the CS has children then we go to this part.

434
00:21:21,440 --> 00:21:24,440
 If CS has no children we go here.

435
00:21:24,440 --> 00:21:25,440
 Okay.

436
00:21:25,440 --> 00:21:26,440
 Let's start.

437
00:21:26,440 --> 00:21:28,440
 So initial step zero.

438
00:21:28,440 --> 00:21:34,440
 So what we do is we set the current state, the starting state.

439
00:21:34,440 --> 00:21:38,440
 We set NSL, SL as a current state as well.

440
00:21:38,440 --> 00:21:40,440
 I mean starting state as well.

441
00:21:40,440 --> 00:21:42,440
 That then is empty list.

442
00:21:42,440 --> 00:21:43,440
 Right.

443
00:21:43,440 --> 00:21:44,440
 That's how we start.

444
00:21:44,440 --> 00:21:47,440
 And then we should run.

445
00:21:47,440 --> 00:21:52,440
 I wish I can have different page.

446
00:21:52,440 --> 00:21:53,440
 Yeah.

447
00:21:53,440 --> 00:21:56,440
 So we actually look at the algorithm to see check.

448
00:21:56,440 --> 00:21:58,440
 Does CS is go or not?

449
00:21:58,440 --> 00:22:01,440
 So CS suppose our goal is this one.

450
00:22:01,440 --> 00:22:02,440
 Okay.

451
00:22:02,440 --> 00:22:04,440
 So our goal is not here.

452
00:22:04,440 --> 00:22:07,440
 We just fully explore the space.

453
00:22:07,440 --> 00:22:08,440
 Yeah.

454
00:22:08,440 --> 00:22:14,440
 So the A, so we check the A is not a goal.

455
00:22:14,440 --> 00:22:18,440
 And then we check whether CS, the A has children.

456
00:22:18,440 --> 00:22:19,440
 Right.

457
00:22:19,440 --> 00:22:22,440
 So A has three children.

458
00:22:22,440 --> 00:22:23,440
 Yes.

459
00:22:23,440 --> 00:22:27,440
 So we should do this.

460
00:22:27,440 --> 00:22:28,440
 Yeah.

461
00:22:28,440 --> 00:22:35,440
 So we should remove those children which already in either dead end or the solution list or

462
00:22:35,440 --> 00:22:38,440
 the unprocessed state list.

463
00:22:38,440 --> 00:22:40,440
 Do we have?

464
00:22:40,440 --> 00:22:43,440
 The children actually is a BCD.

465
00:22:43,440 --> 00:22:44,440
 Right.

466
00:22:44,440 --> 00:22:45,440
 BCD.

467
00:22:45,440 --> 00:22:46,440
 Yeah.

468
00:22:46,440 --> 00:22:47,440
 So none of them in the existing one.

469
00:22:47,440 --> 00:22:55,440
 So that means we should add all of them into the NSL and treat them as the new unprocessed

470
00:22:55,440 --> 00:22:56,440
 state.

471
00:22:57,440 --> 00:22:59,440
 So this is how we add in.

472
00:22:59,440 --> 00:23:00,440
 Okay.

473
00:23:00,440 --> 00:23:03,440
 Adding from the left of the list.

474
00:23:03,440 --> 00:23:05,440
 So that is a stack process.

475
00:23:05,440 --> 00:23:06,440
 Okay.

476
00:23:06,440 --> 00:23:08,440
 So we add in.

477
00:23:08,440 --> 00:23:11,440
 So this is the second step.

478
00:23:11,440 --> 00:23:12,440
 First step checking.

479
00:23:12,440 --> 00:23:14,440
 Then we find no children.

480
00:23:14,440 --> 00:23:17,440
 And then we add in, sorry, we find they have children.

481
00:23:17,440 --> 00:23:22,440
 So we've added this into the list, into the NSL list.

482
00:23:22,440 --> 00:23:26,440
 And then what we do is here, right?

483
00:23:26,440 --> 00:23:29,440
 We add the first thing.

484
00:23:29,440 --> 00:23:36,440
 And then we take the first element in the NSL as the current state.

485
00:23:36,440 --> 00:23:41,440
 So that means the B will be used as the current state.

486
00:23:41,440 --> 00:23:48,440
 And then add the current, the new current state into the SL.

487
00:23:48,440 --> 00:23:49,440
 Okay.

488
00:23:49,440 --> 00:23:52,440
 So this is the step.

489
00:23:52,440 --> 00:23:54,440
 You see one.

490
00:23:54,440 --> 00:23:56,440
 And then two.

491
00:23:56,440 --> 00:23:57,440
 And then three.

492
00:23:57,440 --> 00:23:59,440
 So this is coming from here to here.

493
00:23:59,440 --> 00:24:04,440
 And then this one also add into the SL.

494
00:24:04,440 --> 00:24:05,440
 Okay.

495
00:24:05,440 --> 00:24:07,440
 So this is four steps.

496
00:24:07,440 --> 00:24:09,440
 So then we start from here again.

497
00:24:09,440 --> 00:24:10,440
 Check.

498
00:24:10,440 --> 00:24:11,440
 Check.

499
00:24:11,440 --> 00:24:12,440
 The CS.

500
00:24:12,440 --> 00:24:14,440
 Is this one.

501
00:24:15,440 --> 00:24:17,440
 Current state.

502
00:24:17,440 --> 00:24:19,440
 Is this a gold state?

503
00:24:19,440 --> 00:24:20,440
 It's not.

504
00:24:20,440 --> 00:24:21,440
 Right?

505
00:24:21,440 --> 00:24:22,440
 It's not.

506
00:24:22,440 --> 00:24:24,440
 So we are doing the same thing.

507
00:24:24,440 --> 00:24:27,440
 We check the children of the B.

508
00:24:27,440 --> 00:24:29,440
 Is B have children?

509
00:24:29,440 --> 00:24:30,440
 Yes.

510
00:24:30,440 --> 00:24:31,440
 E and F.

511
00:24:31,440 --> 00:24:32,440
 Right?

512
00:24:32,440 --> 00:24:33,440
 E and F.

513
00:24:33,440 --> 00:24:37,440
 Has this E and F appeared in other lists?

514
00:24:37,440 --> 00:24:38,440
 Not yet.

515
00:24:38,440 --> 00:24:39,440
 Right?

516
00:24:39,440 --> 00:24:40,440
 So they can be added in.

517
00:24:40,440 --> 00:24:43,440
 That's why they are added in here.

518
00:24:43,440 --> 00:24:45,440
 So this is step five.

519
00:24:45,440 --> 00:24:46,440
 They are added in.

520
00:24:46,440 --> 00:24:51,440
 And then after you add in, you actually use the first of the NSL.

521
00:24:51,440 --> 00:24:55,440
 That makes the E set as the current state.

522
00:24:55,440 --> 00:25:01,440
 And then this E also add into the SL.

523
00:25:01,440 --> 00:25:02,440
 Okay.

524
00:25:02,440 --> 00:25:04,440
 So far, all right?

525
00:25:04,440 --> 00:25:06,440
 So far it's quite easy.

526
00:25:06,440 --> 00:25:07,440
 Right?

527
00:25:07,440 --> 00:25:08,440
 Smooth.

528
00:25:08,440 --> 00:25:09,440
 Okay.

529
00:25:09,440 --> 00:25:10,440
 Then next.

530
00:25:10,440 --> 00:25:11,440
 Next.

531
00:25:11,440 --> 00:25:14,440
 E, check E, E is not gold.

532
00:25:14,440 --> 00:25:16,440
 And then E has children.

533
00:25:16,440 --> 00:25:17,440
 Yes.

534
00:25:17,440 --> 00:25:18,440
 So still have children.

535
00:25:18,440 --> 00:25:19,440
 So still add in.

536
00:25:19,440 --> 00:25:20,440
 So add in.

537
00:25:20,440 --> 00:25:21,440
 Okay?

538
00:25:21,440 --> 00:25:22,440
 So repeating.

539
00:25:22,440 --> 00:25:25,440
 So we add in.

540
00:25:25,440 --> 00:25:30,440
 Then don't look at this H cancel yet.

541
00:25:30,440 --> 00:25:31,440
 Okay?

542
00:25:31,440 --> 00:25:33,440
 So this is just H and I.

543
00:25:33,440 --> 00:25:38,440
 Add into the NSL as the processed state.

544
00:25:38,440 --> 00:25:39,440
 Okay?

545
00:25:39,440 --> 00:25:45,440
 And then after that, we should move this H to reset the CS.

546
00:25:45,440 --> 00:25:46,440
 Right?

547
00:25:46,440 --> 00:25:47,440
 Okay.

548
00:25:47,440 --> 00:25:55,440
 And then after that, the CS should put into the SL.

549
00:25:55,440 --> 00:26:02,440
 Yeah?

550
00:26:02,440 --> 00:26:07,440
 So then we check whether H is gold.

551
00:26:07,440 --> 00:26:09,440
 H is not the gold.

552
00:26:09,440 --> 00:26:12,440
 And now H have no children.

553
00:26:12,440 --> 00:26:14,440
 H have no children.

554
00:26:14,440 --> 00:26:17,440
 So we cannot use this part anymore.

555
00:26:17,440 --> 00:26:19,440
 We come here.

556
00:26:19,440 --> 00:26:20,440
 Okay.

557
00:26:20,440 --> 00:26:24,440
 So H have no children.

558
00:26:24,440 --> 00:26:29,440
 And then we see whether CS is SL.

559
00:26:29,440 --> 00:26:30,440
 Sorry.

560
00:26:30,440 --> 00:26:33,440
 The solution is that empty?

561
00:26:33,440 --> 00:26:35,440
 It's not empty, right?

562
00:26:35,440 --> 00:26:47,440
 So also whether CS and the first element of the SL is the same.

563
00:26:47,440 --> 00:26:49,440
 It's the same?

564
00:26:49,440 --> 00:26:50,440
 Yes?

565
00:26:50,440 --> 00:26:54,440
 So we should do this part.

566
00:26:54,440 --> 00:26:55,440
 Removing.

567
00:26:55,440 --> 00:26:56,440
 Okay?

568
00:26:56,440 --> 00:26:58,440
 So that means we should track back.

569
00:26:58,440 --> 00:26:59,440
 So we are tracking back.

570
00:26:59,440 --> 00:27:00,440
 So we should remove.

571
00:27:00,440 --> 00:27:01,440
 You see?

572
00:27:01,440 --> 00:27:05,440
 We should add the current CS into that end.

573
00:27:05,440 --> 00:27:06,440
 Yeah?

574
00:27:06,440 --> 00:27:09,440
 Finally, the end have one element.

575
00:27:09,440 --> 00:27:10,440
 Okay?

576
00:27:10,440 --> 00:27:12,440
 We should add the CS to that end.

577
00:27:12,440 --> 00:27:13,440
 That's here.

578
00:27:13,440 --> 00:27:15,440
 The H add into the dead end.

579
00:27:15,440 --> 00:27:17,440
 And then we check.

580
00:27:17,440 --> 00:27:20,440
 We should remove the first element from the SL.

581
00:27:20,440 --> 00:27:23,440
 So first element removed.

582
00:27:23,440 --> 00:27:24,440
 Okay?

583
00:27:24,440 --> 00:27:27,440
 And also remove the same elements from NSL.

584
00:27:27,440 --> 00:27:29,440
 So this one already processed.

585
00:27:29,440 --> 00:27:30,440
 Okay?

586
00:27:30,440 --> 00:27:34,440
 And then the first element of NSL set.

587
00:27:34,440 --> 00:27:40,440
 That means I should be used to set the CS.

588
00:27:40,440 --> 00:27:41,440
 Okay?

589
00:27:41,440 --> 00:27:45,440
 So now what is the, what's inside the CS?

590
00:27:45,440 --> 00:27:47,440
 What is inside the SL?

591
00:27:47,440 --> 00:27:51,440
 First element of the SL is what?

592
00:27:51,440 --> 00:27:53,440
 Don't look at here.

593
00:27:53,440 --> 00:27:55,440
 Actually they jump the steps here.

594
00:27:55,440 --> 00:27:57,440
 Do you notice?

595
00:27:57,440 --> 00:28:02,440
 After we cancel this first one based on here.

596
00:28:02,440 --> 00:28:07,440
 And also we reset the I into the CS.

597
00:28:07,440 --> 00:28:09,440
 Now what do we have?

598
00:28:09,440 --> 00:28:12,440
 CS equal to I and SL haven't update yet.

599
00:28:12,440 --> 00:28:13,440
 Right?

600
00:28:13,440 --> 00:28:16,440
 So SL is these three elements.

601
00:28:16,440 --> 00:28:17,440
 Yes?

602
00:28:17,440 --> 00:28:23,440
 And then the NSL, we have those.

603
00:28:23,440 --> 00:28:24,440
 Okay?

604
00:28:24,440 --> 00:28:26,440
 So is this same?

605
00:28:26,440 --> 00:28:31,440
 The first elements of SL same as I?

606
00:28:31,440 --> 00:28:32,440
 No, right?

607
00:28:32,440 --> 00:28:33,440
 Not the same.

608
00:28:33,440 --> 00:28:37,440
 So this condition is not satisfied anymore.

609
00:28:37,440 --> 00:28:38,440
 Okay?

610
00:28:38,440 --> 00:28:41,440
 So we can come out.

611
00:28:41,440 --> 00:28:42,440
 Yes?

612
00:28:42,440 --> 00:28:44,440
 So we should come here.

613
00:28:44,440 --> 00:28:47,440
 We should add the CS to SL.

614
00:28:47,440 --> 00:28:48,440
 Okay?

615
00:28:48,440 --> 00:28:53,440
 So that means I will add into the SL.

616
00:28:53,440 --> 00:28:54,440
 Okay?

617
00:28:54,440 --> 00:29:00,440
 But next, next, you need to be careful.

618
00:29:00,440 --> 00:29:02,440
 Okay, we are here now.

619
00:29:02,440 --> 00:29:06,440
 So far we finished this and we managed to track back, right?

620
00:29:06,440 --> 00:29:08,440
 And then we come to here.

621
00:29:08,440 --> 00:29:09,440
 We come to here.

622
00:29:09,440 --> 00:29:11,440
 So we track back successfully.

623
00:29:11,440 --> 00:29:15,440
 And we come to search this one to check whether this is go or not.

624
00:29:15,440 --> 00:29:16,440
 Right?

625
00:29:16,440 --> 00:29:21,440
 So that is the I here checking whether this is a go.

626
00:29:21,440 --> 00:29:23,440
 So this is not go yet.

627
00:29:23,440 --> 00:29:24,440
 Okay?

628
00:29:24,440 --> 00:29:25,440
 Not go yet.

629
00:29:25,440 --> 00:29:29,440
 And does this note have children?

630
00:29:29,440 --> 00:29:30,440
 No children.

631
00:29:30,440 --> 00:29:32,440
 So come here again.

632
00:29:32,440 --> 00:29:33,440
 Right?

633
00:29:33,440 --> 00:29:34,440
 Come here again.

634
00:29:34,440 --> 00:29:36,440
 So SL is not empty.

635
00:29:36,440 --> 00:29:41,440
 The first elements of SL equal to CS satisfy this condition.

636
00:29:41,440 --> 00:29:42,440
 Correct?

637
00:29:42,440 --> 00:29:43,440
 Yeah.

638
00:29:43,440 --> 00:29:44,440
 So we should do this part.

639
00:29:44,440 --> 00:29:45,440
 Okay?

640
00:29:45,440 --> 00:29:46,440
 So what we do?

641
00:29:46,440 --> 00:29:49,440
 I will add into the add-and-end.

642
00:29:49,440 --> 00:29:55,440
 And then remove SL, remove the first elements of SL, remove the first elements of the NSL,

643
00:29:55,440 --> 00:29:57,440
 and reset the CS.

644
00:29:57,440 --> 00:29:58,440
 Okay?

645
00:29:58,440 --> 00:30:02,440
 So that means the I will be removed here.

646
00:30:02,440 --> 00:30:05,440
 And this I move to here.

647
00:30:05,440 --> 00:30:07,440
 And this I will be removed.

648
00:30:07,440 --> 00:30:10,440
 This I will be removed.

649
00:30:10,440 --> 00:30:12,440
 Okay, I think I should.

650
00:30:12,440 --> 00:30:14,440
 Okay, I just verbally say it.

651
00:30:14,440 --> 00:30:16,440
 I don't have a pointer to.

652
00:30:16,440 --> 00:30:20,440
 Well, yes, I have a pointer.

653
00:30:20,440 --> 00:30:24,440
 I should remove this one.

654
00:30:24,440 --> 00:30:27,440
 I should remove this one.

655
00:30:27,440 --> 00:30:30,440
 And that one already moved to here.

656
00:30:30,440 --> 00:30:32,440
 Right?

657
00:30:32,440 --> 00:30:35,440
 This is what I'm doing.

658
00:30:35,440 --> 00:30:42,440
 Add into the add-and-remove the first element, remove the first element of the NSL, and then the first element of the...

659
00:30:42,440 --> 00:30:49,440
 Okay, so that means the E should set into the...

660
00:30:49,440 --> 00:30:52,440
 The E should be here.

661
00:30:52,440 --> 00:30:53,440
 Right?

662
00:30:53,440 --> 00:30:55,440
 E should be set.

663
00:30:55,440 --> 00:30:59,440
 I mean, the current state now is the E.

664
00:30:59,440 --> 00:31:00,440
 Okay?

665
00:31:00,440 --> 00:31:02,440
 So this is what?

666
00:31:02,440 --> 00:31:05,440
 And now we're still in this while loop.

667
00:31:05,440 --> 00:31:06,440
 Okay?

668
00:31:06,440 --> 00:31:13,440
 So we need to check whether the SL is not empty and CS is the same element of the SL.

669
00:31:13,440 --> 00:31:14,440
 Okay?

670
00:31:14,440 --> 00:31:16,440
 The CS is E.

671
00:31:16,440 --> 00:31:20,440
 First element of the SL is what?

672
00:31:20,440 --> 00:31:21,440
 E.

673
00:31:21,440 --> 00:31:23,440
 So do we need to...

674
00:31:23,440 --> 00:31:26,440
 Can we come out this loop yet?

675
00:31:26,440 --> 00:31:27,440
 Cannot.

676
00:31:27,440 --> 00:31:29,440
 Cannot come out.

677
00:31:29,440 --> 00:31:30,440
 You see?

678
00:31:30,440 --> 00:31:33,440
 It's satisfied this condition.

679
00:31:33,440 --> 00:31:35,440
 So meaning what?

680
00:31:35,440 --> 00:31:41,440
 E should add into the dead end and remove the first element of SL.

681
00:31:41,440 --> 00:31:46,440
 Remove the first element of NSL, reset CS.

682
00:31:46,440 --> 00:31:50,440
 Okay, so that means E should go.

683
00:31:50,440 --> 00:31:51,440
 E should go.

684
00:31:51,440 --> 00:31:56,440
 And this E should go to the dead end.

685
00:31:56,440 --> 00:31:57,440
 Okay?

686
00:31:57,440 --> 00:31:59,440
 We are still satisfied this condition.

687
00:31:59,440 --> 00:32:04,440
 No need to reset the E into...

688
00:32:04,440 --> 00:32:07,440
 Basically, you don't go here yet.

689
00:32:07,440 --> 00:32:08,440
 Okay?

690
00:32:08,440 --> 00:32:12,440
 This E was the previous step we got it because of eye condition.

691
00:32:12,440 --> 00:32:18,440
 Okay, now after you set, you find the E is exactly the same as the first element in SL.

692
00:32:18,440 --> 00:32:20,440
 So you still satisfy this condition.

693
00:32:20,440 --> 00:32:24,440
 It's not empty and this one satisfies the condition.

694
00:32:24,440 --> 00:32:26,440
 That's why you need to still go this way.

695
00:32:26,440 --> 00:32:27,440
 Okay?

696
00:32:27,440 --> 00:32:28,440
 Remove it.

697
00:32:28,440 --> 00:32:30,440
 Remove the E immediately.

698
00:32:30,440 --> 00:32:31,440
 Okay?

699
00:32:31,440 --> 00:32:32,440
 Yeah.

700
00:32:32,440 --> 00:32:34,440
 This is a tricky part.

701
00:32:34,440 --> 00:32:35,440
 Need to be careful.

702
00:32:35,440 --> 00:32:36,440
 Okay?

703
00:32:36,440 --> 00:32:37,440
 Yeah.

704
00:32:37,440 --> 00:32:38,440
 And then...

705
00:32:38,440 --> 00:32:39,440
 And then what?

706
00:32:39,440 --> 00:32:41,440
 And then next.

707
00:32:41,440 --> 00:32:43,440
 Is this still...

708
00:32:43,440 --> 00:32:47,440
 I mean, now it's not equal to, right?

709
00:32:47,440 --> 00:32:54,440
 The elements of CS is not the same as the first element because now it's a B, right?

710
00:32:54,440 --> 00:32:56,440
 So it's not the same.

711
00:32:56,440 --> 00:32:58,440
 So now we are breaking this while loop.

712
00:32:58,440 --> 00:33:00,440
 So we come here.

713
00:33:00,440 --> 00:33:01,440
 We can come to here.

714
00:33:01,440 --> 00:33:06,440
 That means the CS, the first elements of the CS can put into the...

715
00:33:06,440 --> 00:33:07,440
 Sorry.

716
00:33:07,440 --> 00:33:11,440
 The first elements of the SL can put into...

717
00:33:11,440 --> 00:33:12,440
 So that is the F.

718
00:33:12,440 --> 00:33:14,440
 F go here.

719
00:33:14,440 --> 00:33:15,440
 Okay?

720
00:33:15,440 --> 00:33:17,440
 So then you check the F.

721
00:33:17,440 --> 00:33:19,440
 So this is exactly what we want.

722
00:33:19,440 --> 00:33:24,440
 After we check in the eye, we backtrack to here.

723
00:33:24,440 --> 00:33:27,440
 We are not going to check the E anymore.

724
00:33:27,440 --> 00:33:30,440
 We should backtrack to the previous one.

725
00:33:30,440 --> 00:33:31,440
 Okay?

726
00:33:31,440 --> 00:33:33,440
 So that is the previous one.

727
00:33:33,440 --> 00:33:34,440
 Previous one was a B.

728
00:33:34,440 --> 00:33:35,440
 Okay?

729
00:33:35,440 --> 00:33:40,440
 So that's why we should go to the previous one.

730
00:33:40,440 --> 00:33:41,440
 Sorry.

731
00:33:41,440 --> 00:33:42,440
 Actually, on process...

732
00:33:42,440 --> 00:33:46,440
 Based on this, the on process one actually is the F.

733
00:33:46,440 --> 00:33:48,440
 So we should go to the F directly.

734
00:33:48,440 --> 00:33:49,440
 Okay?

735
00:33:49,440 --> 00:33:56,440
 So we have the F and then F put into the SL and then we start there again.

736
00:33:56,440 --> 00:33:57,440
 Okay?

737
00:33:57,440 --> 00:33:59,440
 So any question?

738
00:33:59,440 --> 00:34:04,440
 So that's how we go.

739
00:34:04,440 --> 00:34:05,440
 Okay?

740
00:34:05,440 --> 00:34:08,440
 So we have the F and then the F have J.

741
00:34:08,440 --> 00:34:12,440
 So F have J and then after that backtrack.

742
00:34:12,440 --> 00:34:13,440
 Yeah?

743
00:34:13,440 --> 00:34:14,440
 So J is the same.

744
00:34:14,440 --> 00:34:16,440
 So we actually backtrack.

745
00:34:16,440 --> 00:34:24,440
 Backtrack F, J and then F and then even the B.

746
00:34:24,440 --> 00:34:25,440
 Right?

747
00:34:25,440 --> 00:34:27,440
 So we can remove all the three.

748
00:34:27,440 --> 00:34:29,440
 And then we go to the A.

749
00:34:29,440 --> 00:34:30,440
 Sorry.

750
00:34:30,440 --> 00:34:32,440
 We actually come to the...

751
00:34:32,440 --> 00:34:33,440
 Yeah.

752
00:34:33,440 --> 00:34:36,440
 Actually, basically, we come to here.

753
00:34:36,440 --> 00:34:40,440
 So we basically make use of the...

754
00:34:40,440 --> 00:34:43,440
 These three actually are already removed.

755
00:34:43,440 --> 00:34:44,440
 Yeah.

756
00:34:44,440 --> 00:34:49,440
 So we come to the C.

757
00:34:49,440 --> 00:34:50,440
 Okay?

758
00:34:50,440 --> 00:34:56,440
 So when we come to the C, the children, the F is no longer need to add in.

759
00:34:56,440 --> 00:34:57,440
 Okay?

760
00:34:57,440 --> 00:35:03,440
 Because F already in the dead end list.

761
00:35:03,440 --> 00:35:05,440
 So F no need to add in.

762
00:35:05,440 --> 00:35:09,440
 Only the children G will be added.

763
00:35:09,440 --> 00:35:10,440
 Okay?

764
00:35:10,440 --> 00:35:16,440
 So for this one, actually, we go through the entire graph.

765
00:35:16,440 --> 00:35:19,440
 And suppose we didn't find the answer.

766
00:35:19,440 --> 00:35:20,440
 Okay?

767
00:35:20,440 --> 00:35:21,440
 The answer is not here.

768
00:35:21,440 --> 00:35:26,440
 So this we run this.

769
00:35:26,440 --> 00:35:29,440
 So please, you need to make sure you can do it.

770
00:35:29,440 --> 00:35:30,440
 Okay?

771
00:35:30,440 --> 00:35:35,440
 Not just understand the concept, but manually you can do it.

772
00:35:35,440 --> 00:35:37,440
 And that's exercise...

773
00:35:37,440 --> 00:35:40,440
 Exercise three, I think.

774
00:35:40,440 --> 00:35:42,440
 Exercise three.

775
00:35:42,440 --> 00:35:47,440
 Exercise three.

776
00:35:47,440 --> 00:35:48,440
 Okay?

777
00:35:48,440 --> 00:35:50,440
 So look at this.

778
00:35:50,440 --> 00:35:53,440
 This is more complicated graph.

779
00:35:53,440 --> 00:35:54,440
 Right?

780
00:35:54,440 --> 00:35:55,440
 So we will...

781
00:35:55,440 --> 00:36:00,440
 I think how many of you already hand run this?

782
00:36:00,440 --> 00:36:02,440
 Not yet, huh?

783
00:36:02,440 --> 00:36:04,440
 So give you time to run.

784
00:36:04,440 --> 00:36:06,440
 We check the answer next week.

785
00:36:06,440 --> 00:36:07,440
 Okay?

786
00:36:07,440 --> 00:36:15,440
 And just to quickly just make sure we understand each other well.

787
00:36:15,440 --> 00:36:25,440
 So for example, when we come to the notes F, what are the children we should add into the NSL?

788
00:36:25,440 --> 00:36:31,440
 Okay, what are the children's?

789
00:36:31,440 --> 00:36:32,440
 L.

790
00:36:32,440 --> 00:36:35,440
 Can I know?

791
00:36:35,440 --> 00:36:37,440
 No more?

792
00:36:37,440 --> 00:36:38,440
 No more?

793
00:36:38,440 --> 00:36:39,440
 A.

794
00:36:39,440 --> 00:36:40,440
 Yeah.

795
00:36:40,440 --> 00:36:43,440
 But A, do we need to add in?

796
00:36:43,440 --> 00:36:44,440
 No need.

797
00:36:44,440 --> 00:36:47,440
 Yeah, because A appeared before.

798
00:36:47,440 --> 00:36:48,440
 Okay, this one thing.

799
00:36:48,440 --> 00:36:50,440
 Another thing, G, for example.

800
00:36:50,440 --> 00:36:53,440
 What are the children of the G?

801
00:36:53,440 --> 00:36:58,440
 Yeah, easily you identify these two, but you probably missed this one.

802
00:36:58,440 --> 00:36:59,440
 Yes.

803
00:36:59,440 --> 00:37:00,440
 Okay, so need to be careful.

804
00:37:00,440 --> 00:37:05,440
 So this one more like very much like a graph instead of three, right?

805
00:37:05,440 --> 00:37:12,440
 But we can still have definition of so-called the parents and siblings, this kind of idea.

806
00:37:12,440 --> 00:37:13,440
 Okay?

807
00:37:13,440 --> 00:37:18,440
 So go try out, use backtracking.

808
00:37:18,440 --> 00:37:19,440
 Okay?

809
00:37:19,440 --> 00:37:22,440
 So we check answer next week.

810
00:37:22,440 --> 00:37:25,440
 So we are not doing it now.

811
00:37:25,440 --> 00:37:29,440
 I think, yeah, better check next week so we have more time.

812
00:37:29,440 --> 00:37:35,440
 And this is answer for the example today.

813
00:37:35,440 --> 00:37:37,440
 Okay?

814
00:37:37,440 --> 00:37:40,440
 Basically we go through this.

815
00:37:40,440 --> 00:37:44,440
 Although a bit messy, so here is a more clean version.

816
00:37:44,440 --> 00:37:47,440
 And do you have this one?

817
00:37:47,440 --> 00:37:50,440
 In your side, you have this one, right?

818
00:37:50,440 --> 00:37:51,440
 Okay, okay.

819
00:37:51,440 --> 00:37:53,440
 So you can check this one, yeah.

820
00:37:53,440 --> 00:37:56,440
 This is our example, okay?

821
00:37:56,440 --> 00:37:58,440
 It's not the exercise.

822
00:37:58,440 --> 00:38:01,440
 Any question?

823
00:38:01,440 --> 00:38:08,440
 A bit serious, but yeah, this is, okay, computer can do it very fast, but we need to fully understand this.

824
00:38:08,440 --> 00:38:13,440
 So that's why I give you a toy problem to hand run it.

825
00:38:13,440 --> 00:38:14,440
 Okay?

826
00:38:14,440 --> 00:38:19,440
 Just need to be careful to see children or other children.

827
00:38:19,440 --> 00:38:27,440
 And then when you backtrack, you know, backtrack to those parents, they already, the children already fully explore, they become a dead end as well.

828
00:38:27,440 --> 00:38:28,440
 Okay?

829
00:38:28,440 --> 00:38:30,440
 Just add in too.

830
00:38:30,440 --> 00:38:37,440
 Okay, so this is, so this is exercise.

831
00:38:37,440 --> 00:38:45,440
 We check next week.

832
00:38:45,440 --> 00:38:51,440
 Okay, so are you ready to move to next algorithm?

833
00:38:51,440 --> 00:38:59,440
 Okay, so backtracking, you see, is systematically to explore, but it's very much more probably for a graph.

834
00:38:59,440 --> 00:39:01,440
 Okay, so you can have this.

835
00:39:01,440 --> 00:39:04,440
 Our next one, next two, next three are very easy.

836
00:39:04,440 --> 00:39:08,440
 Okay, very easy, very easy and very easy to be applied.

837
00:39:08,440 --> 00:39:12,440
 So BFS, okay, BFS from the name you can tell, right?

838
00:39:12,440 --> 00:39:14,440
 Breath first search.

839
00:39:14,440 --> 00:39:16,440
 So we are going level by level.

840
00:39:16,440 --> 00:39:19,440
 So level by level, level by level.

841
00:39:19,440 --> 00:39:25,440
 Okay, so level is depends on the distance from your current state to the root.

842
00:39:25,440 --> 00:39:26,440
 Okay, to the root.

843
00:39:26,440 --> 00:39:29,440
 So that length consider as a level.

844
00:39:29,440 --> 00:39:35,440
 So this is, if this is level zero, then this is all level one and then level two and so on.

845
00:39:35,440 --> 00:39:45,440
 Okay, so only when that's no more states to be explored in the same level, given level, and then the algorithm will move to the next level.

846
00:39:45,440 --> 00:39:47,440
 Okay, so that is a BFS.

847
00:39:47,440 --> 00:39:58,440
 And so from this tree or from this, yes, this graph, what we have level by level, so level one, level zero.

848
00:39:58,440 --> 00:40:07,440
 And BCD, after that, the next level, EFGHIJ, then next level, and next level.

849
00:40:07,440 --> 00:40:10,440
 Okay, level by level, level by level.

850
00:40:10,440 --> 00:40:15,440
 Okay, so that is BFS.

851
00:40:15,440 --> 00:40:18,440
 Implementation.

852
00:40:18,440 --> 00:40:25,440
 Okay, so for BFS, probably we are not interested having an SL.

853
00:40:25,440 --> 00:40:31,440
 So basically we can use these two lists to hold the notes.

854
00:40:31,440 --> 00:40:36,440
 Okay, one is called open, another one is called closed.

855
00:40:36,440 --> 00:40:40,440
 Okay, so closed is like that then, checked already.

856
00:40:40,440 --> 00:40:44,440
 And open are those which is not checked yet.

857
00:40:44,440 --> 00:40:53,440
 Okay, so this is open, hold those which is state need to be checked, and then close is those already exempt.

858
00:40:53,440 --> 00:40:59,440
 So those assess states were removed from the left most.

859
00:40:59,440 --> 00:41:03,440
 Okay, so just check the left most is the one you want to check.

860
00:41:03,440 --> 00:41:16,440
 So in the open, in the open list, you take the left most, and then the new one, the successor or descendants will be add into the right.

861
00:41:16,440 --> 00:41:18,440
 Okay, so it's not add into the left.

862
00:41:18,440 --> 00:41:20,440
 So it's like a queue.

863
00:41:20,440 --> 00:41:21,440
 It's like forming a queue.

864
00:41:21,440 --> 00:41:23,440
 It's not forming a stack, it's forming a queue.

865
00:41:23,440 --> 00:41:28,440
 So that is the first coming, first out, right, from a queue.

866
00:41:28,440 --> 00:41:33,440
 So this is for the open, it's from the queue.

867
00:41:33,440 --> 00:41:40,440
 So we are adding into the tail, right, the tail of the queue, because we are taking from the left most.

868
00:41:40,440 --> 00:41:47,440
 Okay, we are taking the states to be exempt from the left most in the open list.

869
00:41:47,440 --> 00:41:51,440
 Okay, so this is the idea.

870
00:41:51,440 --> 00:41:56,440
 Yeah, so this is much simple, right.

871
00:41:56,440 --> 00:42:03,440
 So only two list, one is taking the state to be exempt, one is holding the states already checked.

872
00:42:03,440 --> 00:42:08,440
 Okay, so open, which is having those state need to be exempt.

873
00:42:08,440 --> 00:42:14,440
 So starting from the starting states, right, then the close will be those exams already.

874
00:42:14,440 --> 00:42:19,440
 And then check whether the open still have states in the open list.

875
00:42:19,440 --> 00:42:22,440
 If it is, then we do something.

876
00:42:22,440 --> 00:42:28,440
 If not, that means, yeah, you haven't find anything that means fail already.

877
00:42:28,440 --> 00:42:34,440
 Okay, so for the open, we take the left most, see, left most.

878
00:42:34,440 --> 00:42:41,440
 Left most from this open list, and suppose we put, call it X, okay, call it X.

879
00:42:41,440 --> 00:42:46,440
 The first elements in the open list, left most.

880
00:42:46,440 --> 00:42:49,440
 And then we check whether X is already a goal.

881
00:42:49,440 --> 00:42:52,440
 If it is, successful, okay, we find it.

882
00:42:52,440 --> 00:42:55,440
 Otherwise, we do this.

883
00:42:55,440 --> 00:42:57,440
 Otherwise, do what?

884
00:42:57,440 --> 00:42:59,440
 Children of the X.

885
00:42:59,440 --> 00:43:06,440
 Get all the children of the X, and then put the current X into the closed list.

886
00:43:06,440 --> 00:43:10,440
 That means X already exempt, and then throw it away.

887
00:43:10,440 --> 00:43:11,440
 So X gone.

888
00:43:11,440 --> 00:43:19,440
 And then we eliminate all the children of the X, which already appeared in the open,

889
00:43:19,440 --> 00:43:22,440
 or have been exempt in the closed list.

890
00:43:22,440 --> 00:43:24,440
 Okay, so that is the one.

891
00:43:24,440 --> 00:43:26,440
 So get rid of them first.

892
00:43:26,440 --> 00:43:33,440
 Put the remaining, put the rest of the children to the right end of the open list.

893
00:43:33,440 --> 00:43:37,440
 Okay, form a queue, form a queue, right end, right?

894
00:43:37,440 --> 00:43:38,440
 Tell of the queue.

895
00:43:38,440 --> 00:43:40,440
 Yeah, so this is the one.

896
00:43:40,440 --> 00:43:46,440
 So just, just, then you're open to check from the left most again.

897
00:43:46,440 --> 00:43:49,440
 Okay, then new one add into the tail.

898
00:43:49,440 --> 00:43:50,440
 That's all.

899
00:43:50,440 --> 00:43:52,440
 Yeah.

900
00:43:52,440 --> 00:43:54,440
 Clear?

901
00:43:54,440 --> 00:43:58,440
 Okay, hand run again.

902
00:43:58,440 --> 00:43:59,440
 Okay.

903
00:43:59,440 --> 00:44:02,440
 So we are using these three.

904
00:44:02,440 --> 00:44:06,440
 So suppose this is the goal, or actually no goal.

905
00:44:06,440 --> 00:44:10,440
 Okay, we just up to us how much you want to run.

906
00:44:10,440 --> 00:44:14,440
 So we are using a BFS to run this.

907
00:44:14,440 --> 00:44:22,440
 So we have two, and the queue, or first thing, first out, or you call it the last thing.

908
00:44:22,440 --> 00:44:23,440
 Oh, sorry.

909
00:44:23,440 --> 00:44:25,440
 Yeah, actually it's a queue.

910
00:44:25,440 --> 00:44:29,440
 And then you have open list, and also have closed list.

911
00:44:29,440 --> 00:44:35,440
 Okay, so when you add into, actually this one, we didn't say anything about how you want

912
00:44:35,440 --> 00:44:39,440
 to handle the closed list, so up to you, it's not important.

913
00:44:39,440 --> 00:44:44,440
 Okay, so you can add into the left, or you want to left into the right, it's up to us.

914
00:44:44,440 --> 00:44:51,440
 Okay, so for the open, we must have a queue, then you can actually form the branched,

915
00:44:51,440 --> 00:44:56,440
 the, oh sorry, the level by level, yeah, level by level, BFS.

916
00:44:56,440 --> 00:44:59,440
 Okay, so this is the one.

917
00:44:59,440 --> 00:45:01,440
 We have the A to start.

918
00:45:01,440 --> 00:45:05,440
 So there is a starting state, and the closed list is empty.

919
00:45:05,440 --> 00:45:09,440
 Okay, and then we check whether A is a goal, so A is not goal.

920
00:45:09,440 --> 00:45:10,440
 Is there any children?

921
00:45:10,440 --> 00:45:12,440
 Yes, I have three children.

922
00:45:12,440 --> 00:45:16,440
 So three children add into the open list, right?

923
00:45:16,440 --> 00:45:24,440
 Open the current X, the current X, throw into the closed, and then these three children

924
00:45:24,440 --> 00:45:29,440
 add into the right-hand side of the list, the open list.

925
00:45:29,440 --> 00:45:35,440
 But open list is empty, so left-hand side or right-hand side, it won't show much, right?

926
00:45:35,440 --> 00:45:38,440
 But yes, this one will show, this one show.

927
00:45:38,440 --> 00:45:44,440
 Yeah, so three add in, and then take the leftmost as the X, right?

928
00:45:44,440 --> 00:45:50,440
 So B, check the B, and then B has children, yes, E and F.

929
00:45:50,440 --> 00:45:54,440
 So E and F must add into the tail, okay?

930
00:45:54,440 --> 00:45:55,440
 Right-hand side.

931
00:45:55,440 --> 00:45:59,440
 Right-hand side of the open list, okay, open list.

932
00:45:59,440 --> 00:46:05,440
 And then put the X, the current X, into the closed list, right?

933
00:46:05,440 --> 00:46:08,440
 And then move on.

934
00:46:08,440 --> 00:46:11,440
 The leftmost becomes X, right?

935
00:46:11,440 --> 00:46:13,440
 So there is a C.

936
00:46:13,440 --> 00:46:16,440
 So C has children, yes, G and H.

937
00:46:16,440 --> 00:46:23,440
 G and H add into the open, and then the C will add into the closed list, and then move on.

938
00:46:23,440 --> 00:46:29,440
 Okay, so this is all the way until like here, okay?

939
00:46:29,440 --> 00:46:41,440
 So suppose if the U is a goal, yeah, until we find the U, actually we still failed.

940
00:46:41,440 --> 00:46:49,440
 Okay, so here I just, it's not everything show yet, we can show a few more steps, yeah?

941
00:46:49,440 --> 00:46:55,440
 Okay, so this one is quite straightforward, right?

942
00:46:55,440 --> 00:47:00,440
 Okay, next.

943
00:47:00,440 --> 00:47:02,440
 Oh, no, no, no, next.

944
00:47:02,440 --> 00:47:11,440
 So actually we are ending here for this lecture, suppose we go through the backtracking, which is more complicated,

945
00:47:11,440 --> 00:47:15,440
 and then the breadth BFS, okay?

946
00:47:15,440 --> 00:47:24,440
 So BFS is another way to implement the depth first, oh sorry, breadth BFS, okay?

947
00:47:24,440 --> 00:47:27,440
 So yeah, we are using two lists only.

948
00:47:27,440 --> 00:47:32,440
 So we just use the open and also the closed list, yeah?

949
00:47:32,440 --> 00:47:40,440
 And then when you're forming the, when you add in new elements into the open list, you need to form a queue, okay?

950
00:47:40,440 --> 00:47:50,440
 Okay, so that means add into the tail, the rightmost as a new children will be adding from there, okay?

951
00:47:50,440 --> 00:47:59,440
 And then you take, always take the leftmost as a state going to be exempt, yeah?

952
00:47:59,440 --> 00:48:03,440
 Okay, we can continue, huh?

953
00:48:03,440 --> 00:48:09,440
 No need to break, yeah?

954
00:48:09,440 --> 00:48:15,440
 Okay, so another way, okay, so algorithm is very simple.

955
00:48:15,440 --> 00:48:18,440
 So is there any issue with this approach?

956
00:48:18,440 --> 00:48:25,440
 Okay, what is the major disadvantage or what is the major could be the bottom neck of this approach?

957
00:48:25,440 --> 00:48:30,440
 So let's take a look of the size of the memory required, okay?

958
00:48:30,440 --> 00:48:36,440
 So the slightly darker blue here, yeah, it is very hard to tell.

959
00:48:36,440 --> 00:48:47,440
 This light blue, slightly darker light blue, actually it indicates the elements of the states inside the closed list, okay?

960
00:48:47,440 --> 00:48:48,440
 Closed list.

961
00:48:48,440 --> 00:48:55,440
 And the lighter blue, very light blue here is the elements, states inside the open list, okay?

962
00:48:55,440 --> 00:48:59,440
 So you can see it's a left, I mean level by level.

963
00:48:59,440 --> 00:49:09,440
 So when you check this, all the children will be in, and then when you check this, the other elements should be in as well, right?

964
00:49:09,440 --> 00:49:13,440
 So it should be added into the open.

965
00:49:13,440 --> 00:49:22,440
 So this is the amount of the elements, states will be hosted inside the open list, okay?

966
00:49:22,440 --> 00:49:34,440
 So when you check in this one, that means this already exempt, and those, those, those already throw into the closed, but there are children already add into the open.

967
00:49:34,440 --> 00:49:43,440
 Until here, when you exempt this, then this, this, as well as those already add into the open list, right?

968
00:49:43,440 --> 00:49:45,440
 So you can see the depth.

969
00:49:45,440 --> 00:49:58,440
 When you go, the depth grows deeper how the requirements, what is the impact to the, to the, to the size of the memory, right?

970
00:49:58,440 --> 00:50:10,440
 You need to host, you need to hold the, the, all the children, and the children number depends on the depth of your goal, right?

971
00:50:10,440 --> 00:50:16,440
 So, so depends on the depth of the tree or depth of the graph, right?

972
00:50:16,440 --> 00:50:20,440
 So this is the major thing.

973
00:50:20,440 --> 00:50:26,440
 So this is at this step, step six here, yeah, you can see those are in the close.

974
00:50:26,440 --> 00:50:36,440
 We have all those, the states here, one, two, three, four, five, six, seven are in the open list, okay?

975
00:50:36,440 --> 00:50:45,440
 So this is the requirement to the, the pressure we will have for the memory requirements, okay?

976
00:50:45,440 --> 00:50:49,440
 To the, for the BFS, okay?

977
00:50:49,440 --> 00:50:50,440
 For the BFS.

978
00:50:50,440 --> 00:50:59,440
 So if the branch factor is B, then the memory we require is B to the power of N, okay?

979
00:50:59,440 --> 00:51:01,440
 So N is the depth here.

980
00:51:01,440 --> 00:51:05,440
 So this is, this is just imagine, okay?

981
00:51:05,440 --> 00:51:07,440
 Just imagine the goal.

982
00:51:07,440 --> 00:51:14,440
 This is those figures I don't even, I can't imagine what's the size of this, okay?

983
00:51:14,440 --> 00:51:23,440
 Doesn't matter how we derive it, this is just the, the, the figure actually is about, about estimated, about this figure, okay?

984
00:51:23,440 --> 00:51:25,440
 Ten to the power of 360, okay?

985
00:51:25,440 --> 00:51:29,440
 So you can imagine one trillion is ten to the power of 12, okay?

986
00:51:29,440 --> 00:51:32,440
 So huge, very, very big.

987
00:51:32,440 --> 00:51:35,440
 So that is mission impossible, right?

988
00:51:35,440 --> 00:51:36,440
 Mission impossible.

989
00:51:36,440 --> 00:51:43,440
 That's why when we see the goal, computer can play the goal well, can beat the human being.

990
00:51:43,440 --> 00:51:47,440
 It was like, yeah, this is like how to achieve this.

991
00:51:47,440 --> 00:51:51,440
 Definitely not state-based approach, right?

992
00:51:51,440 --> 00:51:57,440
 Okay, so this is a major limitation or major issue with the BFS.

993
00:51:57,440 --> 00:52:01,440
 What is the advantage of BFS?

994
00:52:01,440 --> 00:52:04,440
 Level by level, yeah, simple.

995
00:52:04,440 --> 00:52:05,440
 Anything else?

996
00:52:05,440 --> 00:52:09,440
 I mean, if suppose we have the memory.

997
00:52:09,440 --> 00:52:16,440
 And also another thing I want to say is some state, it may repeat, okay?

998
00:52:16,440 --> 00:52:20,440
 In the game, game, game tree, states may repeat, right?

999
00:52:20,440 --> 00:52:26,440
 Because it's with a different, also depends on your opponent, how they play, and then can lead to the same state,

1000
00:52:26,440 --> 00:52:28,440
 but different level, okay?

1001
00:52:28,440 --> 00:52:33,440
 So if you want to find a goal state, some is here, some is there, okay?

1002
00:52:33,440 --> 00:52:39,440
 So for BFS, which one you can find first?

1003
00:52:39,440 --> 00:52:41,440
 Level by level, right?

1004
00:52:41,440 --> 00:52:45,440
 So you can find this one rather than the deep down one.

1005
00:52:45,440 --> 00:52:48,440
 So that is a kind of optimized answer, right?

1006
00:52:48,440 --> 00:52:50,440
 That is an advantage, okay?

1007
00:52:50,440 --> 00:52:58,440
 So if the memory can hold, you know, your memory is big enough than BFS, and also feasible time,

1008
00:52:58,440 --> 00:53:06,440
 BFS can find probably optimal answer, okay?

1009
00:53:06,440 --> 00:53:09,440
 Okay, enough about BFS.

1010
00:53:09,440 --> 00:53:16,440
 Now let's move on to next BFS, depth first search.

1011
00:53:16,440 --> 00:53:19,440
 Because we say memory is an issue, right?

1012
00:53:19,440 --> 00:53:27,440
 So can we have something which can help us with systematic search and at the same time don't cause us so much memory?

1013
00:53:27,440 --> 00:53:30,440
 That looks like it's an answer, right?

1014
00:53:30,440 --> 00:53:33,440
 So we go branch by branch.

1015
00:53:33,440 --> 00:53:37,440
 So branch by branch, that is a depth first search.

1016
00:53:37,440 --> 00:53:48,440
 So that means we examine all the children, and that means for a state, we examine all its children and they are descendants.

1017
00:53:48,440 --> 00:53:52,440
 And examine before they are siblings, okay?

1018
00:53:52,440 --> 00:53:54,440
 That means they are other branches.

1019
00:53:54,440 --> 00:53:59,440
 So deep, deep, deep, deep down, down, down, down all the way, okay?

1020
00:53:59,440 --> 00:54:02,440
 Before examine your siblings.

1021
00:54:02,440 --> 00:54:09,440
 So that is actually backtracking also in a way is a deep depth first, right?

1022
00:54:09,440 --> 00:54:11,440
 Yeah, so go this way.

1023
00:54:11,440 --> 00:54:20,440
 So from the principle, yeah, only when no further descendants of the states can be found, and then the sibling will be considered.

1024
00:54:20,440 --> 00:54:22,440
 Okay, so this is the one.

1025
00:54:22,440 --> 00:54:24,440
 So you go, go, go, go all the way.

1026
00:54:24,440 --> 00:54:30,440
 So no more descendants can be found for these notes, for example.

1027
00:54:30,440 --> 00:54:35,440
 Then, no, sorry, for these notes, no more descendants can be found.

1028
00:54:35,440 --> 00:54:39,440
 Then you go to another branch, okay?

1029
00:54:39,440 --> 00:54:41,440
 So that is a depth first.

1030
00:54:41,440 --> 00:54:48,440
 So, okay.

1031
00:54:48,440 --> 00:54:54,440
 So for this one will be the sequence, yeah?

1032
00:54:54,440 --> 00:54:56,440
 I already color code you.

1033
00:54:56,440 --> 00:54:59,440
 So that means we go A, B, E, K, S.

1034
00:54:59,440 --> 00:55:02,440
 After that, yeah, L, T.

1035
00:55:02,440 --> 00:55:05,440
 Then go back to this branch, right?

1036
00:55:05,440 --> 00:55:07,440
 So, and so on.

1037
00:55:07,440 --> 00:55:09,440
 Branch by branch, okay?

1038
00:55:09,440 --> 00:55:17,440
 So backtracking, we said, it's also a depth first search.

1039
00:55:17,440 --> 00:55:23,440
 Okay, so implementation wise, yeah, you will see another way to implement the depth first search.

1040
00:55:23,440 --> 00:55:25,440
 We already see one which is for backtracking.

1041
00:55:25,440 --> 00:55:28,440
 Backtracking in a way is depth first as well.

1042
00:55:28,440 --> 00:55:30,440
 But now we have another way.

1043
00:55:30,440 --> 00:55:36,440
 So another way, another implementation is we just use two lists, open and closed.

1044
00:55:36,440 --> 00:55:39,440
 We don't use three plus one.

1045
00:55:39,440 --> 00:55:51,440
 Okay, so the descendant notes will be at and then removed from the leftmost of the open to be examined.

1046
00:55:52,440 --> 00:55:54,440
 Descendant, yeah.

1047
00:55:54,440 --> 00:56:00,440
 Okay, so everything add into the state, open states from the left.

1048
00:56:00,440 --> 00:56:03,440
 Okay, take also take from the left.

1049
00:56:03,440 --> 00:56:08,440
 So that means it's a stack class, the last in first out.

1050
00:56:08,440 --> 00:56:18,440
 Okay, and then, okay, so this is what we have.

1051
00:56:18,440 --> 00:56:22,440
 We have the implementation two lists, one is open, one is closed.

1052
00:56:22,440 --> 00:56:26,440
 And then the states have been exempt.

1053
00:56:26,440 --> 00:56:30,440
 So the children would be not be exempt.

1054
00:56:33,440 --> 00:56:39,440
 Oh, yeah, so the states which are already generally about having exempt yet to add into the open.

1055
00:56:39,440 --> 00:56:44,440
 Okay, so similar like NSL in the backtracking.

1056
00:56:44,440 --> 00:56:49,440
 Yeah, but then the closed basically is the dead end.

1057
00:56:49,440 --> 00:56:59,440
 Okay, and only thing is when we add in, we add into the open list from the left.

1058
00:56:59,440 --> 00:57:05,440
 Okay, from the left, forming a stack instead of forming a queue.

1059
00:57:05,440 --> 00:57:08,440
 A queue is a BFS, okay.

1060
00:57:08,440 --> 00:57:13,440
 DFS is a stack, so add from the left.

1061
00:57:13,440 --> 00:57:16,440
 That's the key difference.

1062
00:57:16,440 --> 00:57:18,440
 So, you see?

1063
00:57:18,440 --> 00:57:24,440
 So open, yeah, you have the starting, then closed list is empty to start with.

1064
00:57:24,440 --> 00:57:28,440
 If the open still have elements, then we should do this part.

1065
00:57:28,440 --> 00:57:34,440
 We should take the first, the leftmost from the open list, we call it X.

1066
00:57:34,440 --> 00:57:38,440
 And then we check whether X is a goal already.

1067
00:57:38,440 --> 00:57:40,440
 If it is, then successful, funded.

1068
00:57:40,440 --> 00:57:42,440
 Otherwise, we do this.

1069
00:57:42,440 --> 00:57:49,440
 So that means we take the children of the X and then put the current X into the closed list.

1070
00:57:49,440 --> 00:57:51,440
 That means the dead end.

1071
00:57:51,440 --> 00:57:57,440
 And then also check all the children of the X and remove those they already appear before.

1072
00:57:57,440 --> 00:57:59,440
 Okay, we don't consider them anymore.

1073
00:57:59,440 --> 00:58:05,440
 And then put the rest into the left-hand side of the open list.

1074
00:58:05,440 --> 00:58:09,440
 Okay, that means add them in from the left.

1075
00:58:10,440 --> 00:58:13,440
 Yeah, so the open will act as a stack.

1076
00:58:13,440 --> 00:58:15,440
 Okay.

1077
00:58:18,440 --> 00:58:22,440
 Okay, so that's all for the DFS.

1078
00:58:28,440 --> 00:58:30,440
 So, we run it.

1079
00:58:33,440 --> 00:58:36,440
 So again, if this is a goal.

1080
00:58:37,440 --> 00:58:45,440
 And start with the starting states, closed list is empty.

1081
00:58:45,440 --> 00:58:49,440
 Okay, then we check whether X is already the goal.

1082
00:58:49,440 --> 00:58:50,440
 It's not.

1083
00:58:50,440 --> 00:58:54,440
 Then the children of the X, the BCD.

1084
00:58:54,440 --> 00:58:56,440
 So, BCD, any of them appear before?

1085
00:58:56,440 --> 00:58:57,440
 No.

1086
00:58:57,440 --> 00:59:02,440
 So, all of them can be add into the open list.

1087
00:59:02,440 --> 00:59:05,440
 And the other X already put into the closed.

1088
00:59:05,440 --> 00:59:07,440
 So, it's empty open now.

1089
00:59:07,440 --> 00:59:10,440
 And then these three elements add into the left.

1090
00:59:10,440 --> 00:59:13,440
 Okay, so we cannot see add in.

1091
00:59:13,440 --> 00:59:16,440
 Okay, and then B will be the X.

1092
00:59:16,440 --> 00:59:17,440
 B will be checked.

1093
00:59:17,440 --> 00:59:18,440
 And B is not.

1094
00:59:18,440 --> 00:59:19,440
 And B is short way.

1095
00:59:19,440 --> 00:59:21,440
 The children of the B is the EF.

1096
00:59:21,440 --> 00:59:26,440
 So, EF add into the left-hand side and so on.

1097
00:59:26,440 --> 00:59:27,440
 Okay.

1098
00:59:27,440 --> 00:59:32,440
 And yeah, continue until the U is funded.

1099
00:59:33,440 --> 00:59:36,440
 Okay, any questions?

1100
00:59:40,440 --> 00:59:42,440
 So, easy to run this.

1101
00:59:42,440 --> 00:59:45,440
 It's very easy to run BFS, BFS.

1102
00:59:45,440 --> 00:59:47,440
 I mean, normally very.

1103
00:59:47,440 --> 00:59:51,440
 So, I will test you on the backtracking.

1104
00:59:51,440 --> 00:59:56,440
 Okay, so this is the thing.

1105
00:59:56,440 --> 00:59:58,440
 Yeah, you need to hand run it.

1106
00:59:58,440 --> 00:59:59,440
 Okay.

1107
01:00:00,440 --> 01:00:03,440
 So, I say this alternative way implement the depth first.

1108
01:00:03,440 --> 01:00:06,440
 Because we are only using this two list.

1109
01:00:06,440 --> 01:00:07,440
 It's down.

1110
01:00:09,440 --> 01:00:14,440
 So, yeah, let's take a look at memory requirement now.

1111
01:00:14,440 --> 01:00:20,440
 So, remember the major issue with the breadth first search is the memory.

1112
01:00:20,440 --> 01:00:21,440
 Like memory cost.

1113
01:00:21,440 --> 01:00:23,440
 So, now what about this?

1114
01:00:23,440 --> 01:00:28,440
 Yeah, so when we basically go this way.

1115
01:00:28,440 --> 01:00:30,440
 So, this is in our close list.

1116
01:00:30,440 --> 01:00:33,440
 Like the slightly dark curve light blue.

1117
01:00:33,440 --> 01:00:36,440
 And then lighter light blue is here.

1118
01:00:36,440 --> 01:00:44,440
 Okay, so that is when we having the step here, right?

1119
01:00:44,440 --> 01:00:45,440
 Six.

1120
01:00:45,440 --> 01:00:46,440
 Yeah.

1121
01:00:46,440 --> 01:00:56,440
 So, this fall is inside the open.

1122
01:00:56,440 --> 01:00:57,440
 Okay.

1123
01:00:57,440 --> 01:00:59,440
 The other side in the closed.

1124
01:00:59,440 --> 01:01:04,440
 We already finished this branch.

1125
01:01:04,440 --> 01:01:09,440
 So, you see the thing in the open will be smaller.

1126
01:01:09,440 --> 01:01:10,440
 Right?

1127
01:01:10,440 --> 01:01:15,440
 So, the memory may not be the major issue now.

1128
01:01:15,440 --> 01:01:31,440
 So, what would be the issue?

1129
01:01:31,440 --> 01:01:36,440
 Imagine the answer is somewhere here.

1130
01:01:36,440 --> 01:01:37,440
 Okay.

1131
01:01:37,440 --> 01:01:44,440
 And then we have a huge deep, deep, deep, deep, long lane.

1132
01:01:44,440 --> 01:01:47,440
 We have a deep down branch.

1133
01:01:47,440 --> 01:01:53,440
 The answer is not in that branch at all.

1134
01:01:53,440 --> 01:01:58,440
 Then we can actually waste all of time, all of life there.

1135
01:01:58,440 --> 01:01:59,440
 Possible.

1136
01:01:59,440 --> 01:02:01,440
 Yeah, that's the worst case.

1137
01:02:01,440 --> 01:02:03,440
 We always talk about the worst case.

1138
01:02:03,440 --> 01:02:04,440
 Yeah.

1139
01:02:04,440 --> 01:02:05,440
 So, that is the issue.

1140
01:02:05,440 --> 01:02:11,440
 Another issue is of course just now we say the level by level we will find the best,

1141
01:02:11,440 --> 01:02:12,440
 better answer, right?

1142
01:02:12,440 --> 01:02:13,440
 The optimal answer.

1143
01:02:13,440 --> 01:02:17,440
 If the answer is there, we will find it first rather than the deep down one.

1144
01:02:17,440 --> 01:02:20,440
 But for this one, it's hard to say.

1145
01:02:20,440 --> 01:02:21,440
 It depends on the branch.

1146
01:02:21,440 --> 01:02:22,440
 Right?

1147
01:02:22,440 --> 01:02:25,440
 You may actually find the answer which is not optimal.

1148
01:02:25,440 --> 01:02:28,440
 You actually have a much better answer over there.

1149
01:02:28,440 --> 01:02:31,440
 But it's the, you know, right hand side of the branch.

1150
01:02:31,440 --> 01:02:32,440
 Yeah.

1151
01:02:32,440 --> 01:02:33,440
 So, you can't find it.

1152
01:02:33,440 --> 01:02:40,440
 But major thing is you probably cannot, even the answer exists, you probably cannot find

1153
01:02:40,440 --> 01:02:41,440
 it.

1154
01:02:41,440 --> 01:02:42,440
 So, that is the major thing.

1155
01:02:42,440 --> 01:02:49,440
 We waste our life to certain branch which is totally wrong, mislead branch.

1156
01:02:49,440 --> 01:02:50,440
 Right?

1157
01:02:50,440 --> 01:02:55,440
 So, that is a major issue with this.

1158
01:02:55,440 --> 01:02:56,440
 Yeah.

1159
01:02:56,440 --> 01:02:59,440
 You can take a look of this.

1160
01:02:59,440 --> 01:03:08,440
 We try to show this, the previous using this power, right, the eight puzzle.

1161
01:03:08,440 --> 01:03:18,440
 And so, you see, suppose our goal is sorted, the numbered tower around the, you know, so

1162
01:03:18,440 --> 01:03:24,440
 one, two, three, four, five, six, eight, you know, the empty power is in the middle.

1163
01:03:24,440 --> 01:03:26,440
 So, suppose this is our goal.

1164
01:03:26,440 --> 01:03:32,440
 And so, those are the possible movement, a few steps and the answer is here, right?

1165
01:03:32,440 --> 01:03:39,440
 So, if you use BFS, you will go like, you need to check, you get the answer.

1166
01:03:39,440 --> 01:03:42,440
 So, you need to check 46 times.

1167
01:03:42,440 --> 01:03:43,440
 Okay.

1168
01:03:43,440 --> 01:03:50,440
 But if you go for depth first, this one looks like a faster.

1169
01:03:50,440 --> 01:03:52,440
 Faster get the answer.

1170
01:03:52,440 --> 01:03:53,440
 Okay.

1171
01:03:53,440 --> 01:03:54,440
 But it really depends.

1172
01:03:54,440 --> 01:03:55,440
 It really depends.

1173
01:03:55,440 --> 01:04:02,440
 So, you can see it's just a different way to systematically find the goal, to search for

1174
01:04:02,440 --> 01:04:03,440
 a goal.

1175
01:04:03,440 --> 01:04:04,440
 Okay.

1176
01:04:04,440 --> 01:04:07,440
 And some will become more efficient than another.

1177
01:04:07,440 --> 01:04:08,440
 Okay.

1178
01:04:08,440 --> 01:04:13,440
 But the major thing for BFS is major disadvantages.

1179
01:04:13,440 --> 01:04:17,440
 You probably, even the answer exists, you probably cannot find it.

1180
01:04:17,440 --> 01:04:25,440
 So, if some branch like that can have a loop, you know, lead you down to the totally run

1181
01:04:25,440 --> 01:04:26,440
 lane.

1182
01:04:26,440 --> 01:04:27,440
 Yeah.

1183
01:04:27,440 --> 01:04:34,440
 So, we have one slide, try to compare these two methods.

1184
01:04:34,440 --> 01:04:35,440
 Okay.

1185
01:04:35,440 --> 01:04:42,440
 So, for BFS, the nice thing is you can find the shortest path and then never track into

1186
01:04:42,440 --> 01:04:44,440
 a particular blind lane, right?

1187
01:04:44,440 --> 01:04:50,440
 So, it won't have that happen because it's level by level.

1188
01:04:50,440 --> 01:04:57,440
 This one, but the major problem with this is very, comes to you much more memory.

1189
01:04:57,440 --> 01:05:01,440
 That is the issue.

1190
01:05:01,440 --> 01:05:10,440
 So, the depth first, actually less memory and it's just, you know, can be mislead.

1191
01:05:10,440 --> 01:05:17,440
 And may not find the answer.

1192
01:05:17,440 --> 01:05:20,440
 Yeah.

1193
01:05:20,440 --> 01:05:30,440
 So, this is just talk about the memory console for BFS.

1194
01:05:30,440 --> 01:05:36,440
 This is talking about the depth first issue.

1195
01:05:37,440 --> 01:05:38,440
 Yeah.

1196
01:05:38,440 --> 01:05:40,440
 Maybe lost in certain branch.

1197
01:05:40,440 --> 01:05:41,440
 Okay.

1198
01:05:41,440 --> 01:05:44,440
 Although memory wise is much better.

1199
01:05:44,440 --> 01:05:48,440
 So, that's why we hope we can combine both.

1200
01:05:48,440 --> 01:05:49,440
 Right.

1201
01:05:49,440 --> 01:05:53,440
 So, that is our number four search algorithm.

1202
01:05:53,440 --> 01:05:54,440
 Okay.

1203
01:05:54,440 --> 01:05:58,440
 Backtracking, then BFS, DFS.

1204
01:05:58,440 --> 01:06:02,440
 Now, we want to combine BFS and DFS together.

1205
01:06:02,440 --> 01:06:05,440
 So, that is iterative deepening.

1206
01:06:05,440 --> 01:06:06,440
 Okay.

1207
01:06:06,440 --> 01:06:11,440
 I iterative deepening and using probably depth first.

1208
01:06:11,440 --> 01:06:14,440
 So, we actually set the depth first.

1209
01:06:14,440 --> 01:06:21,440
 And then within that given depth, we do depth first search.

1210
01:06:21,440 --> 01:06:22,440
 Okay.

1211
01:06:22,440 --> 01:06:23,440
 So, that is one.

1212
01:06:23,440 --> 01:06:31,440
 So, this is firstly, yeah, deep first search in the space with depth spawn of one.

1213
01:06:31,440 --> 01:06:34,440
 And then two and three and like that.

1214
01:06:34,440 --> 01:06:40,440
 But every time you basically have to research, re-inituate, I mean, start the search from

1215
01:06:40,440 --> 01:06:41,440
 beginning.

1216
01:06:41,440 --> 01:06:42,440
 Okay.

1217
01:06:42,440 --> 01:06:43,440
 If you find it, you find it.

1218
01:06:43,440 --> 01:06:52,440
 If you cannot find it, you increase the depth and then you have to do DFS again from that

1219
01:06:52,440 --> 01:06:53,440
 tree.

1220
01:06:53,440 --> 01:06:54,440
 Okay.

1221
01:06:54,440 --> 01:06:59,440
 So, this is, this is, yeah.

1222
01:06:59,440 --> 01:07:02,440
 When you look at this, it's easier to understand.

1223
01:07:02,440 --> 01:07:03,440
 Right?

1224
01:07:03,440 --> 01:07:07,440
 So, this is the iteration one with the depth equal to one.

1225
01:07:07,440 --> 01:07:10,440
 So, you search this way and then this way.

1226
01:07:10,440 --> 01:07:15,440
 And this is increase the depth by two now.

1227
01:07:15,440 --> 01:07:16,440
 So, still go branch.

1228
01:07:16,440 --> 01:07:21,440
 So, you see this is one, two, three, four and then five and six.

1229
01:07:21,440 --> 01:07:23,440
 So, this is how you search.

1230
01:07:23,440 --> 01:07:30,440
 So, if you find it, then good, not, then increase by one and then go four, this way, one, two,

1231
01:07:30,440 --> 01:07:32,440
 three, four, like this, this.

1232
01:07:32,440 --> 01:07:33,440
 Okay.

1233
01:07:33,440 --> 01:07:36,440
 So, depth first with that given tree.

1234
01:07:36,440 --> 01:07:41,440
 So, this is approach.

1235
01:07:41,440 --> 01:07:42,440
 Okay.

1236
01:07:42,440 --> 01:07:52,440
 So, basically hopefully you can combine the advantage of both together from the, you

1237
01:07:53,440 --> 01:07:58,440
 know, the BFS and DFS.

1238
01:07:58,440 --> 01:07:59,440
 Okay.

1239
01:07:59,440 --> 01:08:05,440
 Then exercise four is to go through this.

1240
01:08:05,440 --> 01:08:09,440
 So, you can see this is a graph.

1241
01:08:09,440 --> 01:08:10,440
 Right?

1242
01:08:10,440 --> 01:08:14,440
 It's no arrow given, meaning what?

1243
01:08:14,440 --> 01:08:15,440
 Bidirectional.

1244
01:08:15,440 --> 01:08:16,440
 Yes.

1245
01:08:16,440 --> 01:08:17,440
 It's undirected.

1246
01:08:17,440 --> 01:08:18,440
 Right?

1247
01:08:18,440 --> 01:08:20,440
 So, it's both directions.

1248
01:08:20,439 --> 01:08:21,439
 Okay.

1249
01:08:21,439 --> 01:08:28,439
 So, now I see why the children of the A, B and C.

1250
01:08:28,439 --> 01:08:29,439
 Right?

1251
01:08:29,439 --> 01:08:33,439
 Why the children of the C?

1252
01:08:33,439 --> 01:08:35,439
 A is a children as well.

1253
01:08:35,439 --> 01:08:36,439
 Right?

1254
01:08:36,439 --> 01:08:38,439
 Although you probably no need to put in.

1255
01:08:38,439 --> 01:08:39,439
 Yeah.

1256
01:08:39,439 --> 01:08:40,439
 Depends.

1257
01:08:40,439 --> 01:08:41,439
 Okay.

1258
01:08:41,439 --> 01:08:42,439
 So, both directions.

1259
01:08:42,439 --> 01:08:43,439
 Both directions.

1260
01:08:43,439 --> 01:08:45,439
 That's why it's both ways.

1261
01:08:45,439 --> 01:08:46,439
 Okay.

1262
01:08:46,439 --> 01:08:55,439
 So, can we do this using the BFS, DFS, starting from A and then the goal is G?

1263
01:08:55,439 --> 01:08:56,439
 Okay.

1264
01:08:56,439 --> 01:08:59,439
 Shall we do it now?

1265
01:08:59,439 --> 01:09:04,439
 We check the answer.

1266
01:09:04,439 --> 01:09:05,439
 It's an easy one.

1267
01:09:05,439 --> 01:09:06,439
 Right?

1268
01:09:06,439 --> 01:09:07,439
 Easy one.

1269
01:09:07,439 --> 01:09:08,439
 Okay.

1270
01:09:37,439 --> 01:09:39,439
 Okay.

1271
01:09:39,439 --> 01:09:41,439
 Okay.

1272
01:09:41,439 --> 01:09:43,439
 Okay.

1273
01:09:43,439 --> 01:09:44,439
 Okay.

1274
01:09:44,439 --> 01:09:45,439
 Okay.

1275
01:09:45,439 --> 01:09:46,439
 Okay.

1276
01:09:46,439 --> 01:09:47,439
 Okay.

1277
01:09:47,439 --> 01:09:48,439
 Okay.

1278
01:09:48,439 --> 01:09:49,439
 Okay.

1279
01:09:49,439 --> 01:09:50,439
 Okay.

1280
01:09:50,439 --> 01:09:51,439
 Okay.

1281
01:09:51,439 --> 01:09:52,439
 Okay.

1282
01:09:52,439 --> 01:09:53,439
 Okay.

1283
01:09:53,439 --> 01:09:54,440
 Okay.

1284
01:09:54,440 --> 01:09:55,440
 Okay.

1285
01:09:55,440 --> 01:09:56,440
 Okay.

1286
01:09:56,440 --> 01:09:57,440
 Okay.

1287
01:09:57,440 --> 01:09:58,440
 Okay.

1288
01:09:58,440 --> 01:09:59,440
 Okay.

1289
01:09:59,440 --> 01:10:00,440
 Okay.

1290
01:10:00,440 --> 01:10:01,440
 Okay.

1291
01:10:01,440 --> 01:10:02,440
 Okay.

1292
01:10:02,440 --> 01:10:03,440
 Okay.

1293
01:10:03,440 --> 01:10:04,440
 Okay.

1294
01:10:04,440 --> 01:10:05,440
 Okay.

1295
01:10:05,440 --> 01:10:06,440
 Okay.

1296
01:10:06,440 --> 01:10:07,440
 Okay.

1297
01:10:07,440 --> 01:10:08,440
 Okay.

1298
01:10:08,440 --> 01:10:09,440
 Okay.

1299
01:10:09,440 --> 01:10:10,440
 Okay.

1300
01:10:10,440 --> 01:10:11,440
 Okay.

1301
01:10:11,440 --> 01:10:12,440
 Okay.

1302
01:10:12,440 --> 01:10:13,440
 Okay.

1303
01:10:13,440 --> 01:10:14,440
 Okay.

1304
01:10:14,440 --> 01:10:15,440
 Okay.

1305
01:10:15,440 --> 01:10:16,440
 Okay.

1306
01:10:16,440 --> 01:10:17,440
 Okay.

1307
01:10:17,440 --> 01:10:18,440
 Okay.

1308
01:10:18,440 --> 01:10:19,440
 Okay.

1309
01:10:19,440 --> 01:10:20,440
 Okay.

1310
01:10:20,440 --> 01:10:21,440
 Okay.

1311
01:10:21,440 --> 01:10:22,440
 Okay.

1312
01:10:22,440 --> 01:10:23,440
 Okay.

1313
01:10:23,440 --> 01:10:24,440
 Okay.

1314
01:10:24,440 --> 01:10:25,440
 Okay.

1315
01:10:25,440 --> 01:10:26,440
 Okay.

1316
01:10:26,440 --> 01:10:27,440
 Okay.

1317
01:10:27,440 --> 01:10:28,440
 Okay.

1318
01:10:28,440 --> 01:10:29,440
 Okay.

1319
01:10:29,440 --> 01:10:30,440
 Okay.

1320
01:10:30,440 --> 01:10:31,440
 Okay.

1321
01:10:31,440 --> 01:10:32,440
 Okay.

1322
01:10:32,440 --> 01:10:33,440
 Okay.

1323
01:10:33,440 --> 01:10:34,440
 Okay.

1324
01:10:34,440 --> 01:10:35,440
 Okay.

1325
01:10:35,440 --> 01:10:36,440
 Okay.

1326
01:11:05,440 --> 01:11:06,440
 Okay.

1327
01:11:35,440 --> 01:11:36,440
 Okay.

1328
01:12:05,440 --> 01:12:06,440
 Okay.

1329
01:12:35,440 --> 01:12:36,440
 Okay.

1330
01:13:05,440 --> 01:13:06,440
 Okay.

1331
01:13:35,440 --> 01:13:36,440
 Okay.

1332
01:14:05,440 --> 01:14:06,440
 Okay.

1333
01:14:35,440 --> 01:14:36,440
 Okay.

1334
01:15:05,440 --> 01:15:06,440
 Okay.

1335
01:15:35,440 --> 01:15:36,440
 Okay.

1336
01:16:05,440 --> 01:16:06,440
 Okay.

1337
01:16:35,440 --> 01:16:36,440
 Okay.

1338
01:17:05,440 --> 01:17:06,440
 Okay.

1339
01:17:35,440 --> 01:17:36,440
 Okay.

1340
01:18:05,440 --> 01:18:09,639
 Okay.

1341
01:18:09,639 --> 01:18:15,940
 Should we continue our discussion?

1342
01:18:15,940 --> 01:18:17,360
 Okay.

1343
01:18:17,360 --> 01:18:19,360
 You have tried, right?

1344
01:18:19,360 --> 01:18:26,480
 So the best way, I can see some of you actually based on this graph and try to draw the tree.

1345
01:18:26,480 --> 01:18:27,480
 Right?

1346
01:18:27,480 --> 01:18:32,139
 So you try to actually draw a tree and then based on a tree, you want to do the level

1347
01:18:32,140 --> 01:18:41,340
 by level, okay, or the branch by branch. But the best way probably is just to write, follow

1348
01:18:41,340 --> 01:18:49,740
 the algorithm. Okay, so you just have the open list and close list. So if it's a BFS,

1349
01:18:49,740 --> 01:18:56,860
 you go for the, you are forming, you're adding the things from the right. Okay, so that means

1350
01:18:56,860 --> 01:19:05,900
 actually it's forming a queue. If it's a DFS, you're forming a stack. Okay, so that is a

1351
01:19:05,900 --> 01:19:13,580
 key thing. No need to take picture. I will update the exercise answer and the exercise,

1352
01:19:13,580 --> 01:19:21,460
 the example answer, exercise answer, I think will be available tomorrow around noon time.

1353
01:19:21,460 --> 01:19:27,140
 Okay, after the full-time students finish their class. So those slides is already in

1354
01:19:27,140 --> 01:19:34,900
 NTU learn. So no need to take picture. Okay, so we are starting from here and suppose G is a goal.

1355
01:19:35,700 --> 01:19:41,780
 So this is a BFS we are talking about. So remember keywords is a queue. Okay, so the queue, forming

1356
01:19:41,780 --> 01:19:49,460
 a queue, forming a queue, queue for the open list. Okay, open list. So starting from A and then initially

1357
01:19:49,460 --> 01:19:56,740
 the closed list is empty. And then we check whether A is a goal is not yet. So we add in the children

1358
01:19:56,740 --> 01:20:06,980
 of the A into the open to form the queue. So children of the A, that is a B and C. Then anyone

1359
01:20:06,980 --> 01:20:15,780
 want to ask something here? Why I put, because the sequence of this is also important, right?

1360
01:20:16,420 --> 01:20:23,219
 It's forming a queue. So forming a queue, why not same level, right? Why not C and B?

1361
01:20:26,660 --> 01:20:34,740
 Yeah, so, but it's a, I mean, level by level. So same level. So why this way, not this way.

1362
01:20:34,740 --> 01:20:42,500
 Okay, that is really hard. That's why you probably don't have a unique answer. Right? Yeah, why not

1363
01:20:42,500 --> 01:20:49,380
 some of you probably put the C and the B. Then I will examine C first rather than B. Right?

1364
01:20:50,020 --> 01:20:57,380
 Yeah, so actually I didn't make it very clear for this exercise. We should say for the children,

1365
01:20:57,940 --> 01:21:06,500
 probably I want to go for alphabetical order. Then it's a unique answer. Otherwise, all correct.

1366
01:21:07,060 --> 01:21:14,500
 All correct. Yeah, so this is just one of the possible answer. It's not the only answer. Okay,

1367
01:21:14,500 --> 01:21:22,660
 so I'm putting the B in front of C, the two both children. I go for alphabetical order. Then the

1368
01:21:22,660 --> 01:21:29,380
 B in front of C. And then similarly, after checking B, the children of the B, which is D F, I sorted

1369
01:21:29,380 --> 01:21:37,780
 again, you know, alphabetical order. That's why D F H. Okay, so I think that is the only thing I need

1370
01:21:37,780 --> 01:21:49,540
 to say about this. So similarly, if you draw the tree, then also how you, you know, which branch

1371
01:21:49,540 --> 01:21:59,860
 you put in slightly different. Okay, D F and then check C, C, add in this and so on, so on, so on.

1372
01:22:00,420 --> 01:22:10,580
 Okay, any question? So it's just a bit serious. Otherwise, it's okay. Right? And then only question

1373
01:22:10,580 --> 01:22:17,620
 you can ask is about this. But they are all children. So how, which children go first? Okay,

1374
01:22:17,700 --> 01:22:24,500
 so it's the same level, but then which one you want to check first? So suppose we go alphabetical

1375
01:22:24,500 --> 01:22:32,820
 order. Okay, but in the actual scenario, probably that is something they have normally this is not

1376
01:22:32,820 --> 01:22:39,220
 totally exhausted search. Okay, normally if it's a game tree, then normally come with a heuristic

1377
01:22:39,220 --> 01:22:45,540
 value or hint, okay, which one give you a higher priority. So then you follow that or something.

1378
01:22:46,420 --> 01:22:49,780
 Okay, anything else?

1379
01:22:53,540 --> 01:23:00,740
 Similarly, yeah, so this is a BFS. Then what about DFS? Same graph, DFS.

1380
01:23:02,740 --> 01:23:09,540
 So same thing here, similar here, then after that, then when you check the B,

1381
01:23:10,260 --> 01:23:21,780
 you also have D F H, right? But D F H adding where? It's not adding from the right hand side.

1382
01:23:22,500 --> 01:23:29,060
 It should add in from left hand side. That is the only thing. Right? Yeah, so this is the one.

1383
01:23:29,780 --> 01:23:38,900
 See, left hand side, left hand side. Okay, so we are adding from the whole,

1384
01:23:39,780 --> 01:23:44,900
 the whole open list, actually is a stack. Okay, so we should add in from the left.

1385
01:23:51,380 --> 01:23:52,900
 Any questions?

1386
01:23:59,300 --> 01:24:06,820
 So the keywords is here, left hand, left hand, left hand of the open list.

1387
01:24:07,620 --> 01:24:14,900
 And then also the sequence probably alphabetical order. So then I put it this way. Okay.

1388
01:24:15,139 --> 01:24:17,139
 Okay.

1389
01:24:27,940 --> 01:24:35,620
 So for this case, it looks like DFS is faster. Seven steps to find it. This one take longer,

1390
01:24:35,620 --> 01:24:41,139
 slightly longer. Right. Okay, anything else?

1391
01:24:45,700 --> 01:24:54,259
 Okay. How to do this using the iterative, the deepening method? You can try.

1392
01:24:57,620 --> 01:25:04,740
 Okay. So that is just a concept. Okay. So that's all about the lecture five. Basically,

1393
01:25:05,540 --> 01:25:12,019
 we finish off the topic two. So we cover the exhaustive search. Okay. So we introduce the

1394
01:25:12,740 --> 01:25:23,540
 backtracking and then the BFS, DFS and also the iterative. Okay. And then for the topic two,

1395
01:25:23,540 --> 01:25:28,980
 in the beginning, we talk about representation. And then that's why today we start to talk about

1396
01:25:28,980 --> 01:25:39,940
 search algorithms. Okay. Then one thing left is about the discussion for the exercise two,

1397
01:25:40,500 --> 01:25:46,019
 which is about data driven or goal driven. Right. For the play the goal game.

1398
01:25:47,219 --> 01:25:50,820
 Go game. Okay. Go game. Should be data driven or goal driven?

1399
01:25:54,660 --> 01:25:55,219
 Go driven?

1400
01:25:58,660 --> 01:26:01,540
 Data driven. Okay. How do you decide based on what?

1401
01:26:01,860 --> 01:26:13,460
 Visibility or finding the answer. Right. We are talking about searching on the same space.

1402
01:26:14,260 --> 01:26:20,580
 Is to check forward or backwards. Which one the actual search space is smaller?

1403
01:26:21,460 --> 01:26:30,019
 Yeah. So like what I said before, John and Tom and John relationship. Right. So

1404
01:26:30,820 --> 01:26:36,660
 the to check whether John is a, which one? Tom is a great, great, great parents of the John.

1405
01:26:36,660 --> 01:26:42,100
 Right. So you, which one data driven or goal driven? Depend which direction give you a smaller

1406
01:26:42,100 --> 01:26:50,340
 or bigger tree. That's all. Okay. So if it's a play goal, if it's a goal driven, what will happen?

1407
01:26:50,980 --> 01:26:59,780
 Remember the, for goal, actually the branch factor is 250. Yeah. So that's why I guess you

1408
01:26:59,780 --> 01:27:07,140
 probably want to say you want to go for goal driven, but this way the branch factor, I don't know

1409
01:27:07,140 --> 01:27:13,220
 what is the value. I mean the front finding the goal states is also very challenging.

1410
01:27:14,100 --> 01:27:20,980
 Many, many, many possible goal states. Right. And then after you find one, then you find the

1411
01:27:23,380 --> 01:27:30,420
 states lead to these goal states also many, many, many possible possibilities. Right.

1412
01:27:31,460 --> 01:27:38,420
 That is a goal driven. But if it's data driven, although it looks like a branch factor is 250,

1413
01:27:38,420 --> 01:27:45,460
 but in actual play, that's no way you do that way. Okay. So that means actually the skill player

1414
01:27:45,460 --> 01:27:53,300
 probably, I mean, those champion, they probably only estimate about between 10 to 20, up to 20

1415
01:27:53,300 --> 01:28:02,260
 possible branches. Okay. And then probably also look ahead a few steps. So you, for each branch,

1416
01:28:02,260 --> 01:28:08,900
 you probably look at likely how your opponent would play. And then you look ahead a few steps.

1417
01:28:08,900 --> 01:28:13,620
 And then based on that, you search. So data driven seems not feasible.

1418
01:28:16,500 --> 01:28:24,580
 Okay. So basically, okay, principle is you see data driven, what is, you know, tree size. And then

1419
01:28:25,220 --> 01:28:30,500
 goal driven, what is the tree size? Which one is smaller? Then take that. Most likely in the

1420
01:28:30,500 --> 01:28:38,900
 real world situation, you probably go hybrid, you meet in the middle. Okay. Yeah. Then diagnosis,

1421
01:28:39,460 --> 01:28:48,740
 for expert diagnosis, like COVID, you know, or you actually have many data, which is to help us

1422
01:28:48,740 --> 01:28:55,620
 to diagnosis particular disease. Right. So which way we go? Go driven or data driven?

1423
01:28:56,180 --> 01:29:07,300
 Huh? Data driven as well? Okay. So suppose we have all the symptoms like running nose,

1424
01:29:07,300 --> 01:29:14,500
 high temperature, you know, coughing. Those are data, right? Those are the data. And then based

1425
01:29:14,500 --> 01:29:23,620
 on this data, we try to find what disease. Yeah. So do you think doctor will do like this?

1426
01:29:24,580 --> 01:29:31,380
 Totally data driven? Or actually they look at your symptoms, they already assume particular disease.

1427
01:29:32,099 --> 01:29:40,820
 And then they go this way to get the supporting evidence. Most likely they assume like, okay,

1428
01:29:40,820 --> 01:29:47,700
 this is flu or this is COVID. And then if it's COVID and those data support or not, if not,

1429
01:29:48,420 --> 01:29:53,540
 then you probably give up this goal. You find another goal. So likely it's this way.

1430
01:29:54,260 --> 01:30:00,099
 Or actually it's a hybrid. Okay. So it doesn't matter. I mean, you can have a different way,

1431
01:30:00,099 --> 01:30:06,340
 as long as you can justify well. You think, you know, which tree, which direction is smaller.

1432
01:30:06,900 --> 01:30:15,380
 Yeah. Although in the same search space. Okay. Yeah. So no standard answer, but in a way,

1433
01:30:15,380 --> 01:30:24,660
 the principle is this. Okay. So that is lecture five. And we move on to the last topic we want

1434
01:30:24,660 --> 01:30:32,340
 to discuss today. Okay. So that is we move to the first section in the topic tree, which is about

1435
01:30:32,340 --> 01:30:39,700
 heuristic search and gaming. So part A is more about heuristic search. Part B is particularly

1436
01:30:39,700 --> 01:30:47,620
 talking about the algorithms for gaming. Okay. So you can see so far that exhausted search,

1437
01:30:47,620 --> 01:30:53,139
 basically we don't have any hints. So we only have the search space and we want to systematically

1438
01:30:53,139 --> 01:31:01,220
 finding the answer. Right. So that is the algorithm we learned. But what if actually that is some

1439
01:31:01,220 --> 01:31:09,380
 hints or that is some experience plus effort and then actually can help us to give us an

1440
01:31:09,380 --> 01:31:15,940
 evaluation function. And this evaluation function actually can lead us to, you know, quickly find

1441
01:31:15,940 --> 01:31:22,500
 answer. So that would be better. Right. So that is hopefully we can actually improve the performance.

1442
01:31:22,500 --> 01:31:29,860
 Because we know when the tree or the search space become very big, systematically search for answer

1443
01:31:29,860 --> 01:31:36,580
 become not feasible. And then we need to rely on the hint. Right. The hint. So normally the hint

1444
01:31:36,580 --> 01:31:43,059
 is come with, you know, the skills. People very skillful in this area. And then they can come up

1445
01:31:43,059 --> 01:31:49,219
 with, they'll know some part probably is really like a pattern recognition, you know, because like

1446
01:31:49,219 --> 01:31:54,420
 those goal player, you really don't know how they find it. They probably not really can write the rule

1447
01:31:54,420 --> 01:32:01,380
 to tell you how exactly they find answer. They just look at the board situation. They probably can

1448
01:32:01,940 --> 01:32:09,460
 kind of predict, you know, have a, have a, have a way to judge which, what they should do. So that

1449
01:32:09,460 --> 01:32:16,900
 is kind of pattern recognition. Not if that is any way which is can use an equation or something

1450
01:32:16,900 --> 01:32:22,660
 which can get the figure for you. Okay. Then actually we can come with make use of this to

1451
01:32:23,460 --> 01:32:30,500
 have every state you can actually estimate what is how likely this will lead to the success or

1452
01:32:30,500 --> 01:32:37,300
 lead to the goal. Then we should apply this heuristics. Okay. So this is what we are talking

1453
01:32:37,300 --> 01:32:43,780
 about. So what is this about? And then how to design the heuristic value? Okay. So this is,

1454
01:32:44,420 --> 01:32:49,540
 cannot answer this question actually. The heuristic value, these things, the design of this is not

1455
01:32:49,540 --> 01:32:56,740
 like applicable for all the problems. It's very much problem driven. Okay. So it's goal, you

1456
01:32:56,740 --> 01:33:02,019
 play goal for example, you need to find what's the best way to come out with a heuristic. If you

1457
01:33:02,019 --> 01:33:08,500
 play chess, that's another way to do it. Okay. So it's very different. And then so we can only say

1458
01:33:08,500 --> 01:33:16,900
 the some guideline. And then it's not enough just to have the heuristic value. Okay. Even you have

1459
01:33:16,900 --> 01:33:21,940
 the value, but you don't have a right way to search for the answer is also will not lead to the

1460
01:33:22,580 --> 01:33:28,660
 successful finding the goal. So search algorithm is still important. So we are going to talk about

1461
01:33:28,660 --> 01:33:37,860
 hill climbing and their best first or greedy best first or the optimistic one, which is, you know,

1462
01:33:37,860 --> 01:33:45,940
 finding optimal answer, which is a star. So here I will say something more about this later. Okay.

1463
01:33:45,940 --> 01:33:50,419
 And then we talk about how to apply the heuristics in the gaming.

1464
01:33:52,419 --> 01:33:58,099
 Okay. So first part is without talking about game. Okay. We just talk about in general how the

1465
01:33:58,099 --> 01:34:05,700
 heuristic search can apply and what are the search algorithms we are covering. Okay. So basically

1466
01:34:05,700 --> 01:34:11,379
 this is talking about the strategy. I'm still talking about the search strategy. So before we

1467
01:34:11,460 --> 01:34:17,860
 talk about exhaustive search, right? We actually uninformed and then systematically search that

1468
01:34:17,860 --> 01:34:25,060
 is so-called this blind search. Okay. So it's uninformed. And now we talk about informed. So we

1469
01:34:25,060 --> 01:34:32,260
 know some hints. Okay. We can make use of the hints to search for answer. So that is under the strategy.

1470
01:34:32,260 --> 01:34:38,900
 So there are a few things. Yeah. I showed these slides before is to talk about this search,

1471
01:34:38,900 --> 01:34:47,219
 whether it's completeness. So if the answer exists, can we find it? Okay. So just now we say, for

1472
01:34:47,219 --> 01:34:54,900
 example, the DFS cannot find, it's not complete. Okay. It's not complete. It's not satisfied

1473
01:34:54,900 --> 01:35:01,219
 completeness because the answer can exist there, but it's in the branch and then you have one branch

1474
01:35:01,219 --> 01:35:08,339
 which is deep down. There is no way you come out. It's trapped inside. So you cannot find the answer.

1475
01:35:08,980 --> 01:35:15,700
 But the BFS probably is another issue is space complexity. Okay. Yeah. So these are the few

1476
01:35:15,700 --> 01:35:24,340
 things in time and then optimal solution that is BFS can achieve, but DFS probably cannot. Okay.

1477
01:35:25,940 --> 01:35:33,300
 Then a few things like related to the branch factor, related to the depth and relate to the

1478
01:35:33,300 --> 01:35:41,460
 maximum space you have. Okay. And then, so these are the important things. So this is more for your

1479
01:35:41,460 --> 01:35:48,580
 information only. Okay. I don't expect you to totally remember this or to fully justify this,

1480
01:35:48,580 --> 01:35:56,100
 but it's good to know. Okay. So this is BFS, DFS, and then the combination of these two. So you

1481
01:35:56,100 --> 01:36:05,220
 can see that this is depth. For DFS, it's not complete. Right. You cannot find the answer,

1482
01:36:05,220 --> 01:36:11,700
 even the solution exists. Also cannot find the optimal solution. Yeah. So this is a major thing.

1483
01:36:11,700 --> 01:36:20,500
 But for BFS, this is a space and time that's a main issue. Okay. And so let's start to introduce

1484
01:36:20,580 --> 01:36:28,900
 heretics. So this word itself basically indicates, you know, personal discovery of something,

1485
01:36:29,460 --> 01:36:37,860
 experience. Okay. So we actually hopefully, the noun here tell us is use experience and practical

1486
01:36:37,860 --> 01:36:43,620
 efforts to find answer to questions or improve the performance. Right. Give us a hint. Give us a

1487
01:36:43,700 --> 01:36:50,500
 hint. Yeah. So is this space search, this is formulated as a rules? So it's likely,

1488
01:36:51,700 --> 01:36:57,940
 hopefully, can give us a lead to the answer, which is acceptable answer. Okay. May not be the

1489
01:36:57,940 --> 01:37:05,700
 optimal. So sometimes finding sub-automome is already happy. We are already happy enough. Okay. So

1490
01:37:05,700 --> 01:37:15,860
 that is using the heuristic help us to do. So why, yeah, basically is because not feasible

1491
01:37:15,860 --> 01:37:23,460
 if we don't have it. Totally rely on the system as such. Probably kid cannot give us answer at all.

1492
01:37:23,460 --> 01:37:30,340
 Okay. Within a given time and space. So that's why we have to rely on this. Also, so hopefully,

1493
01:37:30,340 --> 01:37:38,660
 this will guide us to search along the more promising space. Okay. So space. Yeah. So we

1494
01:37:38,660 --> 01:37:44,580
 can quickly eliminate those states, which is definitely not worth to explore. Okay. So that is

1495
01:37:44,580 --> 01:37:51,620
 a key thing. So hopefully it can be applied to defeat those, you know, relate any question related

1496
01:37:51,620 --> 01:37:59,780
 constraints, actually problem. We can actually find some answer. And then, yeah. So, so this is

1497
01:37:59,780 --> 01:38:06,099
 talking about, you know, go and the chest, those have very large brand, very, very factors. So we

1498
01:38:06,099 --> 01:38:13,540
 have to have a hint in order to use it. Limitation, of course, because this is based on human experience

1499
01:38:13,540 --> 01:38:20,820
 and also their skills really depends. So that's why it's valuable. Okay. It's not,

1500
01:38:20,820 --> 01:38:27,059
 cannot prove it's definitely true. Definitely work all the time. And also very likely when we

1501
01:38:27,059 --> 01:38:32,660
 work out the heuristic value is based on our limited information. Okay. So for example, when you

1502
01:38:32,660 --> 01:38:38,580
 calculate the H value, you probably only look ahead a few steps. And then based on that information,

1503
01:38:38,580 --> 01:38:43,940
 you work out the hints. Okay. So it's partial information. So it's not like it's a local

1504
01:38:43,940 --> 01:38:49,620
 information. It's not like a global information available. So that is how actually practically

1505
01:38:50,260 --> 01:38:56,019
 how like a chess player, for example, how they estimate the value, right? Yeah. So this is limited

1506
01:38:56,019 --> 01:39:02,820
 information. That's why definitely valuable. Sometimes doesn't work. Okay. So cannot guarantee. So

1507
01:39:02,820 --> 01:39:10,180
 it's also, it's cannot eliminate those, you know, guarantee which one is better than the other one.

1508
01:39:10,260 --> 01:39:14,500
 And for all the situations, it works everywhere. No.

1509
01:39:17,620 --> 01:39:24,500
 So that's why for heuristic search, two things. One is the measurement. Another one is the search

1510
01:39:24,500 --> 01:39:31,140
 algorithm. Okay. So still search algorithm is important. So make use of the rules to get the

1511
01:39:31,140 --> 01:39:37,460
 acceptable solutions, combine the heuristic value we have, the measurements we have,

1512
01:39:37,460 --> 01:39:45,780
 and then the search algorithm we follow. Okay. Okay. Then we take a look of the tic-tac-toe again.

1513
01:39:48,100 --> 01:39:55,700
 So what is likely we can have each value, okay? Heuristic value. So that's why let's take a look

1514
01:39:55,700 --> 01:40:01,700
 starting. And then suppose cross player and the circle player. So cross player, you have three

1515
01:40:01,700 --> 01:40:07,139
 places to put. Actually, it's nine places to put. But we summarize one is the left corner,

1516
01:40:07,139 --> 01:40:12,900
 one is in the middle, oh, sorry. One is the corners. Okay. So four corners. Another one is in the

1517
01:40:12,900 --> 01:40:19,220
 middle, very center point. And then another one is in the middle of the row or columns. Okay. So

1518
01:40:19,220 --> 01:40:26,420
 total nine. But we just show three of it to be the representative. Okay. Then after you have this

1519
01:40:26,420 --> 01:40:32,420
 cross and then the circle player come into play. So suppose the circle player put in again in the

1520
01:40:32,420 --> 01:40:42,420
 middle or in the corner or in the, you know, the place you can have, you can place the circle.

1521
01:40:42,420 --> 01:40:49,380
 Okay. So this is the one. And this is the level is considered as a how many levels? Yeah. Maybe

1522
01:40:49,380 --> 01:40:57,860
 just one level. If it's just zero, then one and two. And then you can decide where to put

1523
01:40:57,860 --> 01:41:06,180
 for the cross. Okay. Cross player. So you can see, okay, if you already placed the cross in this

1524
01:41:06,180 --> 01:41:17,460
 location, then the chunks are winning. It can come from this row or this column or in the diagonal.

1525
01:41:18,100 --> 01:41:25,300
 Right. So you can say the h value equal to three. If this is counting of the possible winning

1526
01:41:25,860 --> 01:41:33,220
 based on the current location. Okay. So if you put here, then what is the h value here?

1527
01:41:34,500 --> 01:41:41,940
 Yeah. So one, two, three, four. Right. So this is, yeah, what about this one? Only two.

1528
01:41:42,900 --> 01:41:51,059
 Okay. So if you want to win, where should you, you should put? Yeah. You should try to put in the

1529
01:41:51,059 --> 01:42:00,019
 middle. Right. Yeah. So this is the one. So we are using this most win heuristic, you know,

1530
01:42:00,019 --> 01:42:06,259
 for the first children and try to estimate together h value and then guide you to see

1531
01:42:06,260 --> 01:42:14,900
 where to put. And then after you put, that is your opponent's turn to put next. Then after that,

1532
01:42:14,900 --> 01:42:20,500
 you also decide how are you going next, what's your next movement. Okay. Again, you can,

1533
01:42:20,500 --> 01:42:28,100
 based on your opponent's location, then you check what is next, where can I put. So this is a practice.

1534
01:42:28,100 --> 01:42:34,180
 Yeah. So suppose this opponent put here. Okay. Then where should we put?

1535
01:42:35,860 --> 01:42:42,180
 You can try. Okay. If I put here, yeah. You assume in the beginning you put in the center.

1536
01:42:42,180 --> 01:42:48,980
 Right. So your opponent put this position. So then you decide if you put here, what's the h value?

1537
01:42:48,980 --> 01:42:57,060
 If you put here, what's your h value? What if you put here? Okay. So you can count the h value,

1538
01:42:57,060 --> 01:43:06,260
 how many times likely we will win. Then you pick the highest. Right. So this is a hint for us to

1539
01:43:06,260 --> 01:43:12,580
 see, okay, how likely you can win. Now, of course, you, this h value indicates how fit you are,

1540
01:43:12,580 --> 01:43:19,860
 a fit. So we say the h value can be a fitness or can be a cost. So if it's a cost, of course,

1541
01:43:19,860 --> 01:43:24,980
 you want to cost as low as possible. If it's a fitness, you want to fitness as high as possible.

1542
01:43:24,980 --> 01:43:35,299
 Right. So that is the idea. Okay. Yeah. So this is what exactly we had. So here we talk about

1543
01:43:35,299 --> 01:43:41,219
 fitness. So for this one, actually fitness is three because one, two, three. Right. So this is

1544
01:43:41,219 --> 01:43:48,179
 four, this is two. So opponent put here, then you are here, then you have those options. So this

1545
01:43:48,179 --> 01:43:54,259
 one give you three, and this one give you five. So of course, you should try to put in this location.

1546
01:43:54,260 --> 01:44:02,020
 This is h equal to five, highest h value. So if your opponent put in this, in this occasion,

1547
01:44:02,020 --> 01:44:06,660
 but if your opponent put here, then you should evaluate accordingly. And then you probably want

1548
01:44:06,660 --> 01:44:15,300
 to pick this one. Okay. So this is the, how the h come into play. Okay. So this is h value.

1549
01:44:18,500 --> 01:44:23,940
 Can I can only use some very simple questions to tell us how actually you can design your h.

1550
01:44:24,340 --> 01:44:30,820
 But since h is linked to the experience and skills, definitely is a programmer

1551
01:44:32,340 --> 01:44:39,460
 need to decide how to design it. Okay. And it's problem based. This cannot be very general rules

1552
01:44:39,460 --> 01:44:45,700
 to be applied. So after you have the h, then of course, just now we see, based on h value,

1553
01:44:45,700 --> 01:44:51,780
 you should pick the maximum one for fitness and pick the lowest one for h. And is this the only

1554
01:44:51,780 --> 01:44:57,860
 way to find the answer? Because next step is still depends on your opponent, how to move.

1555
01:44:57,860 --> 01:45:05,780
 And then you act. Right. So is this always just to find the best only or you should have a say

1556
01:45:06,420 --> 01:45:14,660
 search based on the best first. Okay. So it's like, you see the difference best only and best

1557
01:45:14,660 --> 01:45:23,220
 first. This is different concept. If best only, you only keep the best one, the rest you ignore.

1558
01:45:23,220 --> 01:45:29,460
 Okay. And then you probably stuck somewhere. You cannot find the answer. But if it's a best first,

1559
01:45:30,180 --> 01:45:36,740
 you still have second. Okay. You can go best first and then you can still backtrack. If it

1560
01:45:36,740 --> 01:45:42,099
 doesn't work, you can still kind of backtrack or you still have a backup. You still have backup

1561
01:45:42,100 --> 01:45:48,500
 pool. Then you choose second best, for example. Okay. So it's different. That's why we talk about

1562
01:45:48,500 --> 01:45:56,660
 algorithm now. Okay. So this is a heuristic based search algorithm. So suppose we go for the best

1563
01:45:56,660 --> 01:46:04,820
 only. Okay. So he'll climbing. So you always climb the taller, you think is the best one. Okay.

1564
01:46:05,460 --> 01:46:13,540
 And then like clay, like for example here. So suppose you're in this kind of location and then

1565
01:46:13,540 --> 01:46:21,299
 you find the, I don't know. Okay. You probably, you're here and then you can kind of find the best

1566
01:46:21,299 --> 01:46:28,019
 or you are somewhere, somewhere here. Then you find this one is the best. You know, depends on

1567
01:46:28,020 --> 01:46:36,180
 local situation. And then actually best children is like for further expansion and you don't keep

1568
01:46:36,180 --> 01:46:43,300
 any information for the siblings. Okay. So it's all up and then this is kind of greedy approach. And

1569
01:46:43,300 --> 01:46:50,500
 you will find it won't work. Okay. So this is a limitation. So you can actually end up with

1570
01:46:50,500 --> 01:46:59,060
 error and stuck in some local minimal. So a more informed algorithm will be, you know,

1571
01:46:59,060 --> 01:47:06,260
 using the best first instead of best only. Okay. So don't go for best only. That's too ideal.

1572
01:47:06,260 --> 01:47:13,380
 So go for best first. You still have second, you still have a second chance. Okay. And then

1573
01:47:13,380 --> 01:47:18,820
 other thing we'd like to highlight is a fitness and causes. So remember if you are each function is

1574
01:47:19,059 --> 01:47:24,179
 fitness, then you go for highest and then your best will be the highest value and you still

1575
01:47:24,179 --> 01:47:30,740
 have a second best and so on. And then if it's a cost, then the lowest cost is the best one. Okay.

1576
01:47:30,740 --> 01:47:40,980
 So this is the idea. Okay. So let's see for this one we want to look at whether the best only,

1577
01:47:40,980 --> 01:47:48,500
 that means he'll climbing is this one working or not. So convince you. So we attach with a value,

1578
01:47:48,500 --> 01:47:54,660
 don't ask me how the value we got it, but suppose this is a cost. Okay. So here the H is a cost.

1579
01:47:54,660 --> 01:48:02,980
 So a have a cost of five, B have cost of four and so on. So suppose I go for best only. Okay.

1580
01:48:02,980 --> 01:48:10,740
 Best only. So this is equal. I probably randomly select this one. Okay. So I select the B and

1581
01:48:10,740 --> 01:48:17,220
 select the B. All those will be throw away. You have, you don't have the information anymore.

1582
01:48:17,220 --> 01:48:25,300
 So I come to here and then I'm stuck here. Right. Because you expanded, you find the cost

1583
01:48:25,300 --> 01:48:32,420
 value is higher. So you cannot feel climbing up. So I mean climbing is for best value. Okay. But

1584
01:48:32,420 --> 01:48:38,340
 it's for the cost that means you actually go the best is, you know, lowest value. So the lowest

1585
01:48:38,420 --> 01:48:47,860
 value here, this is higher. So I should stop here. I'm not finding the answer. Okay. So this is

1586
01:48:47,860 --> 01:48:56,180
 talking about if I go the B. So if randomly I pick the C looks like I'm lucky I come here.

1587
01:48:56,180 --> 01:49:05,780
 And then this is a fall. And then I expanded these two branches. And so this is lower. Right. So that

1588
01:49:05,780 --> 01:49:14,420
 means this is better. So I can move to this. I move to this and then expanded again. I will end up

1589
01:49:14,420 --> 01:49:28,900
 where? Best only. I will end up here. Do we find the answer? No. Not. That is a consequence.

1590
01:49:28,900 --> 01:49:34,019
 Okay. So you can see although you have the each value, suppose each value is very correct,

1591
01:49:34,020 --> 01:49:40,500
 but your strategy is wrong. Okay. You are using the hill climbing or the best only approach

1592
01:49:41,540 --> 01:49:49,540
 that will not help you to find the answer. Okay. What if you are using best first?

1593
01:49:50,820 --> 01:49:57,780
 Best first, but not only very best first. So this is the same thing. Okay. So we have

1594
01:49:57,780 --> 01:50:07,540
 starting from A and then you have the children. And then you find the best. So best is D. So the D

1595
01:50:07,540 --> 01:50:14,259
 will be expanded. The children of the B will be evaluated. You get each value. Actually those are

1596
01:50:14,259 --> 01:50:21,460
 all still kept. Okay. So those are kept. So all the siblings are still kept. So those are still

1597
01:50:21,460 --> 01:50:30,820
 in your open list. Okay. So still there. And then when this expanded, then what do you do? You look

1598
01:50:30,820 --> 01:50:42,500
 at all the possible descendants. Okay. So you look at all of them. So can cross generation. Okay. So

1599
01:50:42,500 --> 01:50:50,820
 that means B, C, E, F will have the same equal chance to be examined. And then see which one I

1600
01:50:50,820 --> 01:50:59,700
 should expand next or search next. Okay. So yeah. So when you come to the D, after you expand it,

1601
01:50:59,700 --> 01:51:09,620
 now which one you should go? Those lowest. Right. If the F is, yeah, F is a cost. So lowest. So I

1602
01:51:09,700 --> 01:51:19,300
 should go B, right? Yeah. So the B that is expanded. Okay. So expanded you get this. So who are the

1603
01:51:19,300 --> 01:51:29,460
 notes in the open now? It's a G, H, C, E and F. Okay. Then they compete among themselves. And then

1604
01:51:29,460 --> 01:51:36,180
 you pick the best. So among this, which one is best? The E is best. So E is the best. And then you

1605
01:51:36,180 --> 01:51:42,820
 get this. And there you have. Okay. So that's how possibly you can find the answer. Okay. So this

1606
01:51:42,820 --> 01:51:54,100
 is called best first. Okay. But not best only. Okay. So that's the best first algorithm. So you

1607
01:51:54,100 --> 01:52:11,060
 have open and also you have closed list. So this is how you evaluate. So basically pick the best

1608
01:52:11,060 --> 01:52:18,980
 notes in the open. So you see pick the best notes in the open. That means the open list, is this a

1609
01:52:18,980 --> 01:52:28,900
 stack or is this a queue? Doesn't matter. In a way, doesn't matter. When you add into, you can add in

1610
01:52:28,900 --> 01:52:36,980
 any direction and then sort it. You need to sort based on their H value. Yes. And then the best one,

1611
01:52:37,620 --> 01:52:43,379
 you pick. Okay. So you sort it. Maybe you from high to low or low to high depends on what is your H

1612
01:52:43,380 --> 01:52:49,940
 value definition. Then you pick the best. Okay. So this is generate the assessors. And then for

1613
01:52:49,940 --> 01:52:55,700
 each assessor, if you check, you know, whether have generate before and then evaluate into the open

1614
01:52:55,700 --> 01:53:02,740
 and the records, the parents. So if already generate before and still in the open, you want to replace

1615
01:53:02,740 --> 01:53:10,020
 them. Okay. Use a better H value. Replace them. Update the cost. And then if already placed in the

1616
01:53:10,020 --> 01:53:16,020
 close, if the new pass is better than previous one, then you actually take them out and then add

1617
01:53:16,020 --> 01:53:23,620
 into the open. So that means you can recycle. Okay. You can take out previously already exam,

1618
01:53:23,620 --> 01:53:30,020
 but actually reach by different paths. And then if the current one is better, you add in again. Okay.

1619
01:53:30,100 --> 01:53:37,380
 So it can be re-examined. So that is the idea. Yeah. So one more algorithm.

1620
01:53:41,620 --> 01:53:49,620
 Okay. So this is open or closed. Okay. The only thing is now you have the H value.

1621
01:53:49,620 --> 01:53:56,340
 You have H value. You also still checking the children. You check whether X already,

1622
01:53:57,300 --> 01:54:02,420
 sorry, sorry. Okay. Okay. Start from here. Remove the left most. Okay. I'm talking about left most.

1623
01:54:02,420 --> 01:54:08,500
 So I'm still using left most. That means I sorted and then our best one on the left. Okay. So left

1624
01:54:08,500 --> 01:54:14,580
 most, put into X and then check whether X is already the goal. Yes. Then return. If not,

1625
01:54:15,140 --> 01:54:21,300
 then get the children on the X. And then for each children, you check, check, check. Okay. So see

1626
01:54:21,300 --> 01:54:28,260
 whether the children is not appear before. So that is very straightforward. Right. To add them.

1627
01:54:28,260 --> 01:54:34,580
 Okay. So that means you should evaluate the value, the H value for these children and then add these

1628
01:54:34,580 --> 01:54:40,020
 children to the open. Okay. Just add. They didn't say add from which direction. Doesn't matter. Just

1629
01:54:40,020 --> 01:54:47,700
 add. Because after adding, yeah, the current X should be in the close. After adding, you need to

1630
01:54:47,780 --> 01:54:54,900
 sorting, do the sorting. So that is a reordering states on the open by their heuristic merit.

1631
01:54:54,900 --> 01:55:02,099
 Okay. So either the best lowest value or highest value depends on whether you are using the fitness

1632
01:55:02,099 --> 01:55:09,300
 or using cost. And then the best one should be on the left most. Okay. If it's equal, then equal.

1633
01:55:09,300 --> 01:55:15,220
 I mean up to you, random or alphabetical order or whatever if you want to have a unique answer.

1634
01:55:15,860 --> 01:55:23,860
 Okay. Yeah. So this is the resort. Resorting. That's why here seems very casually. Just say,

1635
01:55:23,860 --> 01:55:34,580
 just say, just say, add. Right. Yeah. Just say add this into the open. Just say add.

1636
01:55:37,060 --> 01:55:42,340
 So this is if the children not appear before, if the children already appear in the open,

1637
01:55:43,060 --> 01:55:49,460
 then we check whether the current one reach, is there a shorter path. That means it's a

1638
01:55:49,460 --> 01:55:54,900
 shorter one. So we try to find the optimum. So if it's shorter one, we should update. Okay. We

1639
01:55:54,900 --> 01:56:00,980
 should update. So similarly, if you're already in the close, but current one is shorter,

1640
01:56:01,620 --> 01:56:08,580
 then remove the one from the, from the close and then add these children into the open again.

1641
01:56:08,580 --> 01:56:15,940
 Okay. And then the key thing is in the end, we need to resort, sorting the open list

1642
01:56:16,740 --> 01:56:24,980
 and then make the left most one the best one. Okay. And then go back to check. So that is

1643
01:56:25,700 --> 01:56:33,860
 best first. Okay. Best first. Any question?

1644
01:56:36,419 --> 01:56:42,179
 So why is a heuristic value? Now, after suppose we have a heuristic value, how to search. Okay.

1645
01:56:43,140 --> 01:56:54,900
 Yeah. Come to this again. So check that the best first work. Okay. Heuricolumines doesn't work.

1646
01:56:54,900 --> 01:57:01,380
 That means the best only it would not work. Best first search. Is that work? Okay. Based on the

1647
01:57:01,380 --> 01:57:08,500
 algorithm. Yeah. We have the children here and then we sort them. So suppose B was the first

1648
01:57:08,500 --> 01:57:18,500
 and then the expanded. So this, now we have this, this, and this, this in the open list.

1649
01:57:18,500 --> 01:57:24,740
 Right. In the open list, then we sorted and then this one is the best. Right. So we should

1650
01:57:24,740 --> 01:57:34,660
 expanding here. So we are having this, this edit. So we will have one, two, three, four, five in the

1651
01:57:34,660 --> 01:57:44,740
 open. Okay. And then this is the best. So this one expanding. Right. So we will have this, this,

1652
01:57:46,580 --> 01:57:55,380
 here, here, here, here. And then we sorted this one will be checked. No children. Then next one.

1653
01:57:56,100 --> 01:58:08,740
 Right. We find it. Yeah. So use the best first. We can find it. Okay. Yeah. I think that's about it.

1654
01:58:09,540 --> 01:58:16,100
 Then this is how they updated. Then, yeah, we try to find the,

1655
01:58:17,940 --> 01:58:23,140
 and those in the close and those in the open, you know, we can still find the answer.

1656
01:58:24,100 --> 01:58:32,420
 So we try to use a hill climbing. We can try to use depth first or breadth BFS.

1657
01:58:33,140 --> 01:58:41,140
 Can we find it? Those are exhaustive search. Right. For this case, can we find use that DFS?

1658
01:58:42,100 --> 01:58:55,220
 BFS. Can not. Looks like can not. Level by level. Right. I mean, if it's a BFS level by level,

1659
01:58:56,020 --> 01:59:04,100
 if it's a BFS, then branch by branch, we can still find it. Yeah. It's just a efficiency. Right.

1660
01:59:04,500 --> 01:59:06,580
 Okay. Okay. That's all.

1661
01:59:10,180 --> 01:59:20,980
 I think, yeah. So we managed to cover all those algorithms from the topic tree. Those are the

1662
01:59:20,980 --> 01:59:29,060
 topic we covered. Heuristic value concept. Okay. So, and then the search. So this is the best only,

1663
01:59:29,620 --> 01:59:38,500
 this is the best first. This one best only. This is really just for very much introduction to

1664
01:59:38,500 --> 01:59:44,900
 say search algorithm. Still very important. Even you have each value. Okay. And then,

1665
01:59:46,340 --> 01:59:55,060
 so this is a topic we covered in part A in topic three. And topic B will be more about gaming.

1666
01:59:55,060 --> 02:00:01,940
 So I would introduce the other algorithms, especially for gaming. Okay. Minimax and also the

1667
02:00:01,940 --> 02:00:10,020
 alphabet pruning. Okay. Next week. Next week, we also go through the backtracking exercise

1668
02:00:10,820 --> 02:00:18,340
 in detail. So please go back and try and step by step. And then we check the answer. And then

1669
02:00:19,300 --> 02:00:26,260
 we will talk about the new things. Okay. If you want to do it here for the backtracking,

1670
02:00:26,260 --> 02:00:33,780
 yes, I will be around if you want to check. Okay. Otherwise, I think we can stop here.

1671
02:00:35,700 --> 02:00:43,620
 Okay. Anything else? Any quick question? Oh, yes. One thing I forgot to say. Proven already

1672
02:00:43,700 --> 02:00:49,460
 updates the file. So already upload the file. So you can actually

1673
02:00:50,260 --> 02:00:59,460
 fill in if you already have a team for the project. Yeah. And another thing is I think

1674
02:01:01,059 --> 02:01:10,580
 that we can arrange probably two TA sessions just for you for question or answer session for

1675
02:01:10,580 --> 02:01:18,820
 some related to the project. Okay. In the week 11 and 12. But I will, I haven't got the confirmation

1676
02:01:18,820 --> 02:01:24,660
 about the venue yet, although I booked it in the tutorial room. Here it's not available. Okay. So

1677
02:01:24,660 --> 02:01:40,420
 I will inform you again. You can form a team of three. Okay. Form a team of three. Yeah. Thank you.

1678
02:01:40,980 --> 02:01:47,380
 I still thought you tried to make it so it's not old. Oh, we choose the old and the old is not the

1679
02:01:47,380 --> 02:01:56,260
 goal. So we will take another one from the open. Oh, okay. So weird motion that always not so.

1680
02:01:56,260 --> 02:01:59,380
 Oh, because the algorithm, where's the algorithm?

1681
02:02:01,780 --> 02:02:08,100
 Now here. Yeah. So here actually we check to check whether this is a goal. You see. Oh,

1682
02:02:08,660 --> 02:02:14,340
 so it's not goal. And then the next one will be checked, right? Because we still have things in the

1683
02:02:14,340 --> 02:02:26,900
 open. Okay. So if it's not the OTC, so it's yeah, yeah. Thank you. Yeah. I have a question.

1684
02:02:27,860 --> 02:02:41,059
 As you see first, A is also the children of the C. Yes. So in the deep, deep, deep, deep

1685
02:02:41,059 --> 02:02:48,019
 process, why can't I? You don't add in anymore because A was there before.

1686
02:02:49,780 --> 02:02:56,500
 You see the DFS and DFS, they say it was already the children, but already appeared before. You

1687
02:02:56,580 --> 02:03:13,380
 don't put in anymore. Okay. Why the third step? The open is DFH. The order is the DFH, not the HDF.

1688
02:03:14,100 --> 02:03:23,700
 Oh, because alphabetical, alphabetical, yeah. Alphabetical order. So ABCD, yeah.

1689
02:03:26,420 --> 02:03:33,540
 DFH. Oh, because I think HDF is right. Yes, exactly.

1690
02:03:33,540 --> 02:03:40,500
 But I don't know how to say it. Yeah, yeah. Actually, it's just you get the

1691
02:59:34,260 --> 02:59:50,500
 DFS.

1692
02:59:50,500 --> 02:59:54,980
 Thank you.

