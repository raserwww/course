1
00:00:00,000 --> 00:00:07,000
 中文字幕 中文字幕 中文字幕

2
00:00:30,000 --> 00:00:37,000
 中文字幕

3
00:01:00,000 --> 00:01:07,000
 中文字幕

4
00:01:30,000 --> 00:01:37,000
 中文字幕

5
00:02:00,000 --> 00:02:07,000
 中文字幕

6
00:02:07,000 --> 00:02:14,000
 中文字幕

7
00:02:14,000 --> 00:02:23,000
 中文字幕

8
00:02:23,000 --> 00:02:30,000
 中文字幕

9
00:02:30,000 --> 00:02:37,000
 中文字幕

10
00:02:37,000 --> 00:02:44,000
 中文字幕

11
00:02:44,000 --> 00:02:51,000
 中文字幕

12
00:02:51,000 --> 00:02:58,000
 中文字幕

13
00:02:58,000 --> 00:03:08,000
 中文字幕

14
00:03:08,000 --> 00:03:15,000
 中文字幕

15
00:03:15,000 --> 00:03:23,000
 中文字幕

16
00:03:23,000 --> 00:03:33,000
 中文字幕

17
00:03:33,000 --> 00:03:40,000
 中文字幕

18
00:03:40,000 --> 00:03:47,000
 中文字幕

19
00:03:47,000 --> 00:03:57,000
 中文字幕

20
00:03:57,000 --> 00:04:04,000
 中文字幕

21
00:04:04,000 --> 00:04:12,000
 中文字幕

22
00:04:12,000 --> 00:04:25,000
 中文字幕

23
00:04:25,000 --> 00:04:32,000
 中文字幕

24
00:04:32,000 --> 00:04:40,000
 中文字幕

25
00:04:40,000 --> 00:04:49,000
 中文字幕

26
00:04:49,000 --> 00:04:56,000
 中文字幕

27
00:04:56,000 --> 00:05:04,000
 中文字幕

28
00:05:04,000 --> 00:05:10,000
 中文字幕

29
00:05:10,000 --> 00:05:17,000
 中文字幕

30
00:05:17,000 --> 00:05:24,000
 中文字幕

31
00:05:24,000 --> 00:05:31,000
 中文字幕

32
00:05:31,000 --> 00:05:38,000
 中文字幕

33
00:05:38,000 --> 00:05:44,000
 中文字幕

34
00:05:44,000 --> 00:05:51,000
 中文字幕

35
00:05:51,000 --> 00:05:54,000
 中文字幕

36
00:05:54,000 --> 00:06:04,000
 中文字幕

37
00:06:04,000 --> 00:06:12,000
 中文字幕

38
00:06:12,000 --> 00:06:19,000
 中文字幕

39
00:06:19,000 --> 00:06:27,000
 中文字幕

40
00:06:27,000 --> 00:06:32,000
 中文字幕

41
00:06:32,000 --> 00:06:37,000
 中文字幕

42
00:06:37,000 --> 00:06:45,000
 中文字幕

43
00:06:45,000 --> 00:06:53,000
 中文字幕

44
00:06:53,000 --> 00:07:02,000
 中文字幕

45
00:07:02,000 --> 00:07:03,680
 here within the search window.

46
00:07:03,680 --> 00:07:05,280
 Suppose this is a current macro block.

47
00:07:05,280 --> 00:07:08,320
 If your best match block or most similar block is here,

48
00:07:08,320 --> 00:07:10,640
 then the relative offset from here to here,

49
00:07:10,640 --> 00:07:13,920
 this position is known as the motion vector.

50
00:07:13,920 --> 00:07:18,640
 So that's a basic idea of a motion estimation.

51
00:07:18,640 --> 00:07:20,600
 So once you've found the best match block,

52
00:07:20,600 --> 00:07:23,160
 this block and this block are a little bit different.

53
00:07:23,160 --> 00:07:24,920
 So therefore, if you take the difference

54
00:07:24,920 --> 00:07:27,120
 between these two macro blocks,

55
00:07:27,120 --> 00:07:30,040
 you'll get a matrix which is the prediction error.

56
00:07:30,040 --> 00:07:32,720
 So that is known as a motion compensation.

57
00:07:32,720 --> 00:07:35,680
 So that's a quick recap of the idea.

58
00:07:35,680 --> 00:07:38,880
 So now, this particular video is actually

59
00:07:38,880 --> 00:07:41,880
 showing you the motion vector visualization.

60
00:07:41,880 --> 00:07:44,160
 So what it means is that even this video,

61
00:07:44,160 --> 00:07:46,240
 we partition into numerous macro blocks.

62
00:07:46,240 --> 00:07:48,080
 And then for each of these macro blocks,

63
00:07:48,080 --> 00:07:50,480
 we compare to the previous reference frame

64
00:07:50,480 --> 00:07:54,160
 to see the relative displacement vector

65
00:07:54,160 --> 00:07:55,800
 or all the motion vector.

66
00:07:55,800 --> 00:07:57,480
 So you're going to see later on.

67
00:08:00,040 --> 00:08:02,040
 This part is a bit off.

68
00:08:31,040 --> 00:08:33,039
 Right, okay.

69
00:08:33,039 --> 00:08:36,039
 So this particular video you're going to see later on

70
00:08:36,039 --> 00:08:39,039
 essentially is a current frame.

71
00:08:39,039 --> 00:08:41,039
 You partition into numerous macro blocks.

72
00:08:41,039 --> 00:08:43,039
 And then for each of the macro blocks,

73
00:08:43,039 --> 00:08:45,040
 you compare to the previous reference frame

74
00:08:45,040 --> 00:08:48,040
 to see the positions of the best match block.

75
00:08:48,040 --> 00:08:51,040
 So this arrow here that you see,

76
00:08:51,040 --> 00:08:54,040
 you'll see that there's a small line, actually it's an arrow.

77
00:08:54,040 --> 00:08:56,040
 It indicates the direction of this motion vector

78
00:08:56,040 --> 00:08:58,040
 and how far it is.

79
00:08:58,040 --> 00:09:01,040
 Okay, so I'll just play you this very short video

80
00:09:01,040 --> 00:09:03,040
 just to let you have a few about,

81
00:09:03,040 --> 00:09:06,040
 for different macro blocks, how the motion vector looks like.

82
00:09:09,040 --> 00:09:12,040
 Okay, so you can see there are some arrows here.

83
00:09:12,040 --> 00:09:17,040
 They indicate the motion vectors across different frames.

84
00:09:17,040 --> 00:09:21,040
 Okay, so most of the time, unless there's a motion,

85
00:09:21,040 --> 00:09:24,040
 otherwise for most of the frames that have little motion,

86
00:09:24,040 --> 00:09:28,040
 you can see there's hardly any motion vector at all.

87
00:09:28,040 --> 00:09:32,040
 Okay, so that's to give you a quick visualizations

88
00:09:32,040 --> 00:09:35,040
 of how this motion vector will look like.

89
00:09:37,040 --> 00:09:40,040
 Okay, so next let's continue.

90
00:09:41,040 --> 00:09:43,040
 So the next section that we are going to look at

91
00:09:43,040 --> 00:09:47,040
 is the different methods in motion estimation.

92
00:09:47,040 --> 00:09:51,040
 So just now the previous lecture that we mentioned,

93
00:09:51,040 --> 00:09:54,040
 if you want to perform motion estimation,

94
00:09:54,040 --> 00:09:57,040
 there's actually many different ways you can perform motion estimation.

95
00:09:57,040 --> 00:10:01,040
 So if you use a brute force, right, that means the original approach,

96
00:10:01,040 --> 00:10:05,040
 what you do is that to recap, you take your current frame,

97
00:10:05,040 --> 00:10:07,040
 you partition it into numerous macro blocks.

98
00:10:07,040 --> 00:10:09,040
 So for each of these macro blocks,

99
00:10:09,040 --> 00:10:12,040
 you compare to the previous reference frame

100
00:10:12,040 --> 00:10:15,040
 and then standard at the positions of this macro block,

101
00:10:15,040 --> 00:10:17,040
 you need to define a search window.

102
00:10:17,040 --> 00:10:19,040
 Okay, search window here.

103
00:10:19,040 --> 00:10:21,040
 So therefore afterwards you need to, you know,

104
00:10:21,040 --> 00:10:24,040
 compare the positions of this macro block.

105
00:10:24,040 --> 00:10:30,040
 You need to move this macro block to different positions in the search window.

106
00:10:30,040 --> 00:10:33,040
 And then for each position, right, you have this reference frame,

107
00:10:33,040 --> 00:10:36,040
 you are trying to find the difference between this current macro block

108
00:10:36,040 --> 00:10:38,040
 and the corresponding region.

109
00:10:38,040 --> 00:10:41,040
 And then later on you'll compute, you'll get an arrow.

110
00:10:41,040 --> 00:10:45,040
 So you try to find the position, the arrow,

111
00:10:45,040 --> 00:10:48,040
 okay, at each of the positions in the search window.

112
00:10:48,040 --> 00:10:51,040
 So if you do that, it's called full search.

113
00:10:51,040 --> 00:10:56,040
 And if you think about it, full search means that for every point in the search window,

114
00:10:56,040 --> 00:10:59,040
 right, you need to calculate the difference.

115
00:10:59,040 --> 00:11:02,040
 So it's very computational intensive.

116
00:11:02,040 --> 00:11:05,040
 So now the next thing is that are there some better way to do it?

117
00:11:05,040 --> 00:11:09,040
 But before we talk about different motion estimation method,

118
00:11:09,040 --> 00:11:13,040
 we need to realize what are some key considerations or factors

119
00:11:13,040 --> 00:11:18,040
 that we need to consider when we try to design the motion estimation method.

120
00:11:18,040 --> 00:11:23,040
 So if you spend some time, you know, pause for one moment and think about it.

121
00:11:23,040 --> 00:11:27,040
 But if you want to do, design different motion estimation methods,

122
00:11:27,040 --> 00:11:31,040
 what are some key considerations?

123
00:11:31,040 --> 00:11:34,040
 What do you think are the key factors that will decide

124
00:11:34,040 --> 00:11:39,040
 whether a motion estimation method is good or not good?

125
00:11:44,040 --> 00:11:50,040
 What do you think are the key factors?

126
00:11:50,040 --> 00:11:54,040
 Number one is you want it to be...

127
00:11:54,040 --> 00:11:59,040
 You want to be accurate, right?

128
00:11:59,040 --> 00:12:02,040
 So you want to be able to make sure that, okay,

129
00:12:02,040 --> 00:12:06,040
 early on we have just explained this full search meaning that we try to find

130
00:12:06,040 --> 00:12:09,040
 within this search window,

131
00:12:09,040 --> 00:12:14,040
 every single position what is the prediction error.

132
00:12:14,040 --> 00:12:18,040
 So if you do that, then definitely you can find the position with the smallest error.

133
00:12:18,040 --> 00:12:21,040
 But we know that this is very slow, very expensive.

134
00:12:21,040 --> 00:12:24,040
 Okay, so now we want to develop some better method.

135
00:12:24,040 --> 00:12:29,040
 But in the process of developing method, we still want this particular method to be accurate.

136
00:12:29,040 --> 00:12:33,040
 Accurate in the sense that we may not be able to search all the points,

137
00:12:33,040 --> 00:12:39,040
 but we want to find the position which has relatively small error.

138
00:12:39,040 --> 00:12:44,040
 So that means we want this particular motion factor estimation still to be accurate.

139
00:12:44,040 --> 00:12:48,040
 Because if it's accurate, that means this current macro block

140
00:12:48,040 --> 00:12:51,040
 and your best match block, the error will be small.

141
00:12:51,040 --> 00:12:55,040
 If the error is small, that means the subsequent compression is going to be good

142
00:12:55,040 --> 00:12:58,040
 and then your compression ratio is going to be high

143
00:12:58,040 --> 00:13:00,040
 and the file size is going to be small.

144
00:13:00,040 --> 00:13:04,040
 So therefore one of the key considerations is we want it to be accurate

145
00:13:04,040 --> 00:13:07,040
 because accurate will make sure your prediction error is small.

146
00:13:07,040 --> 00:13:11,040
 Prediction error is small will make sure that your compression ratio is high.

147
00:13:11,040 --> 00:13:15,040
 Compression ratio was high means that your file size will be small,

148
00:13:15,040 --> 00:13:17,040
 or your bitrate will be small.

149
00:13:17,040 --> 00:13:19,040
 So therefore we want it to be accurate.

150
00:13:19,040 --> 00:13:24,040
 So what is the second factor that you have to consider?

151
00:13:24,040 --> 00:13:29,040
 The second one is you want it to be fast, right?

152
00:13:29,040 --> 00:13:33,040
 Because otherwise, if speed is not a key consideration,

153
00:13:33,040 --> 00:13:37,040
 we could just use the full search to find all the positions.

154
00:13:37,040 --> 00:13:43,040
 So therefore the two key considerations we will try to design a motion estimation method

155
00:13:43,040 --> 00:13:47,040
 is it need to be accurate and it need to be fast, right?

156
00:13:47,040 --> 00:13:50,040
 And often this is a trade-off.

157
00:13:50,040 --> 00:13:54,040
 Okay, right, so over the times there are actually many different

158
00:13:54,040 --> 00:13:57,040
 motion estimation method that has been developed.

159
00:13:57,040 --> 00:14:01,040
 But for example, full search, right, three step search,

160
00:14:01,040 --> 00:14:05,040
 2D logarithm search, hierarchical search and so on and so forth.

161
00:14:05,040 --> 00:14:08,040
 So for this course we are going to cover some of them.

162
00:14:08,040 --> 00:14:13,040
 Okay, so the full search I think in the process of starting about this motion estimation

163
00:14:13,040 --> 00:14:16,040
 we have already explained how do we perform the full search.

164
00:14:16,040 --> 00:14:20,040
 Right, early on I also mentioned, right, so suppose this is a current macro block, right?

165
00:14:20,040 --> 00:14:25,040
 Okay, center at the position of this macro block, you define a search window, okay?

166
00:14:25,040 --> 00:14:29,040
 And afterwards you move this macro block to the first position,

167
00:14:29,040 --> 00:14:33,040
 you calculate the error, you move your macro block to the next pixel position,

168
00:14:33,040 --> 00:14:39,040
 you calculate the error. So that means you find the error at each positions in this search window.

169
00:14:39,040 --> 00:14:42,040
 So if you do that, then it's actually a full search.

170
00:14:42,040 --> 00:14:48,040
 So this full search is also given from this particular equations here.

171
00:14:48,040 --> 00:14:50,040
 So this is a full search.

172
00:14:50,040 --> 00:14:57,040
 You are searching all the positions in this particular search window of 2P plus 1 by 2P plus 1.

173
00:14:57,040 --> 00:15:01,040
 Okay, so this is a full search equation.

174
00:15:01,040 --> 00:15:06,040
 But early on we just explained full search is accurate but it's very slow.

175
00:15:06,040 --> 00:15:10,040
 So now we want to go for some faster method.

176
00:15:10,040 --> 00:15:14,040
 So the next method we are going to introduce is known as a three step search.

177
00:15:14,040 --> 00:15:16,040
 So what is three step search?

178
00:15:16,040 --> 00:15:20,040
 So as a name search, okay, so anyway a quick recap of the full search.

179
00:15:20,040 --> 00:15:25,040
 So full search means that you search every point within the search window, right?

180
00:15:25,040 --> 00:15:29,040
 Okay, so the advantage is accurate because definitely you will, within this search window,

181
00:15:29,040 --> 00:15:33,040
 definitely you will find the position with the smallest error.

182
00:15:33,040 --> 00:15:34,040
 So it's accurate, right?

183
00:15:34,040 --> 00:15:40,040
 Because it's accurate, it will lead to highest compression ratio or smallest file size of bitrate.

184
00:15:40,040 --> 00:15:43,040
 Okay, but the disadvantage is slow, right?

185
00:15:43,040 --> 00:15:45,040
 Because it's computationally intensive.

186
00:15:45,040 --> 00:15:49,040
 You need to evaluate the error at each position.

187
00:15:49,040 --> 00:15:53,040
 So as opposed to that, the second approach that we have is a three step search.

188
00:15:53,040 --> 00:15:56,040
 So what is the meaning of a three step search here?

189
00:15:56,040 --> 00:16:00,040
 Right, okay, so first of all, if you look at this particular grid here,

190
00:16:00,040 --> 00:16:04,040
 right, this we can kind of interpret as a search window.

191
00:16:04,040 --> 00:16:08,040
 Okay, so how do we interpret this particular grid is, imagine again, right,

192
00:16:08,040 --> 00:16:14,040
 currently this frame you want to compress, partition to numerous macro block.

193
00:16:14,040 --> 00:16:17,040
 Suppose this is a current macro block that you want to compress.

194
00:16:17,040 --> 00:16:23,040
 So you compare respect to the previous reference frame at the corresponding center position,

195
00:16:23,040 --> 00:16:25,040
 you define a search window, okay?

196
00:16:25,040 --> 00:16:32,040
 Right, so this is the search window on the reference frame that you need to check the error.

197
00:16:32,040 --> 00:16:37,040
 So if it's full search, that means you need to check the error at each of this particular position.

198
00:16:37,040 --> 00:16:42,040
 You can just imagine that you have a macro block here, you put a center at this position,

199
00:16:42,040 --> 00:16:48,040
 you find the error between this current macro block and the underlying part of the image in the reference frame.

200
00:16:48,040 --> 00:16:52,040
 Okay, so for full search, you check every single point.

201
00:16:52,040 --> 00:16:57,040
 Yeah, but for three step search, what we do is that, right, so first of all, okay,

202
00:16:57,040 --> 00:17:02,040
 we are going to, suppose this is the size of this particular search window here,

203
00:17:02,040 --> 00:17:07,040
 right, we are going to take the center point and then between the center point and the edge in the middle,

204
00:17:07,040 --> 00:17:09,040
 we are going to also take the point.

205
00:17:09,040 --> 00:17:15,040
 So we are going to create, we are going to obtain 9.123456789.

206
00:17:15,040 --> 00:17:17,040
 So this is the number as one.

207
00:17:17,040 --> 00:17:22,040
 So these are the positions we are trying to find is error first, in step one.

208
00:17:22,040 --> 00:17:28,040
 So in step one, we are going to find the error at this nine position indicated as one, okay?

209
00:17:28,040 --> 00:17:35,040
 So this is more like, you know, you roughly sample, right, a rough region where that minimum error

210
00:17:35,040 --> 00:17:38,040
 are likely going to occur, okay?

211
00:17:38,040 --> 00:17:40,040
 Right, so you check these nine points first.

212
00:17:40,040 --> 00:17:46,040
 Suppose out of these nine points here, right, the error that you have is at this particular position, okay?

213
00:17:46,040 --> 00:17:49,040
 Suppose out of these nine points, you find that the error is at this position.

214
00:17:49,040 --> 00:17:55,040
 Then what you need to do now is that in your step two, you are going to be centering at this new position now.

215
00:17:55,040 --> 00:18:01,040
 Just imagine you walk towards the center of this minimum in step one,

216
00:18:01,040 --> 00:18:04,040
 and then you are going to reduce your search width.

217
00:18:04,040 --> 00:18:07,040
 You can see now the search width, okay?

218
00:18:07,040 --> 00:18:11,040
 Right, in step two here, you are going to calculate the error at this position.

219
00:18:11,040 --> 00:18:16,040
 Two, two, two, right, those that you have already evaluated at one, there's no need to repeat that.

220
00:18:16,040 --> 00:18:20,040
 But no, those that you have not done, you evaluate in step two.

221
00:18:20,040 --> 00:18:25,040
 You can see it's two, two, two, right, this one you're done in one, ready, two, two, two.

222
00:18:25,040 --> 00:18:29,040
 But so you can see you are going to find the error at this nine position, right?

223
00:18:29,040 --> 00:18:31,040
 And the search window has been reduced.

224
00:18:31,040 --> 00:18:37,040
 In step one, it's a length of four, but now in step two, it's a length of two, right?

225
00:18:37,040 --> 00:18:45,040
 Okay, so out of these nine positions here, suppose the, right, this position is the one that gives you the smallest error,

226
00:18:45,040 --> 00:18:51,040
 then next you are going to, in step three, you are going to be moving center at this position,

227
00:18:51,040 --> 00:18:54,040
 and again you're going to reduce the search width.

228
00:18:54,040 --> 00:18:59,040
 So the search width now you are going to reduce now, previously it's two, now it's reduced to one.

229
00:18:59,040 --> 00:19:04,040
 So you'll be looking at this nine position indicated by three, okay?

230
00:19:04,040 --> 00:19:09,040
 So among these nine positions, suppose if this position is the one that gives you the smallest error,

231
00:19:09,040 --> 00:19:20,040
 then you can see that the motion vector would then be approximated as, you know, from originally center to lightly, this is the, you know, the location.

232
00:19:20,040 --> 00:19:27,040
 So then this will be the motion vector that's estimated using this three step search, yeah?

233
00:19:27,040 --> 00:19:36,040
 So the basic idea is actually quite simple, but initially you roughly spread evenly across different points to roughly check where the local minima is.

234
00:19:36,040 --> 00:19:45,040
 And afterwards you're going to move to, right, the center of the local minima, because you assume that this particular arrow, the region is roughly smooth.

235
00:19:45,040 --> 00:19:56,040
 So, right, you roughly find out out of those nine points where is the minima, and then afterwards the assumption is that lightly the minima will be somewhere nearby,

236
00:19:56,040 --> 00:20:00,040
 okay, based on your current rough kind of a sample.

237
00:20:00,040 --> 00:20:08,040
 Okay, so therefore this is an idea for you to find the motion vector within three steps, hence named three step search.

238
00:20:08,040 --> 00:20:13,040
 That means you'll be able to arrive at the motion vector within three steps.

239
00:20:13,040 --> 00:20:20,040
 So therefore if you think about for three step search, what do you think will be the advantage as compared to full search?

240
00:20:20,040 --> 00:20:24,040
 What's the advantage?

241
00:20:24,040 --> 00:20:27,040
 It's going to be very fast, right?

242
00:20:27,040 --> 00:20:31,040
 So as compared to full search, you need to evaluate arrow at each position.

243
00:20:31,040 --> 00:20:35,040
 Now you only need to evaluate maximum 27.

244
00:20:35,040 --> 00:20:37,040
 Some of them is actually repetition.

245
00:20:37,040 --> 00:20:40,040
 It is maybe even less than that.

246
00:20:40,040 --> 00:20:47,040
 Okay, so therefore it's actually going to be very fast, but what is the price you have to pay?

247
00:20:47,040 --> 00:20:50,040
 The price you have to pay is not so accurate, okay?

248
00:20:50,040 --> 00:20:53,040
 Right, sometimes it's not so accurate.

249
00:20:53,040 --> 00:20:57,040
 So therefore for three step search, this is the basic idea.

250
00:20:57,040 --> 00:21:01,040
 So early on I already explained to you, so now it's written in bookseed.

251
00:21:01,040 --> 00:21:03,040
 So it consists of three steps only.

252
00:21:03,040 --> 00:21:08,040
 So in step one, you search the nine point for the minimum prediction error.

253
00:21:08,040 --> 00:21:14,040
 Okay, and afterwards in step two, center at the position that you have found in step one, right?

254
00:21:14,040 --> 00:21:20,040
 Okay, you have the search width, okay, and then you search the nine point for minimum error.

255
00:21:20,040 --> 00:21:27,040
 Right, so once you've found the position of the minimum error, you're going to be center at the new found position in step two.

256
00:21:27,040 --> 00:21:31,040
 Again, you have the search width, you search another nine point for minimum error.

257
00:21:31,040 --> 00:21:42,040
 So the final position that you found is the best found position, or you're going to get the motion factor from it.

258
00:21:42,040 --> 00:21:49,040
 So the advantage of these three step search is fast, but the disadvantage is, as we have mentioned, it's not so accurate.

259
00:21:49,040 --> 00:21:59,040
 And if it's not so accurate, then means likely your compression ratio is going to be lower and your file size or bitrate is going to be high.

260
00:21:59,040 --> 00:22:02,040
 Okay, so that's the pros and cons.

261
00:22:02,040 --> 00:22:07,040
 So the next method that we have is known as the 2D logarithm search.

262
00:22:07,040 --> 00:22:11,040
 So for 2D logarithm search, there's a few different variations.

263
00:22:11,040 --> 00:22:15,040
 So we are just going to look at one of the possible variations here.

264
00:22:15,040 --> 00:22:20,040
 So let's look at the basic principles of 2D logarithm search.

265
00:22:20,040 --> 00:22:27,040
 So suppose again, we are going to see this particular grid that we have, there are the search window position.

266
00:22:27,040 --> 00:22:29,040
 Each point is actually in the search window.

267
00:22:29,040 --> 00:22:38,040
 So what we are going to do, right, so first of all, in step one, we are going to evaluate the error at the center as well as another four position,

268
00:22:38,040 --> 00:22:41,040
 but which is equal distance from the center to the edge.

269
00:22:41,040 --> 00:22:44,040
 So therefore, we are going to find the error at this five position.

270
00:22:44,040 --> 00:22:47,040
 One, two, three, four, five.

271
00:22:47,040 --> 00:22:49,040
 Okay, so this is one of the variants.

272
00:22:49,040 --> 00:22:54,040
 There are also some other variants, but for this course, we are going to be using this particular version.

273
00:22:54,040 --> 00:22:58,040
 Okay, so one, two, three, four, five.

274
00:22:58,040 --> 00:23:02,040
 We are going to find the minimum error at this five position.

275
00:23:02,040 --> 00:23:07,040
 Suppose out of this five position, the one that gives you the smallest error is this one.

276
00:23:07,040 --> 00:23:17,040
 Okay, so therefore then our assumption is that no, if that is the position that gives the smallest error, then likely the minimum should be somewhere nearby.

277
00:23:17,040 --> 00:23:23,040
 So therefore, what you are going to do is you are going to be center your search at this new position now.

278
00:23:23,040 --> 00:23:26,040
 Okay, you're going to move from here to here now.

279
00:23:26,040 --> 00:23:36,040
 But one difference is compared to three step search is that for three step search, right, for every step, you always reduce the search width by half.

280
00:23:36,040 --> 00:23:39,040
 But for 2D logarithm search, you do not do that.

281
00:23:39,040 --> 00:23:42,040
 Right, so you will only reduce the search width.

282
00:23:42,040 --> 00:23:51,040
 Okay, if your current position, the central position is the minimum or when you are reaching the edge of the search window.

283
00:23:51,040 --> 00:23:53,040
 So later on, we're going to see.

284
00:23:53,040 --> 00:24:00,040
 Right, okay, so anyway, suppose in step one, we check this five position and this is the position that gives us the smallest error.

285
00:24:00,040 --> 00:24:03,040
 So now we're going to be moving center at this position.

286
00:24:03,040 --> 00:24:14,040
 And then because the new position with the smallest error is not near the center, so we do not reduce the search width yet.

287
00:24:14,040 --> 00:24:17,040
 We still retain a search width of two.

288
00:24:17,040 --> 00:24:22,040
 Right, so therefore in step two, we're going to evaluate the error at this five position.

289
00:24:22,040 --> 00:24:26,040
 One, two, three, four, five as indicated by two.

290
00:24:26,040 --> 00:24:31,040
 Those that you already determined in step one, you can just reuse the error here.

291
00:24:31,040 --> 00:24:33,040
 So we are going to look at this five position.

292
00:24:33,040 --> 00:24:37,040
 In step two, to see which one give you the smallest error.

293
00:24:37,040 --> 00:24:43,040
 Suppose out this five position, right, this position is the one that give you the smallest error.

294
00:24:43,040 --> 00:24:48,040
 So now that means we are going to be moving to be center at this position now.

295
00:24:48,040 --> 00:24:56,040
 Okay, and because this position is not at the center here, so we are going to repeat the process of finding five error.

296
00:24:56,040 --> 00:24:58,040
 Okay, the search width, we still do not reduce it.

297
00:24:58,040 --> 00:25:01,040
 Okay, so that means we are going to be center at this position now.

298
00:25:01,040 --> 00:25:03,040
 We are going to find the error at this five position.

299
00:25:03,040 --> 00:25:08,040
 One, two, three, four, five as indicated by this tree here.

300
00:25:08,040 --> 00:25:14,040
 Okay, right, so suppose in step three, you find the error at this five position and you find that this is the one.

301
00:25:14,040 --> 00:25:19,040
 In step three, this is the one that give you the smallest error.

302
00:25:19,040 --> 00:25:25,040
 So now if the central position is the one that give you the smallest error, that means you have a stronger confidence.

303
00:25:25,040 --> 00:25:29,040
 Right, the minimal is probably somewhere nearby already.

304
00:25:29,040 --> 00:25:33,040
 So therefore in the case, you can start to reduce the search width.

305
00:25:33,040 --> 00:25:40,040
 Okay, if the current position, central position is the one that give you the smallest error, then you can reduce the search width.

306
00:25:40,040 --> 00:25:43,040
 Right, so the search width previously is two.

307
00:25:43,040 --> 00:25:46,040
 Now if you reduce by half, it becomes one.

308
00:25:46,040 --> 00:25:51,040
 So once it becomes one, right, that means we are quite sure we are close to the minimal already.

309
00:25:51,040 --> 00:25:56,040
 So once the search width is one, then what we'll do is we'll check the nine position.

310
00:25:56,040 --> 00:25:59,040
 Okay, so let me just repeat.

311
00:25:59,040 --> 00:26:03,040
 In step three, we check this five point one, two, three, four, five.

312
00:26:03,040 --> 00:26:10,040
 Okay, and if the central position is the one that give you the smallest error, then we'll reduce the search width by half.

313
00:26:10,040 --> 00:26:14,040
 So now we'll be reduced from two to one.

314
00:26:14,040 --> 00:26:19,040
 Okay, when it's one, then instead of checking five point, we'll check all the nine points now.

315
00:26:19,040 --> 00:26:23,040
 So we'll check this one, two, three, four, five, six, seven, eight, nine.

316
00:26:23,040 --> 00:26:28,040
 All right, suppose out of this nine position, this is the position that give you the smallest error.

317
00:26:28,040 --> 00:26:34,040
 Okay, then now this is our estimated kind of position, right, the smallest error.

318
00:26:34,040 --> 00:26:37,040
 So our motion factor now will be from here to here.

319
00:26:37,040 --> 00:26:39,040
 Okay, so this is our motion factor.

320
00:26:39,040 --> 00:26:41,040
 Okay, so this is one scenario.

321
00:26:41,040 --> 00:26:43,040
 The second scenario is like this.

322
00:26:43,040 --> 00:26:45,040
 Right, suppose we look at the second scenario here.

323
00:26:45,040 --> 00:26:49,040
 Right, okay, so for this scenario, suppose we start from the beginning.

324
00:26:49,040 --> 00:26:55,040
 In step one, we are going to check, right, this five position, one, two, three, four, five.

325
00:26:55,040 --> 00:27:01,040
 Suppose out of this five position, okay, the position that give you the smallest error is at this position.

326
00:27:01,040 --> 00:27:05,040
 Okay, right, then what we are going to do is that standard at this position,

327
00:27:05,040 --> 00:27:09,040
 we are going to find the smallest error at this five position now.

328
00:27:09,040 --> 00:27:13,040
 So now we're going to look at step two now, one, two, three, four, five.

329
00:27:13,040 --> 00:27:18,040
 Okay, right, so you can see in this step two here, we do not reduce the search width

330
00:27:18,040 --> 00:27:21,040
 because the minima is not the central position.

331
00:27:21,040 --> 00:27:23,040
 So we check this one, two, three, four, five.

332
00:27:23,040 --> 00:27:27,040
 Right, suppose out of this five position, this is the position that give you the smallest error.

333
00:27:27,040 --> 00:27:30,040
 So now we are going to be standard at this position now.

334
00:27:30,040 --> 00:27:33,040
 Again, we keep the same search width.

335
00:27:33,040 --> 00:27:37,040
 Okay, so we check step three now is one, two, three, four, five.

336
00:27:37,040 --> 00:27:39,040
 We check this five position.

337
00:27:39,040 --> 00:27:46,040
 Okay, suppose out of this five positions here now, right, the position that give you the smallest error is this position.

338
00:27:46,040 --> 00:27:52,040
 So once you reach this position here, because you are reaching the border or boundary already.

339
00:27:52,040 --> 00:27:58,040
 So once you reach the border, you know that there's not much space for you to further move.

340
00:27:58,040 --> 00:28:04,040
 So another condition that you reduce the search width is when you reach the boundary.

341
00:28:04,040 --> 00:28:11,040
 So once you reach this boundary here now, you reduce the search width because you know you're near the edge already.

342
00:28:11,040 --> 00:28:15,040
 Right, so if you reduce the search width previously, it's two, now it becomes one.

343
00:28:15,040 --> 00:28:22,040
 So once one, we'll try to check, you know, supposedly the nine point one, two, three, four, five, six, eight, seven, nine.

344
00:28:22,040 --> 00:28:26,040
 But this three point is outside the search window, so there's no need to search it.

345
00:28:26,040 --> 00:28:29,040
 So therefore you only need to search this six points here.

346
00:28:29,040 --> 00:28:34,040
 But suppose out of these six points here, this is the one that give you the smallest error.

347
00:28:34,040 --> 00:28:40,040
 Okay, then our motion factor now will be interpreted as defined by this particular error.

348
00:28:40,040 --> 00:28:43,040
 Okay, so this is our motion factor.

349
00:28:43,040 --> 00:28:47,040
 So this approach is known as a 2D logarithm search.

350
00:28:47,040 --> 00:28:50,040
 So why is it called 2D logarithm search?

351
00:28:50,040 --> 00:28:56,040
 Because you can see the search width, right, when central position is the local minima,

352
00:28:56,040 --> 00:29:01,040
 or when you reach the edge, right, it's the local minima, then you divide by two.

353
00:29:01,040 --> 00:29:07,040
 Right, so that means in cases sometimes you divide by two, divide by two, divide by two.

354
00:29:07,040 --> 00:29:11,040
 So if you keep dividing by two, it's actually a logarithm function.

355
00:29:11,040 --> 00:29:15,040
 So therefore it's known as the 2D logarithm search.

356
00:29:15,040 --> 00:29:24,040
 So now if you compare full search, three step search, and the 2D logarithm search, right,

357
00:29:24,040 --> 00:29:29,040
 so which one is the fastest?

358
00:29:29,040 --> 00:29:33,040
 So which one is the fastest?

359
00:29:33,040 --> 00:29:37,040
 We have full search, three step search, 2D logarithm search.

360
00:29:37,040 --> 00:29:47,040
 Which one is the fastest in terms of performing motion estimation?

361
00:29:47,040 --> 00:29:50,040
 Here's a mumbling but I'm not too sure.

362
00:29:50,040 --> 00:29:57,040
 But who thinks it's a full search, the fastest, who thinks it's a full search?

363
00:29:57,040 --> 00:30:01,040
 Right, okay, who thinks it's a three step search?

364
00:30:01,040 --> 00:30:06,040
 Okay, who thinks it's a 2D logarithm search?

365
00:30:06,040 --> 00:30:09,040
 Okay, actually the answer is a three step search.

366
00:30:09,040 --> 00:30:14,040
 Because three step search every time you reduce a search width by half,

367
00:30:14,040 --> 00:30:19,040
 and you will definitely complete it after three steps, you will not go any further.

368
00:30:19,040 --> 00:30:25,040
 So therefore three step search is the fastest, followed by 2D logarithm search,

369
00:30:25,040 --> 00:30:28,040
 followed by full search.

370
00:30:28,040 --> 00:30:30,040
 That means full search is the slowest.

371
00:30:30,040 --> 00:30:34,040
 Now in terms of accuracy, which one is the most accurate?

372
00:30:34,040 --> 00:30:41,040
 Full search definitely is the most accurate, followed by 2D logarithm, followed by three step.

373
00:30:41,040 --> 00:30:44,040
 So therefore up to a certain extent you can kind of think about it,

374
00:30:44,040 --> 00:30:52,040
 2D logarithm search is a trade-off in terms of accuracy and speed between full search and the three step search.

375
00:30:52,040 --> 00:30:56,040
 Okay, so this slide here describes the process of 2D logarithm search.

376
00:30:56,040 --> 00:31:00,040
 So earlier I already explained to you, so let's just go through it quickly.

377
00:31:00,040 --> 00:31:05,040
 So in step one, you're going to search the five points for the minimum prediction error.

378
00:31:05,040 --> 00:31:11,040
 As we mentioned, center at the found position, once you've found the position,

379
00:31:11,040 --> 00:31:20,040
 if this position is near the central position, or if it is located at the border, then you'll reduce the search width.

380
00:31:20,040 --> 00:31:26,040
 Otherwise, you will still keep the original search width.

381
00:31:26,040 --> 00:31:32,040
 And afterwards, if you find that the search window is not three by three yet,

382
00:31:32,040 --> 00:31:36,040
 then you continue to search the five points, as I mentioned to you before.

383
00:31:36,040 --> 00:31:43,040
 But if you find that the search window now is already three by three, then you will check all the nine positions, since you are almost there already.

384
00:31:43,040 --> 00:31:46,040
 So you check the nine positions for the minimum error.

385
00:31:46,040 --> 00:31:53,040
 And then the one that you found would be the return position, which is your estimated motion factor.

386
00:31:53,040 --> 00:31:59,040
 So in terms of speed, it's a trade-off between full search and three step search.

387
00:31:59,040 --> 00:32:07,040
 In terms of accuracy, it's also in between full search and three step search, as what we have explained earlier.

388
00:32:07,040 --> 00:32:14,040
 On top of those methods, actually, people continue to develop different methods in the past.

389
00:32:14,040 --> 00:32:19,040
 So another well-known method that we have is known as the hierarchical search here.

390
00:32:19,040 --> 00:32:23,040
 So a common hierarchical search as a tree level.

391
00:32:23,040 --> 00:32:27,040
 So for a tree level hierarchical search, it can be shown like this here.

392
00:32:27,040 --> 00:32:34,040
 So first of all, you have an image. You let it go through a down sampling by a factor of two.

393
00:32:34,040 --> 00:32:39,040
 So down sampling means that you do a low pass filtering, and afterwards you sample the value.

394
00:32:39,040 --> 00:32:46,040
 So you reduce this particular image by a factor of two, both horizontally as well as vertically.

395
00:32:46,040 --> 00:32:54,040
 So we perform a down sampling here, and afterwards we perform a down sampling by a factor of two, so your image will become smaller and smaller.

396
00:32:54,040 --> 00:33:01,040
 So once you obtain a smaller image, we call this level zero, level one, and level two.

397
00:33:01,040 --> 00:33:09,040
 So once you have this smallest image, we can perform motion estimation on this lowest resolution image.

398
00:33:09,040 --> 00:33:13,040
 So we can proceed to perform motion estimation on this smallest image.

399
00:33:13,040 --> 00:33:22,040
 So once you obtain the estimated motion factor, so this is a rough motion factor because it's based on the small image.

400
00:33:22,040 --> 00:33:32,040
 So based on this initial estimated motion factor, what you combine the analysis with the larger image to refine your motion factor.

401
00:33:32,040 --> 00:33:45,040
 And then once you obtain a slightly better motion factor, you move up, and then you combine it with the larger image here to further refine your motion factor to obtain your final factors here.

402
00:33:45,040 --> 00:33:48,040
 So this is the ideas of our hierarchical search.

403
00:33:48,040 --> 00:33:54,040
 You perform your motion estimation from the lowest resolution image.

404
00:33:54,040 --> 00:33:57,040
 So the logic is quite simple.

405
00:33:57,040 --> 00:34:04,040
 If your lowest resolution image is much smaller, that means you can find your motion factor much faster.

406
00:34:04,040 --> 00:34:10,040
 And afterwards you move it back up to further refine your motion factor.

407
00:34:10,040 --> 00:34:12,040
 So that's the basic idea.

408
00:34:12,040 --> 00:34:15,040
 So let's look at the description.

409
00:34:15,040 --> 00:34:20,040
 So for hierarchical search, search can benefit from a hierarchical or multi-resolution approach.

410
00:34:20,040 --> 00:34:26,040
 So you can see this is different hierarchy or different resolution.

411
00:34:26,040 --> 00:34:30,040
 So it's a hierarchical or multi-resolution approach here.

412
00:34:30,040 --> 00:34:41,040
 So the initial estimate of the motion factor can be obtained from an image with a low, much reduced resolution, the smallest resolution image.

413
00:34:41,040 --> 00:34:48,040
 So that the corresponding macro block size is smaller and your search window is also smaller.

414
00:34:48,040 --> 00:34:52,040
 So you can find your motion factor much faster.

415
00:34:52,040 --> 00:34:57,040
 Right, and afterwards you propagate back up, works to further refine your motion factor.

416
00:34:57,040 --> 00:35:04,040
 So all in all, what it means is that your number of operations can be reduced quite significantly using this hierarchical search.

417
00:35:04,040 --> 00:35:10,040
 So this is another approach of performing motion estimation.

418
00:35:11,040 --> 00:35:15,040
 Okay, so now we have completed about this motion estimation.

419
00:35:15,040 --> 00:35:24,040
 So next we are going to look at a few different iterations on this video compression standards.

420
00:35:24,040 --> 00:35:31,040
 Right, okay, so we are going to look at the history and milestones of different video compression standards.

421
00:35:31,040 --> 00:35:39,040
 So as I explained in one of the earlier lectures, the way we are going to do this about this video compression is that

422
00:35:39,040 --> 00:35:46,040
 we are going to be focusing our attention on one earlier important video compression standard, which is the MPEG-1.

423
00:35:46,040 --> 00:35:53,040
 And afterwards, moving from MPEG-1, we are going to look at subsequent standard and see what is the increment

424
00:35:53,040 --> 00:35:56,040
 or what are the things as proposed to further improve it.

425
00:35:56,040 --> 00:36:05,040
 So this is the approach we are going to use rather than trying to study each individual video compression standard independently.

426
00:36:05,040 --> 00:36:11,040
 Right, so the reason is because number one is that there are many different video compression standards.

427
00:36:11,040 --> 00:36:17,040
 And a lot of them is actually a small improvement with respect to the previous iteration.

428
00:36:17,040 --> 00:36:26,040
 So therefore, if we introduce each standard one by itself fully, after a while all of you just can get very bored

429
00:36:26,040 --> 00:36:30,040
 because there's lots of repetition and also there are lots of detail.

430
00:36:30,040 --> 00:36:37,040
 Okay, so therefore the way we are going to approach this video compression standard from now on works is we are going to introduce MPEG-1

431
00:36:37,040 --> 00:36:44,040
 and afterwards we are going to introduce improvement across the subsequent standards.

432
00:36:44,040 --> 00:36:50,040
 Right, so therefore in order to do that, we'll do a quick history right off the different video compression standards.

433
00:36:50,040 --> 00:36:56,040
 Right, okay, so what are some key video coding standardization organizations?

434
00:36:56,040 --> 00:37:01,040
 So what are the NTPs or the organization that perform this video compression?

435
00:37:01,040 --> 00:37:05,040
 So it turns out that there are a few organizations.

436
00:37:05,040 --> 00:37:09,040
 The first one is IEC, then you have the ITU and ISO.

437
00:37:09,040 --> 00:37:17,040
 So this ISO and IEC, they create a particular group called Moving Picture Expert Group or MPEG.

438
00:37:17,040 --> 00:37:24,040
 Right, so therefore this particular organization or group, working group is the one that publish the MPEG standards.

439
00:37:24,040 --> 00:37:29,040
 Right, so you have a series of MPEG standards, they are all published by this working group.

440
00:37:29,040 --> 00:37:32,040
 Okay, and afterwards you have the ITU.

441
00:37:32,040 --> 00:37:38,040
 ITU actually publish H.26X series, for example 261 263.

442
00:37:38,040 --> 00:37:41,040
 Right, so these are the standard published by ITU.

443
00:37:41,040 --> 00:37:53,040
 Right, and this ITUT actually some also work together with ISO and IEC to publish some common standard, for example, H.262, 264, 265, 266.

444
00:37:53,040 --> 00:38:01,040
 Right, so these are the few kind of important NTPs that develop the compression standards.

445
00:38:01,040 --> 00:38:03,040
 Okay, so these three NTPs here.

446
00:38:03,040 --> 00:38:11,040
 So IEC, no need to memorize but just for your information, is stand for International Electro-Tanical Commission.

447
00:38:11,040 --> 00:38:19,040
 ITU is International Telecommunication Union and ISO is International Organization for Standardizations here.

448
00:38:19,040 --> 00:38:25,040
 Right, so IEC is mainly, you know, their target area is actually on electrical engineering.

449
00:38:25,040 --> 00:38:34,040
 ITU is mainly on wireless communication and ISO is focusing on some industrial products, okay, commercial products.

450
00:38:34,040 --> 00:38:42,040
 Okay, so these are three basic NTP that develops lots of the video compression standards.

451
00:38:42,040 --> 00:38:48,040
 Okay, so next let's look at a quick summary of different video compression standards that we have.

452
00:38:48,040 --> 00:38:52,040
 Okay, so the first one is ISO and IEC as we mentioned.

453
00:38:52,040 --> 00:39:00,040
 Right, so these two NTP, they develop this MPEG working group that develop different MPEG standards.

454
00:39:00,040 --> 00:39:04,040
 So it started in much earlier years, so we have MPEG one.

455
00:39:04,040 --> 00:39:08,040
 Okay, and afterwards we have this MPEG two.

456
00:39:08,040 --> 00:39:10,040
 Right, you can see this MPEG two.

457
00:39:10,040 --> 00:39:17,040
 So MPEG two is actually a joint collaboration between ISO, IEC and ITUT here.

458
00:39:17,040 --> 00:39:19,040
 That's why you can see it's sitting on this line.

459
00:39:19,040 --> 00:39:22,040
 So this standard is generally developed between these two groups here.

460
00:39:22,040 --> 00:39:25,040
 Okay, MPEG two, and afterwards you have the MPEG four.

461
00:39:25,040 --> 00:39:27,040
 Okay, MPEG four.

462
00:39:27,040 --> 00:39:32,040
 Right, and then afterwards you have this particular advanced video coding.

463
00:39:32,040 --> 00:39:35,040
 Right, or sometimes it's known as AVC here.

464
00:39:35,040 --> 00:39:38,040
 Right, so this again, jointly developed by them.

465
00:39:38,040 --> 00:39:42,040
 Okay, and afterwards we have the high efficient video coding.

466
00:39:42,040 --> 00:39:47,040
 Okay, again jointly developed, and then the versatile video coding, which is jointly developed.

467
00:39:47,040 --> 00:39:53,040
 Alright, so these are a few important standards that ISO, IEC is involved.

468
00:39:53,040 --> 00:39:57,040
 Right, so the next big organization is ITUT.

469
00:39:57,040 --> 00:40:04,040
 Right, so you have the first early video compression standard, which is the H.120, not so important.

470
00:40:04,040 --> 00:40:07,040
 Okay, and then the more important one is the H.261.

471
00:40:07,040 --> 00:40:14,040
 Okay, and afterwards this one here, MPEG two is also known as H.262.

472
00:40:14,040 --> 00:40:17,040
 So this is the standard that is jointly developed.

473
00:40:17,040 --> 00:40:21,040
 And then you have a H.263 plus and plus plus.

474
00:40:21,040 --> 00:40:23,040
 So there's a few different versions here.

475
00:40:23,040 --> 00:40:25,040
 Okay, and afterwards H.264.

476
00:40:25,040 --> 00:40:32,040
 So 264 is jointly developed, right, it's also known as the AVC advanced video coding.

477
00:40:32,040 --> 00:40:36,040
 And afterwards 265, it's known as the high efficiency video coding,

478
00:40:36,040 --> 00:40:40,040
 and 266, which is the versatile video coding.

479
00:40:40,040 --> 00:40:49,040
 Right, so after this slide, actually if you keep listening about this H.26x series or MPEG series,

480
00:40:49,040 --> 00:40:54,040
 at least you have some idea roughly where it belongs to and who developed it.

481
00:40:54,040 --> 00:40:59,040
 So another important thing to take note of is that you can see, as the time progressed,

482
00:40:59,040 --> 00:41:04,040
 the resolutions of the images or the video start to increase as well,

483
00:41:04,040 --> 00:41:11,040
 starting from standard definition to high definition, 4K, and then do 8K, right, and higher.

484
00:41:11,040 --> 00:41:15,040
 Right, there's also some other numbers here.

485
00:41:15,040 --> 00:41:18,040
 So these are the official kind of a documentation number,

486
00:41:18,040 --> 00:41:21,040
 given to these respective standards here.

487
00:41:21,040 --> 00:41:24,040
 So therefore, some standards, there's many different ways you can call it.

488
00:41:24,040 --> 00:41:28,040
 So this slide captures all those information.

489
00:41:29,040 --> 00:41:37,040
 Right, okay, so next we are going to look at some of the important summary of different video compression standards.

490
00:41:37,040 --> 00:41:41,040
 Right, okay, so we will try to only highlight the most important aspects.

491
00:41:41,040 --> 00:41:47,040
 Some secondary details actually will not cover it, because each of these standards is actually the size of a book.

492
00:41:47,040 --> 00:41:55,040
 So therefore, we'll only focus on the most important aspects and understanding of how video compression standard works.

493
00:41:55,040 --> 00:42:02,040
 And then once you move to the next standard, what is the improvement that has been proposed over the previous method?

494
00:42:02,040 --> 00:42:04,040
 Okay, so let's start with our MPEG one.

495
00:42:04,040 --> 00:42:09,040
 So MPEG one was developed in 1993, right, 1993, many years ago.

496
00:42:09,040 --> 00:42:16,040
 Initially, it was developed for video and audio storage on CD-ROM, okay, for CD-ROM application.

497
00:42:16,040 --> 00:42:18,040
 Right, it supports progressive scanning.

498
00:42:18,040 --> 00:42:21,040
 So if you remember, it scans all the lines, okay.

499
00:42:21,040 --> 00:42:29,040
 Right, and then the color scheme that you use is the YUV, right, the chroma subsampling 420 format.

500
00:42:29,040 --> 00:42:38,040
 Okay, and the resolution, the size of the image you look at is what is known as a CIF resolution or video size.

501
00:42:38,040 --> 00:42:43,040
 CIF stands for common intermediate format or common interchange format.

502
00:42:43,040 --> 00:42:47,040
 And the resolution is actually 352 by 288.

503
00:42:47,040 --> 00:42:54,040
 So you can see because this is a standard development years ago, so the video that you can compress is actually very small.

504
00:42:54,040 --> 00:43:01,040
 Because in the past, when you want to transmit a video, either over the bandwidth or stored, right, it's very expensive.

505
00:43:01,040 --> 00:43:05,040
 Okay, right, that's why it can only handle small images here.

506
00:43:05,040 --> 00:43:14,040
 Right, and for MPEG one, it has the GOP structures of I, frame, P-frame and B-frame, what we have studied in previous lecture.

507
00:43:14,040 --> 00:43:16,040
 Okay, so that's MPEG one.

508
00:43:16,040 --> 00:43:18,040
 So next MPEG two.

509
00:43:18,040 --> 00:43:22,040
 So MPEG two of course you can expect is an improvement over MPEG one.

510
00:43:22,040 --> 00:43:25,040
 So it was standardized in 1995.

511
00:43:25,040 --> 00:43:31,040
 Right, so for MPEG two, initially it's targeting to support applications such as DVD.

512
00:43:31,040 --> 00:43:38,040
 So DVD maybe your generation doesn't watch it that often, but your parent's generation definitely watch this DVD.

513
00:43:38,040 --> 00:43:46,040
 So initially it was a target for DVD, no standard definition TV and high definition TV program.

514
00:43:46,040 --> 00:43:52,040
 Okay, you can support this 420 and 422 from our sub-sampling.

515
00:43:52,040 --> 00:43:55,040
 So this sampling we have discussed in last lecture.

516
00:43:55,040 --> 00:43:58,040
 You can support interlaced and progressive scan.

517
00:43:58,040 --> 00:43:59,040
 So it's a bit more flexible.

518
00:43:59,040 --> 00:44:03,040
 You can actually support the progressive scan, you scan all the lines or interlaced.

519
00:44:03,040 --> 00:44:07,040
 If you remember, you scan the top view, followed by the bottom view.

520
00:44:07,040 --> 00:44:09,040
 Right, so it's a bit more flexible.

521
00:44:09,040 --> 00:44:15,040
 And also it introduced these ideas of profile and level for various capabilities.

522
00:44:15,040 --> 00:44:21,040
 So this profile and level, once we study MPEG two, we are going to introduce a little bit more detail.

523
00:44:21,040 --> 00:44:29,040
 But pretty much is that when it comes to MPEG four, initially there's many different applications with different quality expectations.

524
00:44:29,040 --> 00:44:41,040
 For example, you have some video with low resolution and then you have some video such as a movie or film that has a high expectation.

525
00:44:41,040 --> 00:44:49,040
 So you define different levels and profile to cater for different application with different expectation on the quality.

526
00:44:49,040 --> 00:44:56,040
 So for different quality, right, in terms of the size of the image, the bit rate, the requirement is different.

527
00:44:56,040 --> 00:44:59,040
 So you cater for this different need.

528
00:44:59,040 --> 00:45:02,040
 So that's the idea of different profile and level.

529
00:45:02,040 --> 00:45:06,040
 So when we study about MPEG two, we'll talk a little bit more about it.

530
00:45:06,040 --> 00:45:08,040
 And then you also support this scalable coding.

531
00:45:08,040 --> 00:45:12,040
 So scalable coding is also what we are going to study in MPEG two.

532
00:45:12,040 --> 00:45:17,040
 But pretty much at high level, that means you divide the video into two types.

533
00:45:17,040 --> 00:45:21,040
 One is a base layer, the other is enhancement layer.

534
00:45:21,040 --> 00:45:29,040
 So the base layer would capture the most basic quality and enhancement layer, as the name suggests,

535
00:45:29,040 --> 00:45:32,040
 it provides enhancement or improvement.

536
00:45:32,040 --> 00:45:34,040
 It provides better quality video.

537
00:45:34,040 --> 00:45:37,040
 So therefore you have the base layer as well as the enhancement layer.

538
00:45:37,040 --> 00:45:39,040
 So it's scalable.

539
00:45:39,040 --> 00:45:44,040
 You can either transmit as a base layer or base layer plus enhancement layer.

540
00:45:44,040 --> 00:45:46,040
 So therefore you can scale it.

541
00:45:46,040 --> 00:45:50,040
 That's what it's named by a scalable coding here.

542
00:45:51,040 --> 00:45:53,040
 Okay, then let's continue on.

543
00:45:53,040 --> 00:45:57,040
 And afterwards we have the MPEG four part two.

544
00:45:57,040 --> 00:46:01,040
 So MPEG four part two is standardized in 1999.

545
00:46:01,040 --> 00:46:05,040
 So it can support low bit rate video.

546
00:46:05,040 --> 00:46:14,040
 So one of the important aspects of this MPEG four part two is that it supports object-based or content-based coding.

547
00:46:14,040 --> 00:46:18,040
 So later on when we come to MPEG four, we'll see what's the difference.

548
00:46:18,040 --> 00:46:25,040
 So you have already studied in MPEG one, what we do is that we take a frame, we partition it into different macro blocks.

549
00:46:25,040 --> 00:46:30,040
 So this for MPEG one MPEG two is a block base, a block base approach.

550
00:46:30,040 --> 00:46:36,040
 But for MPEG four, it tries to define different objects in a video.

551
00:46:36,040 --> 00:46:42,040
 And then it tries to encode this performance compression based on the object.

552
00:46:42,040 --> 00:46:46,040
 So therefore it's an object-based coding scheme.

553
00:46:47,040 --> 00:46:54,040
 So you will try to identify the foreground and the background and then you try to encode the objects accordingly.

554
00:46:54,040 --> 00:47:02,040
 And also another thing is that it can encode synthetic video and audio such as the animation.

555
00:47:02,040 --> 00:47:04,040
 So this is the MPEG four.

556
00:47:04,040 --> 00:47:11,040
 But this MPEG four part two is not a dominant video compression standard as compared to the next one.

557
00:47:11,040 --> 00:47:15,040
 So the next one is called advanced video coding or MPEG four part ten.

558
00:47:15,040 --> 00:47:23,040
 So from the compression perspective, this MPEG four part ten or AVC advanced video coding is a more important one.

559
00:47:23,040 --> 00:47:31,040
 Actually now there's many of the videos that you download from the internet actually belonging to this H.264.

560
00:47:31,040 --> 00:47:34,040
 So this is also known as the H.264.

561
00:47:34,040 --> 00:47:39,040
 So it's standardized in 2003 and the name is called advanced video coding.

562
00:47:39,040 --> 00:47:42,040
 So sometimes this will create a little bit of confusion.

563
00:47:43,040 --> 00:47:46,040
 So the more important one is this one, part ten.

564
00:47:48,040 --> 00:47:50,040
 So it's also known as advanced video coding.

565
00:47:50,040 --> 00:47:53,040
 It's also known as H.264.

566
00:47:53,040 --> 00:47:56,040
 So this is a very important standard.

567
00:47:56,040 --> 00:47:59,040
 So it offers improvement.

568
00:47:59,040 --> 00:48:04,040
 One of the reasons why it's important is because as compared to the previous standards,

569
00:48:04,040 --> 00:48:11,040
 a lot of the previous standards from MPEG one, MPEG two, H.261, 262, 263,

570
00:48:11,040 --> 00:48:13,040
 the improvement is more incremental.

571
00:48:13,040 --> 00:48:16,040
 That means the improvement is a little bit by a little bit.

572
00:48:16,040 --> 00:48:18,040
 But MPEG four actually is quite a big job.

573
00:48:18,040 --> 00:48:20,040
 So that's why it's more important.

574
00:48:20,040 --> 00:48:27,040
 So some of the improvement that it has suggested is that it uses what is known as for example the integer transform.

575
00:48:27,040 --> 00:48:32,040
 So early on in last lecture we see that MPEG one use DCT.

576
00:48:32,040 --> 00:48:36,040
 But for MPEG this H.264, it uses integer transform.

577
00:48:36,040 --> 00:48:40,040
 It also uses a variable block size motion compensation.

578
00:48:40,040 --> 00:48:47,040
 So MPEG one and two, the block size that you have is a macro block size.

579
00:48:47,040 --> 00:48:52,040
 But for this H.264, the block size is variable.

580
00:48:52,040 --> 00:48:54,040
 You can have a variable block size compensation.

581
00:48:54,040 --> 00:48:58,040
 It also uses the directional spatial prediction.

582
00:48:58,040 --> 00:49:06,040
 For the intraframe coding, instead of partition each of the blocks independently and encoded just like JPEG,

583
00:49:06,040 --> 00:49:10,040
 it uses the surrounding pixel to predict the value.

584
00:49:10,040 --> 00:49:14,040
 So at this stage I will just share with you some high level idea.

585
00:49:14,040 --> 00:49:18,040
 Later on once we come to each of the parts we will explain a little bit more in detail.

586
00:49:18,040 --> 00:49:21,040
 So this is just a high level introduction.

587
00:49:21,040 --> 00:49:30,040
 So it uses neighboring pixels to help you to predict, to do the prediction in the intraframe coding here.

588
00:49:30,040 --> 00:49:34,040
 And then it also performs in-loop deblocking filtering here.

589
00:49:34,040 --> 00:49:40,040
 So this part means that, right, because for a lot of this video compression standard,

590
00:49:40,040 --> 00:49:45,040
 it's based on this idea given a frame you partitioned into many different blocks.

591
00:49:45,040 --> 00:49:51,040
 So for each of the blocks, because when you perform the motion estimation, you get a prediction error,

592
00:49:51,040 --> 00:49:54,040
 you can kind of imagine between this block and the next block,

593
00:49:54,040 --> 00:49:58,040
 sometimes the border or the boundary is not so smooth, right?

594
00:49:58,040 --> 00:50:00,040
 It's not so smooth.

595
00:50:00,040 --> 00:50:04,040
 So therefore this particular standard, it tries to propose some filtering process

596
00:50:04,040 --> 00:50:10,040
 to make sure that the boundary, the blocking effect is being removed or elevated.

597
00:50:10,040 --> 00:50:16,040
 So that's why it's called the deblocking filter here.

598
00:50:16,040 --> 00:50:20,040
 Right, okay, so we cover some of the basis summary of the impact standards.

599
00:50:20,040 --> 00:50:23,040
 So next is the H.26X series.

600
00:50:23,040 --> 00:50:28,040
 So we have the first 261, right, so developed in 88.

601
00:50:28,040 --> 00:50:35,040
 So initially it's meant for video conferencing, so low bit rate, fast compression.

602
00:50:35,040 --> 00:50:42,040
 So the video resolution that it supports is CIF that we have just mentioned early on for MPEC1,

603
00:50:42,040 --> 00:50:47,040
 and quarter CIF, so quarter CIF means one quarter of it.

604
00:50:47,040 --> 00:50:53,040
 Okay, so therefore the resolution is very small, and it's at 420 chroma subsumpting.

605
00:50:53,040 --> 00:50:55,040
 Right, so it uses a block-based hybrid coding.

606
00:50:55,040 --> 00:50:59,040
 So block-based means that we partition the frame into two different macro blocks.

607
00:50:59,040 --> 00:51:01,040
 So that's called block-based.

608
00:51:01,040 --> 00:51:06,040
 And hybrid means that you have the intra frame as well as interframe.

609
00:51:06,040 --> 00:51:12,040
 Right, some frame is encoded independently, some frame is encoded using interframe.

610
00:51:12,040 --> 00:51:14,040
 So some intraframe, some interframe.

611
00:51:14,040 --> 00:51:17,040
 So therefore it's known as the hybrid coding.

612
00:51:17,040 --> 00:51:22,040
 Okay, and then the motion compensation is at pixel level.

613
00:51:22,040 --> 00:51:25,040
 Okay, pixel level motion compensation.

614
00:51:25,040 --> 00:51:32,040
 That means when you perform the motion compensation, the motion factor that you have is at pixel level.

615
00:51:32,040 --> 00:51:39,040
 Okay, right, and then afterwards, Hitchcock 262, right, so this one is the MPEC2 standard.

616
00:51:39,040 --> 00:51:42,040
 So it's also known as the MPEC2 standard, right.

617
00:51:42,040 --> 00:51:44,040
 So it introduced this B-frame here.

618
00:51:44,040 --> 00:51:48,040
 261, it does not have B-frame, it only has I-frame and P-frame.

619
00:51:48,040 --> 00:51:53,040
 But for 262, actually, the improvement is that it also introduced B-frame.

620
00:51:53,040 --> 00:51:57,040
 Okay, right, so it also supports interlaced video.

621
00:51:57,040 --> 00:51:59,040
 Okay, nice.

622
00:51:59,040 --> 00:52:03,040
 And then 263 and 263 plus and plus plus, you can kind of imagine,

623
00:52:03,040 --> 00:52:06,040
 is the improvement over the earliest standards.

624
00:52:06,040 --> 00:52:10,040
 So it was developed in 1996 and 98, okay.

625
00:52:10,040 --> 00:52:17,040
 Offered improvement over 261, a low bit rate because it's still mainly for video conferencing.

626
00:52:17,040 --> 00:52:24,040
 So low bit rate, fast video communication application.

627
00:52:24,040 --> 00:52:26,040
 Right, and then let's continue.

628
00:52:26,040 --> 00:52:30,040
 264, so earlier we mentioned this is the important one.

629
00:52:30,040 --> 00:52:32,040
 So developed in 2003.

630
00:52:32,040 --> 00:52:38,040
 Right, so anyway, this is the same as, just now we mentioned about ABC, so they are the same.

631
00:52:38,040 --> 00:52:42,040
 Right, okay, support video on different domain, internet computer, right.

632
00:52:42,040 --> 00:52:46,040
 Okay, so it offers much improvement compared to 263.

633
00:52:46,040 --> 00:52:51,040
 Right, so earlier on, just now under the M-Pack, ABC will also mention that

634
00:52:51,040 --> 00:52:56,040
 it introduced integer transform to handle some of the issue for DCT.

635
00:52:56,040 --> 00:53:01,040
 Right, okay, so it improved motion compensation using the variable block size.

636
00:53:01,040 --> 00:53:03,040
 Right, it also supports multiple reference rate.

637
00:53:03,040 --> 00:53:09,040
 So later on when we study 264, we'll look at this a little bit more closely.

638
00:53:09,040 --> 00:53:14,040
 And also just now we have discussed, it introduced this in-look, the blocking filter

639
00:53:14,040 --> 00:53:18,040
 to remove this artifact that occurred at the boundary.

640
00:53:18,040 --> 00:53:22,040
 Right, to reduce the block artifacts there.

641
00:53:22,040 --> 00:53:27,040
 Okay, so this is a very important standard as I mentioned because most of the video nowadays

642
00:53:27,040 --> 00:53:32,040
 if you download is likely actually H.264 M-Pack 4 video.

643
00:53:32,040 --> 00:53:37,040
 Right, okay, after that there's actually some subsequent improvement.

644
00:53:37,040 --> 00:53:44,040
 Right, so the next improvement is H.265 also known as the high efficiency video coding.

645
00:53:44,040 --> 00:53:47,040
 Right, developed in 2013.

646
00:53:47,040 --> 00:53:53,040
 Right, okay, so in terms of these 265s and 264s again is that incremental improvement.

647
00:53:53,040 --> 00:53:59,040
 Okay, so in terms of performance it's similar to 264 but they have some additional improvement.

648
00:53:59,040 --> 00:54:03,040
 Mainly it's that support higher resolution video, higher frame rate.

649
00:54:03,040 --> 00:54:07,040
 Okay, so in terms of the prediction mode, they have more flexibility.

650
00:54:07,040 --> 00:54:09,040
 Right, and also the block size.

651
00:54:09,040 --> 00:54:12,040
 Okay, they just increase the flexibility.

652
00:54:12,040 --> 00:54:16,040
 Right, okay, so better kind of the blocking filter.

653
00:54:16,040 --> 00:54:18,040
 Right, it also supports parallel processing.

654
00:54:18,040 --> 00:54:21,040
 Okay, so it's more efficient than H.264.

655
00:54:21,040 --> 00:54:23,040
 Right, in terms of the bit rate saving.

656
00:54:23,040 --> 00:54:29,040
 So in short 265 is that incremental improvement over 264.

657
00:54:29,040 --> 00:54:35,040
 Right, so in addition to just now what we mentioned, right, this ITU, ISO and IEC,

658
00:54:35,040 --> 00:54:40,040
 there's also some other more independent video coding standards in recent years.

659
00:54:40,040 --> 00:54:45,040
 Right, so specifically for example we have this VP8 and VP9 here.

660
00:54:45,040 --> 00:54:50,040
 So VP8 is actually an open source and video compression standard.

661
00:54:50,040 --> 00:54:53,040
 Right, so their main target is for VAT video.

662
00:54:53,040 --> 00:54:57,040
 Right, so for VAT video with 420 chroma subsampling,

663
00:54:57,040 --> 00:55:01,040
 8-bit color depth progresses scan at 4K resolution.

664
00:55:01,040 --> 00:55:06,040
 Right, so you can see that the motion factor is actually 1 over 4 pixels and 1 over 8 pixels.

665
00:55:06,040 --> 00:55:13,040
 So what it means is that, right, so you may be thinking how do you obtain 1 over 4 or 1 over 8 pixels.

666
00:55:13,040 --> 00:55:18,040
 So what it means is that in the reference frame, okay, so in the reference frame,

667
00:55:18,040 --> 00:55:21,040
 so right in the reference frame initially you have some pixel value.

668
00:55:21,040 --> 00:55:25,040
 For example, these are the pixel value, these are the pixel value, these are the pixel value.

669
00:55:25,040 --> 00:55:31,040
 So at the search grid you may have this pixel, this pixel, this pixel, this pixel, this pixel, this pixel.

670
00:55:31,040 --> 00:55:39,040
 But actually between these two pixels you can do some interpolation to estimate what are some likely value in between.

671
00:55:39,040 --> 00:55:44,040
 Right, so even though these are some integer level pixel value, right, for example this 4.

672
00:55:44,040 --> 00:55:49,040
 Right, these two pixel value, these two pixel values exist in your reference frame.

673
00:55:49,040 --> 00:55:58,040
 But for these two pixel value actually in between you can also use some interpolation method to roughly guess what are the value in between.

674
00:55:58,040 --> 00:56:05,040
 So if you try to do that, you are trying to, you know, in between this pixel value you try to estimate what are some pixel value,

675
00:56:05,040 --> 00:56:07,040
 interpolated pixel value between.

676
00:56:07,040 --> 00:56:12,040
 Then when you perform motion estimation, not only do you, can you check respect to this pixel,

677
00:56:12,040 --> 00:56:16,040
 you can also check respect to this interpolated position.

678
00:56:16,040 --> 00:56:19,040
 So that's why it's known as no.

679
00:56:19,040 --> 00:56:28,040
 But if you do that, that means you can now estimate the non-motion factor up to for example half a pixel, quarter of a pixel or even one-eighth of a pixel.

680
00:56:28,040 --> 00:56:30,040
 Right, okay, so this is the idea.

681
00:56:30,040 --> 00:56:36,040
 Right, so this motion factor can have accuracy up to one over four of the pixel or one over eight of the pixel.

682
00:56:36,040 --> 00:56:40,040
 It's because in the reference frame you perform interpolation.

683
00:56:40,040 --> 00:56:42,040
 Okay.

684
00:56:42,040 --> 00:56:48,040
 Right, okay, so it also, you can see a lot of ideas is actually common across many different standard.

685
00:56:48,040 --> 00:56:53,040
 You also use this in-loop deblocking filter to remove the blockiness.

686
00:56:53,040 --> 00:57:02,040
 Okay, VB9 is improvement over VPA, alright, support up to 8K now as compared to 4K and higher frame rate, okay.

687
00:57:02,040 --> 00:57:08,040
 And it uses a super block, alright, 32 by 32 or 64 by 64.

688
00:57:08,040 --> 00:57:12,040
 So you move across higher and higher resolution video.

689
00:57:12,040 --> 00:57:18,040
 Initially the video is very small, alright, but now the video becomes bigger and bigger, right.

690
00:57:18,040 --> 00:57:22,040
 So therefore your macro block size also start to increase.

691
00:57:22,040 --> 00:57:31,040
 Initially it's 16 by 16, right, and divided into four blocks of 8 by 8 and one C V, one C R.

692
00:57:31,040 --> 00:57:35,040
 So because now the image resolution, the video resolution become much bigger,

693
00:57:35,040 --> 00:57:39,040
 the block size they are going to use also need to adjust accordingly.

694
00:57:39,040 --> 00:57:45,040
 So that's why the block size now also become bigger, right, okay.

695
00:57:45,040 --> 00:57:51,040
 So this will then exploit the correlation similar to the previous macro block idea.

696
00:57:51,040 --> 00:58:00,040
 Okay, and then it can also perform interpolation for motion compensation with the 8-tap filter to achieve one over eight pixel accuracy.

697
00:58:00,040 --> 00:58:02,040
 So this is the same as before, right.

698
00:58:02,040 --> 00:58:06,040
 If you have the integer pixel, you try to do the interpolation in the reference frame.

699
00:58:06,040 --> 00:58:15,040
 So once you can get the interpolated values at the reference frame, that means your motion estimation now can be up to sub-pixel accuracy, okay.

700
00:58:15,040 --> 00:58:17,040
 So that's the idea.

701
00:58:17,040 --> 00:58:27,040
 Right, okay, so yeah, we pretty much go through a quick overview of different standard.

702
00:58:27,040 --> 00:58:31,040
 Next we are going to look into the MPEG standard now.

703
00:58:31,040 --> 00:58:35,040
 Right, okay, so as I mentioned when you come to this video compression standard now,

704
00:58:35,040 --> 00:58:43,040
 a lot of them is a bit more flat, right, because there are lots of kind of information that is required.

705
00:58:43,040 --> 00:58:53,040
 So that's why I already tried to cut down on some of the detail, but will only focus on the high level understanding of how this video compression standard works.

706
00:58:53,040 --> 00:58:58,040
 So next we are going to look at a number of important MPEG standards now.

707
00:58:58,040 --> 00:59:02,040
 Right, so the first one we are going to look at is the MPEG 1 standard.

708
00:59:02,040 --> 00:59:07,040
 Right, so, okay, so a quick overview of MPEG 1 standard first.

709
00:59:07,040 --> 00:59:15,040
 So developed by ISO IEC in 92, right, so it's a standard for law C video and audio compression.

710
00:59:15,040 --> 00:59:19,040
 So why is it law C for MPEG standard?

711
00:59:19,040 --> 00:59:26,040
 Why is it a law C video compression standard?

712
00:59:26,040 --> 00:59:34,040
 Anyone roughly guess why is MPEG a law C video compression standard?

713
00:59:34,040 --> 00:59:44,040
 Sorry?

714
00:59:44,040 --> 00:59:54,040
 Yeah, and in JPEG which is the step that give rise to information loss?

715
00:59:54,040 --> 00:59:57,040
 So that is actually a very good answer.

716
00:59:57,040 --> 01:00:04,040
 So the reason why it's law C is because actually this MPEG 1 standard is highly motivated by JPEG.

717
01:00:04,040 --> 01:00:07,040
 So a lot of the techniques they use is very similar to JPEG.

718
01:00:07,040 --> 01:00:11,040
 And if you remember in JPEG there was a step which is a quantization.

719
01:00:11,040 --> 01:00:18,040
 So when you use a quantization, that means you do an element by element quantization, some information is loss.

720
01:00:18,040 --> 01:00:21,040
 So therefore it's a law C compression.

721
01:00:21,040 --> 01:00:28,040
 So initially it's targeting at very low bit rate, about 1.5 megabits per second.

722
01:00:28,040 --> 01:00:31,040
 It is targeting for CD storage.

723
01:00:31,040 --> 01:00:39,040
 So at the time there's a particular very well known commercial product called VCD, video CD here.

724
01:00:39,040 --> 01:00:46,040
 So it's an extension of MPEG as well as the H.264 because these are the two standard developed before it.

725
01:00:47,040 --> 01:00:53,040
 It supports progressive scanning and the picture resolution it can support is actually very low resolution.

726
01:00:53,040 --> 01:01:00,040
 So you can see the resolution it can support is very low at 30 or 25 lem per second.

727
01:01:00,040 --> 01:01:05,040
 It uses a 420 chroma subsamplifier that we have studied.

728
01:01:05,040 --> 01:01:11,040
 So for MPEG 1 actually it can be, it's also officially known as this particular standard.

729
01:01:11,040 --> 01:01:14,040
 So for those of you if you are keen to Google you can Google it.

730
01:01:14,040 --> 01:01:18,040
 Again I can tell you it's actually a book, there are lots of information there.

731
01:01:18,040 --> 01:01:24,040
 So it can be divided into five different parts, system, video, audio, confirmance and reference software.

732
01:01:24,040 --> 01:01:29,040
 So anyway as I mentioned this is for your information, there's no need to remember.

733
01:01:29,040 --> 01:01:33,040
 So we are only going to focus on the important aspects.

734
01:01:33,040 --> 01:01:38,040
 In particularly we are going to focus on the video aspects of this MPEG 1 standard.

735
01:01:39,040 --> 01:01:43,040
 So what is the limitations of the MPEG 1 standard?

736
01:01:43,040 --> 01:01:47,040
 Number one is it supports only progressive scanning.

737
01:01:47,040 --> 01:01:54,040
 More importantly from our current viewpoint the picture quality is very low

738
01:01:54,040 --> 01:01:57,040
 and the compression ratio is also not so good.

739
01:01:57,040 --> 01:01:59,040
 So these are some limitations of MPEG 1.

740
01:01:59,040 --> 01:02:07,040
 So I can just give some difficulty, I managed to find an MPEG 1 video.

741
01:02:07,040 --> 01:02:13,040
 So this MPEG 1 actually a commercial product that is arising out of MPEG 1 is VCD.

742
01:02:13,040 --> 01:02:22,040
 I'm not sure at home any of you still keep this VCD or DVD or Blu-ray?

743
01:02:22,040 --> 01:02:29,040
 So if some of you still keep it the earlier version that you have is the VCD.

744
01:02:29,040 --> 01:02:35,040
 So I remember when I was, I cannot remember, it's probably in high school or in pre-university.

745
01:02:35,040 --> 01:02:39,040
 At the time if you want to watch a movie, you need two discs.

746
01:02:39,040 --> 01:02:43,040
 So one movie usually have two discs and then you can watch it.

747
01:02:43,040 --> 01:02:51,040
 So this is the examples of the VCD and VCD is actually a commercial product arising from MPEG 1.

748
01:02:51,040 --> 01:02:54,040
 So there's actually some product coming out of it.

749
01:02:54,040 --> 01:02:58,040
 So this is the video qualities of MPEG 1.

750
01:03:05,040 --> 01:03:10,040
 Anything you can do, I can do better. I can do anything better than you.

751
01:03:10,040 --> 01:03:13,040
 No you can't. Yes I can. No you can't. Yes I can.

752
01:03:13,040 --> 01:03:15,040
 Okay probably no need to continue so much.

753
01:03:15,040 --> 01:03:19,040
 But you can see the quality is actually quite low by the current standard.

754
01:03:19,040 --> 01:03:26,040
 But I remember during my time I was still very happily watching it because before VCD what we have to do is the cassette.

755
01:03:26,040 --> 01:03:33,040
 And this cassette I remember when I was young, we have to cycle from, usually because renting cassette is very expensive,

756
01:03:33,040 --> 01:03:35,040
 you try to borrow from your friends.

757
01:03:35,040 --> 01:03:40,040
 Usually your friends' mom rented some cassette for the Hong Kong drama series.

758
01:03:40,040 --> 01:03:45,040
 After they finish then we quickly cycle over to their house to get those cassette.

759
01:03:45,040 --> 01:03:52,040
 So this VCD is still considered as improvement as compared to the video cassette in earlier years.

760
01:03:53,040 --> 01:03:59,040
 Okay so next we are going to look at this MPEG 1 a little bit more in detail now.

761
01:03:59,040 --> 01:04:04,040
 Specifically we are going to look at how do we compress i-frame, p-frame and b-frame here.

762
01:04:10,040 --> 01:04:15,040
 Right okay so if you remember for MPEG 1 we have the i-frame, we have the p-frame and then we have the b-frame here.

763
01:04:15,040 --> 01:04:16,040
 So there's a tree-frame type.

764
01:04:16,040 --> 01:04:21,040
 So we are going to see how do we perform compression for each of these particular frame types here.

765
01:04:21,040 --> 01:04:24,040
 So the first frame type that we have is known as i-frame.

766
01:04:24,040 --> 01:04:29,040
 So if you recall i-frame is intra-coded frame, you encode it independently.

767
01:04:29,040 --> 01:04:30,040
 So just like JPEG.

768
01:04:30,040 --> 01:04:33,040
 So therefore it's exactly like the JPEG.

769
01:04:33,040 --> 01:04:37,040
 So how it works is that if you have a frame which is designated as i-frame,

770
01:04:37,040 --> 01:04:44,040
 if you want to encode it what you do is you take this frame, you partition it into numerous macro blocks.

771
01:04:45,040 --> 01:04:48,040
 Okay partition it into numerous macro blocks.

772
01:04:48,040 --> 01:04:52,040
 And for each of the blocks you let it go through the DCT transform,

773
01:04:52,040 --> 01:04:56,040
 quantization, and entropy encoding and then the format.

774
01:04:56,040 --> 01:05:00,040
 And now afterwards you get the bit-stream for your i-frame.

775
01:05:00,040 --> 01:05:06,040
 So for i-frame encoding it's just exactly like the JPEG standard that we have studied before.

776
01:05:06,040 --> 01:05:10,040
 Okay right so next we are going to look at the p-frame.

777
01:05:10,040 --> 01:05:15,040
 So if you remember p-frame means that if now this frame has been designated as p-frame,

778
01:05:15,040 --> 01:05:17,040
 how do we do the compression?

779
01:05:17,040 --> 01:05:23,040
 So for p-frame what we are going to do is that we are going to partition this frame into different macro blocks.

780
01:05:23,040 --> 01:05:29,040
 Okay and then for each of the blocks we are going to perform motion, estimation, and compensation.

781
01:05:29,040 --> 01:05:34,040
 Okay right so therefore let's look at for example this current frame.

782
01:05:34,040 --> 01:05:40,040
 Suppose this current frame is designated as a p-frame already and we want to compress this frame.

783
01:05:40,040 --> 01:05:43,040
 So what we do is we partition it into numerous macro blocks.

784
01:05:43,040 --> 01:05:48,040
 Okay and then we are going to compress each of these macro blocks one at a time.

785
01:05:48,040 --> 01:05:52,040
 Right suppose this is the current macro block that we want to compress now.

786
01:05:52,040 --> 01:05:58,040
 So therefore center at this particular current macro block we refer to the previous reference frame.

787
01:05:58,040 --> 01:06:00,040
 Suppose this is the previous reference frame now.

788
01:06:00,040 --> 01:06:06,040
 So in the previous reference frame you are going to center at this position, you are going to define a search window.

789
01:06:06,040 --> 01:06:13,040
 Okay and then based on what we have studied before the different motion estimation method that you decide to use.

790
01:06:13,040 --> 01:06:22,040
 Suppose you use one of the estimation method, you find the positions of the best matched block or the position with the smallest error is here.

791
01:06:22,040 --> 01:06:28,040
 Okay then we can see the relative offset from this corner and to this corner this is your motion factor now.

792
01:06:28,040 --> 01:06:31,040
 Okay so that means you can get the motion factor.

793
01:06:31,040 --> 01:06:38,040
 Once you have the motion factor you have this is your target macro block, this is your predicted macro block.

794
01:06:38,040 --> 01:06:45,040
 So these macro blocks are a little bit different so you need to take their difference, their error you encode it, just like JPEG.

795
01:06:45,040 --> 01:06:48,040
 So therefore the idea would be like this.

796
01:06:48,040 --> 01:06:56,040
 Okay once you get the motion factor, you let it go through a differential coding and then after this half-month coding you encode it.

797
01:06:56,040 --> 01:07:02,040
 Why do we want to let it pass through differential coding for the motion factor?

798
01:07:02,040 --> 01:07:07,040
 You can see this motion factor that you have found here, we let it go through a differential coding.

799
01:07:07,040 --> 01:07:18,040
 Why do we let it go through a differential coding?

800
01:07:18,040 --> 01:07:25,040
 We know that when we use differential coding that means the consecutive values are usually very similar right?

801
01:07:25,040 --> 01:07:34,040
 So what it means is that when you say this motion factor it means that the motion factor for this block and the motion factor for the next block.

802
01:07:34,040 --> 01:07:40,040
 So the motion factor for this block suppose this kind of macro block suppose the motion factor is here.

803
01:07:40,040 --> 01:07:45,040
 So the next macro block, do you think the motion factor likely is going to be similar?

804
01:07:45,040 --> 01:07:50,040
 Likely is the case because if you think about your hand here, you partitioned two numerous macro blocks.

805
01:07:50,040 --> 01:07:59,040
 If this block actually moves like in this position, likely the flowing macro block, the motion factor is likely going to be very similar.

806
01:07:59,040 --> 01:08:10,040
 So because for two consecutive macro blocks, the motion factor likely going to be very similar, therefore a suitable way for you to encode it will be differential coding.

807
01:08:10,040 --> 01:08:12,040
 You simply take the difference.

808
01:08:12,040 --> 01:08:18,040
 So after differential coding because some pattern will occur more often than the others, so let it go through the half-month coding.

809
01:08:18,040 --> 01:08:20,040
 So this is the motion factor.

810
01:08:20,040 --> 01:08:30,040
 So the next branch is that this one is the best match block, sorry your target block minus the best match block or the reference block.

811
01:08:30,040 --> 01:08:31,040
 You get the error.

812
01:08:31,040 --> 01:08:40,040
 So this error will go through the DCT transform quantization, right, entropy encoding including ground length coding and the half-month coding to encode it.

813
01:08:40,040 --> 01:08:43,040
 So this part is just similar to the JPEG that you have.

814
01:08:43,040 --> 01:08:47,040
 So that's a basic idea for how to compress the P-frame.

815
01:08:47,040 --> 01:08:55,040
 So next look at flow chart to see how do we perform compression for P-frame here.

816
01:08:55,040 --> 01:08:57,040
 So this is the more systematic way.

817
01:08:57,040 --> 01:09:01,040
 So first of all, suppose this is the current P-frame you want to encode it.

818
01:09:01,040 --> 01:09:05,040
 So this P-frame will be partitioned into numerous macro blocks.

819
01:09:05,040 --> 01:09:09,040
 Departition this frame into numerous macro blocks.

820
01:09:09,040 --> 01:09:14,040
 Okay, suppose now we need to compress this macro block one at a time.

821
01:09:14,040 --> 01:09:18,040
 Now suppose we are considering this current macro block that we want to compress now.

822
01:09:18,040 --> 01:09:28,040
 So this current macro block that we want to compress, what we need to do is, this current macro block that we want to compress, we need to compare with, we need to perform what?

823
01:09:28,040 --> 01:09:35,040
 Motion, estimation and compensation, respect to the previous reference frame.

824
01:09:35,040 --> 01:09:44,040
 Okay, so therefore we need to take this current macro block, we compare to the previous reference frame, which can be an I-frame or P-frame.

825
01:09:44,040 --> 01:09:49,040
 And then we perform the motion estimation to find where is the motion factor.

826
01:09:49,040 --> 01:09:56,040
 So once you can find the motion factor, that means we can also do the motion compensation to find the error.

827
01:09:56,040 --> 01:10:00,040
 Okay, so this current macro block you compare to the reference frame.

828
01:10:00,040 --> 01:10:04,040
 Let it go through motion estimation, right, then you'll get the motion factor.

829
01:10:04,040 --> 01:10:11,040
 This motion factor as discussed earlier will go through differential coding and actually half-moon coding and a format.

830
01:10:11,040 --> 01:10:14,040
 Okay, if you want you can also encode the address.

831
01:10:14,040 --> 01:10:24,040
 Okay, so once you find the motion factor, that means you know your current macro block, you're relative offset, you take the difference between them, you'll get the error.

832
01:10:24,040 --> 01:10:31,040
 So this is the difference computation that will calculate the error, okay, the prediction error here.

833
01:10:31,040 --> 01:10:38,040
 So this error now will go through forward transform quantization, entropy encoding and format.

834
01:10:38,040 --> 01:10:41,040
 Okay, so just like what we have shown in the previous slide.

835
01:10:41,040 --> 01:10:44,040
 There's only a small detail here.

836
01:10:44,040 --> 01:10:48,040
 The small detail is that you notice that there's this particular branch here.

837
01:10:48,040 --> 01:10:56,040
 All right, so this is after the error, we forward transform quantization, okay, and so on.

838
01:10:56,040 --> 01:10:58,040
 But there's this particular branch here.

839
01:10:58,040 --> 01:11:11,040
 So this branch here means that once you get quantized, you actually perform the quantization and you perform inverse DCT to reconstruct this reference frame.

840
01:11:11,040 --> 01:11:19,040
 So can anyone tell why do we need to have a particular branch or in other words, at the encoder end?

841
01:11:19,040 --> 01:11:21,040
 This is the encoder end.

842
01:11:21,040 --> 01:11:26,040
 At the encoder side, why do we need to reconstruct this reference frame?

843
01:11:26,040 --> 01:11:31,040
 You can see this reference frame is obtained from the reconstruction.

844
01:11:31,040 --> 01:11:35,040
 It's not from the original frame.

845
01:11:35,040 --> 01:11:42,040
 Yeah, because actually we have the original frame, right, at the encoder side we have the original information.

846
01:11:42,040 --> 01:11:53,040
 We can take the original frame if we want to, yeah, but actually we choose not to, but rather we actually reconstruct this reference frame through this process here.

847
01:11:53,040 --> 01:11:55,040
 Anyone, can anyone guess why do we need to reconstruct this reference frame?

848
01:11:55,040 --> 01:12:08,040
 Guess, why do we want to do that?

849
01:12:08,040 --> 01:12:17,040
 Okay, so the reason why we want to do this here is because we are trying to simulate the situation we are going to encounter at the decoder.

850
01:12:17,040 --> 01:12:26,040
 So at the encoder, right, this is where we compress a video, later on we are going to transmit this video to the decoder side.

851
01:12:26,040 --> 01:12:30,040
 This decoder is going to reconstruct the video.

852
01:12:30,040 --> 01:12:35,040
 At the decoder side, you don't have access to the original video.

853
01:12:35,040 --> 01:12:38,040
 What you have access is to reconstruct the video.

854
01:12:38,040 --> 01:12:43,040
 So at the decoder, you can only reconstruct your reference frame.

855
01:12:43,040 --> 01:12:56,040
 Okay, so therefore to mimic, right, to make sure that we experience the same condition at the decoder side, at the encoder we also do the reconstructions here.

856
01:12:56,040 --> 01:13:02,040
 So long story short, the reason why we need to have this is that, right, for this reference frame, we reconstruct it.

857
01:13:02,040 --> 01:13:07,040
 The reason is because at the decoder, this is how we are going to construct the reference frame.

858
01:13:07,040 --> 01:13:13,040
 So we want to make sure that the condition at the decoder and at the encoders are the same.

859
01:13:13,040 --> 01:13:17,040
 Okay, right, so that's the basic idea.

860
01:13:17,040 --> 01:13:23,040
 Right, okay, so with that explanation, these are some short descriptions here.

861
01:13:23,040 --> 01:13:27,040
 So for the p-frame encoding, so these are what we already discussed.

862
01:13:27,040 --> 01:13:32,040
 Right, so we perform motion estimation and compensation for each macro block in your target frame.

863
01:13:32,040 --> 01:13:40,040
 Okay, so the each macro block in the target frame is compared to the preceding reference frame, which can be either I or P-frame.

864
01:13:40,040 --> 01:13:44,040
 So this reference frame sometimes is also known as the anchor frame.

865
01:13:44,040 --> 01:13:51,040
 Okay, so for each macro block, a search is performed using the motion estimation, right, center at the search window.

866
01:13:51,040 --> 01:13:56,040
 Right, so you can choose any motion estimation method that you want or that we have studied.

867
01:13:56,040 --> 01:14:01,040
 So a match is found if the sum of absolute difference, right, is less than a threshold.

868
01:14:01,040 --> 01:14:06,040
 But if the error is less than a threshold, then we say that, right, a match has been found.

869
01:14:06,040 --> 01:14:09,040
 But if a match is found, two parameters are determined.

870
01:14:09,040 --> 01:14:12,040
 One is a motion factor, the other is a prediction error.

871
01:14:12,040 --> 01:14:18,040
 Right, the error between those two reference block and the predicted block here.

872
01:14:18,040 --> 01:14:28,040
 Okay, so motion factor measures the offset or the displacement factor between location of target macro block with the location of the best match block in the reference frame.

873
01:14:28,040 --> 01:14:30,040
 So we've talked about it many times already.

874
01:14:30,040 --> 01:14:32,040
 This is our position of current macro block.

875
01:14:32,040 --> 01:14:36,040
 If this is the offset, okay, this is roughly offset here.

876
01:14:36,040 --> 01:14:40,040
 So this is the offset, which is known as the motion factor.

877
01:14:40,040 --> 01:14:45,040
 Right, so because these two blocks are different, so we calculate the difference and this is known as prediction error.

878
01:14:45,040 --> 01:14:51,040
 So prediction error measures the difference, right, and this difference is in the form of a matrix.

879
01:14:51,040 --> 01:14:55,040
 Okay, difference between the target macro block and the best match block.

880
01:14:55,040 --> 01:15:01,040
 Right, okay, so afterwards the motion factor I encoded using differential coding and after that, staff member coding.

881
01:15:01,040 --> 01:15:03,040
 Right, this we have already explained.

882
01:15:03,040 --> 01:15:09,040
 And the error or the prediction, right, okay, are encoded using same step as iframe.

883
01:15:09,040 --> 01:15:11,040
 Right, previous slide we already explained.

884
01:15:11,040 --> 01:15:17,040
 So sometimes if the error is so big, if the error is so big, then we consider no match has been found already.

885
01:15:17,040 --> 01:15:25,040
 Right, so if no match is found, then the macro block is encoded independently, just similar to iframe.

886
01:15:25,040 --> 01:15:35,040
 If your current macro block in your target frame and the best match block, if the error is so big, sometimes we can define it as no match has been found.

887
01:15:35,040 --> 01:15:38,040
 Right, if no match has been found, then this is the macro block.

888
01:15:38,040 --> 01:15:44,040
 You just encode it independently, just like a JPEG.

889
01:15:44,040 --> 01:15:48,040
 Okay, so we have studied about pframe already.

890
01:15:48,040 --> 01:15:50,040
 Next, let's move on to bframe.

891
01:15:50,040 --> 01:16:01,040
 So for bframe, if you remember, right, so for this current frame that you want to encode, suppose it's a bframe, you compare to the previous reference frame and the following reference frame.

892
01:16:01,040 --> 01:16:04,040
 So it's a bi-directionally coded frame.

893
01:16:04,040 --> 01:16:08,040
 So why do you want to refer to two frames to do the coding?

894
01:16:08,040 --> 01:16:14,040
 So in other words, why do we need to have bframe which perform a bi-direction search?

895
01:16:14,040 --> 01:16:19,040
 Okay, so this particular visualization will give you intuition.

896
01:16:19,040 --> 01:16:22,040
 Why do we need to perform bi-direction search?

897
01:16:22,040 --> 01:16:26,040
 So suppose this is your current target frame that you want to compress.

898
01:16:26,040 --> 01:16:28,040
 So this is a bframe, right?

899
01:16:28,040 --> 01:16:30,040
 You partition and do many different macro blocks.

900
01:16:30,040 --> 01:16:34,040
 Suppose this is the current block that you want to encode, okay?

901
01:16:34,040 --> 01:16:36,040
 And this is your previous reference frame.

902
01:16:36,040 --> 01:16:38,040
 This is your following reference frame, for example.

903
01:16:38,040 --> 01:16:51,040
 So if you just want to, if you just rely on the previous reference frame, just like pframe here, you can see for this macro block here, if you try to look through the previous reference frame, you cannot find a good match, right?

904
01:16:51,040 --> 01:16:55,040
 Because this block here, this part has been obscured already.

905
01:16:55,040 --> 01:17:03,040
 So if you just simply rely on one reference frame, like in pframe, then your result will not be so good.

906
01:17:03,040 --> 01:17:09,040
 But on the other hand, if you check both the previous reference frame as well as the following reference frame,

907
01:17:09,040 --> 01:17:14,040
 but you can see that maybe this ball initially was coming here and then bounced off or something.

908
01:17:14,040 --> 01:17:22,040
 But you can see now, if you look at the following reference frame, the chances of you finding a best match block is higher now, right?

909
01:17:22,040 --> 01:17:25,040
 I mean, the intuition is quite easy because they are relying on two reference frames.

910
01:17:25,040 --> 01:17:29,040
 The chances of you finding a best match block is much higher.

911
01:17:29,040 --> 01:17:37,040
 Right, so therefore you have a higher chances of finding a match or this macro block if you compare to the previous and the following reference frame.

912
01:17:37,040 --> 01:17:45,040
 Okay, so yeah, this example just showed that the macro block containing a ball in the target frame cannot find a good match in the previous frame.

913
01:17:45,040 --> 01:17:47,040
 Alright, simple visualization.

914
01:17:47,040 --> 01:17:51,040
 Okay, it can be obtained from the previous, the following reference frame.

915
01:17:51,040 --> 01:17:57,040
 So long story short, what it means is that in some cases, relying on two reference frames is better.

916
01:17:57,040 --> 01:18:01,040
 That's why they introduced this bframe.

917
01:18:01,040 --> 01:18:06,040
 Okay, so how do we encode this particular bframe here?

918
01:18:06,040 --> 01:18:20,040
 So for the bframe, okay, actually, let me just not show whether some of you, whether it's good to...

919
01:18:20,040 --> 01:18:30,040
 Yeah, because I know that sometimes some of you probably do not do the revision before class, so you may have forgotten some of this point already.

920
01:18:30,040 --> 01:18:33,040
 So this is the GOP structure.

921
01:18:33,040 --> 01:18:36,040
 So this frame is encoded independently, which is iframe.

922
01:18:36,040 --> 01:18:42,040
 This frame, just now the pframe we have been explaining is we encode it with respect to the previous reference frame.

923
01:18:42,040 --> 01:18:49,040
 And now we are talking about bframe here is encoded with respect to the previous reference frame and the following reference frame.

924
01:18:49,040 --> 01:18:54,040
 Okay, so these are the three frame type, iframe, pframe and bframe we are talking about here.

925
01:18:54,040 --> 01:19:07,040
 So now we are going to talk about this bframe already.

926
01:19:07,040 --> 01:19:11,040
 Right, okay, so how do we perform bframe from high level idea is like this.

927
01:19:11,040 --> 01:19:14,040
 So suppose this is the current frame, we want to...

928
01:19:14,040 --> 01:19:17,040
 It's a bframe and we want to encode it as a bframe.

929
01:19:17,040 --> 01:19:20,040
 So what do we do? We partition it into numerous macro block,

930
01:19:20,040 --> 01:19:23,040
 and for each of the blocks we are going to encode it one at a time.

931
01:19:23,040 --> 01:19:27,040
 Suppose this is the current macro block that we want to encode.

932
01:19:27,040 --> 01:19:30,040
 So we perform motion estimation with respect to the previous frame.

933
01:19:30,040 --> 01:19:34,040
 Suppose this is the best match block and this is the motion factor.

934
01:19:34,040 --> 01:19:37,040
 And we compare with the following reference frame.

935
01:19:37,040 --> 01:19:40,040
 Suppose this is the best match block and this is the motion factor.

936
01:19:40,040 --> 01:19:46,040
 So when we want to perform this coding using bframe, right, okay.

937
01:19:46,040 --> 01:19:49,040
 So comparing this with respect to the previous reference frame,

938
01:19:49,040 --> 01:19:52,040
 we'll get one set of the result.

939
01:19:52,040 --> 01:19:55,040
 Comparing this target frame with respect to the following reference frame,

940
01:19:55,040 --> 01:19:58,040
 we'll get the second set of the result.

941
01:19:58,040 --> 01:20:02,040
 And for the third set of the result, it's going to be based on the average

942
01:20:02,040 --> 01:20:05,040
 between the previous reference frame and the following reference frame.

943
01:20:05,040 --> 01:20:07,040
 Okay, so this is the third combination.

944
01:20:07,040 --> 01:20:12,040
 So for the third combination, we are going to take this prediction

945
01:20:12,040 --> 01:20:15,040
 and this prediction, we take the average of it.

946
01:20:15,040 --> 01:20:17,040
 Okay, we take the average.

947
01:20:17,040 --> 01:20:21,040
 And afterwards, we take our macro block minus the average between these two blocks here.

948
01:20:21,040 --> 01:20:23,040
 So this will be your prediction error.

949
01:20:23,040 --> 01:20:27,040
 So this prediction error would then go through the same process of

950
01:20:27,040 --> 01:20:32,040
 DCT coding, quantization and entropy encoding to get the best result.

951
01:20:32,040 --> 01:20:38,040
 Okay, so the basic idea is just that, right, for bframe, you have three steps.

952
01:20:38,040 --> 01:20:39,040
 One is compare.

953
01:20:39,040 --> 01:20:41,040
 Suppose this is your current macro block.

954
01:20:41,040 --> 01:20:44,040
 One is with respect to the previous reference frame, set one.

955
01:20:44,040 --> 01:20:47,040
 One is with respect to the following reference frame, set two.

956
01:20:47,040 --> 01:20:49,040
 One is with respect to the average of them.

957
01:20:49,040 --> 01:20:51,040
 Therefore, you have three.

958
01:20:51,040 --> 01:20:52,040
 So now you have three.

959
01:20:52,040 --> 01:20:53,040
 Which one should you choose?

960
01:20:53,040 --> 01:20:56,040
 So you should choose the one that gives you the smallest error.

961
01:20:56,040 --> 01:20:58,040
 Okay, you have three possibilities.

962
01:20:58,040 --> 01:21:02,040
 The one that gives you the smallest error, you should choose it.

963
01:21:02,040 --> 01:21:03,040
 Right, okay.

964
01:21:03,040 --> 01:21:06,040
 So that is the high level explanation.

965
01:21:06,040 --> 01:21:12,040
 Next, let's look at the flow chart on how do we perform bframe encoding.

966
01:21:12,040 --> 01:21:15,040
 Right, so now suppose this frame is a bframe.

967
01:21:15,040 --> 01:21:18,040
 Right, so what we do is we partition it into numerous macro blocks.

968
01:21:18,040 --> 01:21:21,040
 Suppose this is the current macro block you want to encode.

969
01:21:21,040 --> 01:21:25,040
 Right, so what you'll do is that you compare with respect to the previous reference frame.

970
01:21:25,040 --> 01:21:28,040
 You let it go through the motion estimation.

971
01:21:28,040 --> 01:21:31,040
 Right, so we respect to the previous reference frame.

972
01:21:31,040 --> 01:21:33,040
 We have one motion vector.

973
01:21:33,040 --> 01:21:35,040
 Okay, that you encode.

974
01:21:35,040 --> 01:21:42,040
 Alright, respect to the previous reference frame, you have one predicted best match block.

975
01:21:42,040 --> 01:21:45,040
 You can calculate one error, one prediction error.

976
01:21:45,040 --> 01:21:46,040
 So this is the first one.

977
01:21:46,040 --> 01:21:54,040
 Okay, so yeah, and then the next one is that your current macro block you compare to the previous, the following reference frame.

978
01:21:54,040 --> 01:21:58,040
 Okay, you do the motion estimation, the motion vector you can encode it.

979
01:21:58,040 --> 01:22:03,040
 Right, so the predicted block you can calculate your error.

980
01:22:03,040 --> 01:22:04,040
 So this is the second error.

981
01:22:04,040 --> 01:22:12,040
 The third one is you take the average of the best match block in the previous and the following reference frame.

982
01:22:12,040 --> 01:22:15,040
 Just like this case, this is the third case now.

983
01:22:15,040 --> 01:22:17,040
 Right, and then you calculate your error.

984
01:22:17,040 --> 01:22:19,040
 So now you have three errors.

985
01:22:19,040 --> 01:22:20,040
 Which one should you choose?

986
01:22:20,040 --> 01:22:23,040
 You should choose the one that give you the smallest error.

987
01:22:23,040 --> 01:22:29,040
 Right, so the one that should give you the smallest error, you let it go through the DCT transform,

988
01:22:29,040 --> 01:22:33,040
 quantization, and trophy encoding and four-meter to become the b-stream.

989
01:22:33,040 --> 01:22:36,040
 So this path is to reconstruct your reference frame.

990
01:22:36,040 --> 01:22:42,040
 Okay, so the same argument as a p-frame.

991
01:22:42,040 --> 01:22:46,040
 Right, okay, so with that, now let's look at the explanation of the b-frame.

992
01:22:46,040 --> 01:22:56,040
 So for each macro block in the target frame, the motion estimation and compensations perform respect to, you know, the previous frame and the following frame.

993
01:22:56,040 --> 01:23:01,040
 Okay, so with that, you will produce two sets of motion vector and prediction error.

994
01:23:01,040 --> 01:23:04,040
 One respect to previous, one respect to following.

995
01:23:04,040 --> 01:23:07,040
 Okay, and afterwards you get the third one.

996
01:23:07,040 --> 01:23:15,040
 So the third prediction error or difference error is computed by, you know, taking the difference between your target macro block and the average,

997
01:23:15,040 --> 01:23:20,040
 means the average of the previous and the following best match block.

998
01:23:20,040 --> 01:23:22,040
 Just like what is indicated in the diagram.

999
01:23:22,040 --> 01:23:23,040
 So now you have three sets.

1000
01:23:23,040 --> 01:23:24,040
 Which one should you choose?

1001
01:23:24,040 --> 01:23:28,040
 So the set with the smallest prediction error is chosen.

1002
01:23:28,040 --> 01:23:31,040
 All right, so and this is the one that is going to be encoded.

1003
01:23:31,040 --> 01:23:36,040
 Right, like this path here.

1004
01:23:36,040 --> 01:23:46,040
 All right, okay, so we have spent some time to explain about, you know, the compression of our p-frame and b-frame.

1005
01:23:46,040 --> 01:23:48,040
 So let's look at the file size quickly.

1006
01:23:48,040 --> 01:23:54,040
 So I think this one in previous lecture, we already kind of spent a bit of time to explain.

1007
01:23:54,040 --> 01:24:00,040
 So p-frame usually is much smaller than i-frame because i-frame is encoded independently just like image.

1008
01:24:00,040 --> 01:24:02,040
 Okay, and p-frame is interframe.

1009
01:24:02,040 --> 01:24:05,040
 So p-frame, their file size is smaller than i-frame.

1010
01:24:05,040 --> 01:24:08,040
 Okay, because they make use of the temporal redundancy.

1011
01:24:08,040 --> 01:24:14,040
 So and b-frame is even smaller than p-frame because you are comparing respect to reference frame.

1012
01:24:14,040 --> 01:24:22,040
 So the chances of you finding a best match block is even higher and therefore your error is smaller and the file size will also be smaller.

1013
01:24:22,040 --> 01:24:30,040
 So therefore in terms of the compression ratio of i-frame, p-frame and b-frame here, you can see these are the typical file size.

1014
01:24:30,040 --> 01:24:37,040
 Okay, right, you can see and the compression ratio, the highest is b-frame, followed by p-frame, followed by i-frame.

1015
01:24:37,040 --> 01:24:44,040
 So for a typical GOP structure, right, the compression ratio is, you know, within the range of 20 to 30.

1016
01:24:44,040 --> 01:24:49,040
 Right, so this is a common compression ratio for MPEG1.

1017
01:24:49,040 --> 01:24:55,040
 Right, so okay, I think I still have a few more slides to go before we finish this.

1018
01:24:55,040 --> 01:25:02,040
 Right, okay, so now if you look at the MPEG1 bitstream, so the MPEG1 bitstream, first you have the video sequence, which is a sequence of frame.

1019
01:25:02,040 --> 01:25:07,040
 And this video can be organized into the different GOP structures here.

1020
01:25:07,040 --> 01:25:13,040
 Right, so if you, I just show you just now the GOP structure, you have i-frame, your p-frame and b-frame.

1021
01:25:13,040 --> 01:25:15,040
 So you have different GOP structures here.

1022
01:25:15,040 --> 01:25:20,040
 Okay, right, and afterwards each GOP structure can be divided.

1023
01:25:20,040 --> 01:25:26,040
 Right, so the GOP structure just very quickly to refresh your memory.

1024
01:25:26,040 --> 01:25:33,040
 Okay.

1025
01:25:44,040 --> 01:25:54,040
 The memory is fractured.

1026
01:25:54,040 --> 01:25:57,040
 Yeah, it cannot go too fast.

1027
01:26:25,040 --> 01:26:34,040
 Yeah, actually this one I think we have covered before, so you probably can still remember.

1028
01:26:34,040 --> 01:26:39,040
 Yeah.

1029
01:26:39,040 --> 01:26:42,040
 Yeah, okay, so this is the GOP structure.

1030
01:26:55,040 --> 01:27:04,040
 Right, okay, so you have the GOP structure, so in this GOP structure you have the i-frame, you have the p-frame and then you have the b-frame.

1031
01:27:04,040 --> 01:27:07,040
 So each of them, each of this frame is also known as a picture.

1032
01:27:07,040 --> 01:27:09,040
 So under the picture you have different slices.

1033
01:27:09,040 --> 01:27:12,040
 So one picture can be divided into different slices.

1034
01:27:12,040 --> 01:27:14,040
 Okay, so you have different slices.

1035
01:27:14,040 --> 01:27:18,040
 And in one slice you potentially have different macro block.

1036
01:27:18,040 --> 01:27:21,040
 Okay, so you have different macro block.

1037
01:27:21,040 --> 01:27:26,040
 Okay, so under one macro block if you remember we have six blocks here.

1038
01:27:26,040 --> 01:27:30,040
 Four of them is the luminance, one CB and one CR.

1039
01:27:30,040 --> 01:27:31,040
 So we have six blocks.

1040
01:27:31,040 --> 01:27:37,040
 And each of the blocks when you encode it you have the DC coding and then you have the AC which is the running coding.

1041
01:27:37,040 --> 01:27:44,040
 So this is the structures of the MPEG-1 history.

1042
01:27:44,040 --> 01:27:50,040
 Right, okay, so next we will probably just quickly go through one short exercise.

1043
01:27:50,040 --> 01:27:52,040
 Right, so this exercise is on MPEG-1.

1044
01:27:52,040 --> 01:27:57,040
 It asks you to briefly describe the purpose of chroma subsampling in MPEG-1 video compression.

1045
01:27:57,040 --> 01:28:04,040
 So can any one of you still remember what is the purpose of MPEG-1?

1046
01:28:04,040 --> 01:28:13,040
 Chroma subsampling in MPEG-1.

1047
01:28:13,040 --> 01:28:23,040
 What is the objective of chroma subsampling in MPEG-1 video compression?

1048
01:28:23,040 --> 01:28:31,040
 So the basic idea if you remember is because our eyes are not so sensitive to the chroma components or color component,

1049
01:28:31,040 --> 01:28:35,040
 therefore we only need to keep a sub-sex of the sample.

1050
01:28:35,040 --> 01:28:40,040
 Right, and we can drop some of these samples in the chroma plane.

1051
01:28:40,040 --> 01:28:48,040
 Right, so once you drop some of those samples, that means they are less simple to store, hence you can achieve compression.

1052
01:28:48,040 --> 01:28:50,040
 So that's a high-level idea.

1053
01:28:50,040 --> 01:29:00,040
 Okay, next draw a flow chart of the P-frame encoding in MPEG-1 and clear label all the key steps and then briefly explain the roles of entropy encoding.

1054
01:29:00,040 --> 01:29:09,040
 Right, so I think the diagram we just covered and the roles of the entropy encoding as we have mentioned is pretty much right to make sure that those patterns that occur more often,

1055
01:29:09,040 --> 01:29:13,040
 we use a shorter code work to represent it.

1056
01:29:13,040 --> 01:29:22,040
 So overall, the average number of bits required to represent the symbol, both the DC and the AC symbol, is lesser.

1057
01:29:22,040 --> 01:29:26,040
 Right, so that's the basic idea.

1058
01:29:26,040 --> 01:29:32,040
 So in terms of the answer, I'll again upload it to the Corsac.

1059
01:29:32,040 --> 01:29:36,040
 You can go and download it later.

1060
01:29:36,040 --> 01:29:43,040
 So therefore the purpose of chroma sub-sampling is human visual system is less sensitive to the chrominance component.

1061
01:29:43,040 --> 01:29:55,040
 Right, so that chroma sub-sampling will sample the chrominance pixel to reduce number of pixels that need to be stored and hence improving a compression efficiency because there are less pixels to represent.

1062
01:29:55,040 --> 01:29:58,040
 Right, you can download from the Corsac later.

1063
01:29:58,040 --> 01:30:07,040
 So I also share with you some of this sample answer just to let you know that in the exam when you write the answer, there's no need to write too much.

1064
01:30:07,040 --> 01:30:10,040
 Just use point form right into the point.

1065
01:30:10,040 --> 01:30:17,040
 You have to understand especially for this year, the class is very big, there's a 500 something students.

1066
01:30:17,040 --> 01:30:20,040
 I'm actually under lots of stress to do the marking.

1067
01:30:20,040 --> 01:30:31,040
 So therefore, the more quickly you can write your answer quickly in a very concise form, the faster I can mark and usually the more linear I'll give you the marks.

1068
01:30:31,040 --> 01:30:36,040
 So in short, some of these answers just give you a feel about how you can write your answer.

1069
01:30:36,040 --> 01:30:38,040
 So follow this kind of format would do.

1070
01:30:38,040 --> 01:30:41,040
 Because sometimes students would think you probably need to write a lot.

1071
01:30:41,040 --> 01:30:42,040
 Actually there's no need to.

1072
01:30:42,040 --> 01:30:44,040
 Don't overwrite.

1073
01:30:45,040 --> 01:30:47,040
 Right, so this is the first part.

1074
01:30:47,040 --> 01:30:51,040
 In the second part, the p-frame encoding is this.

1075
01:30:51,040 --> 01:30:58,040
 So the rule of entropy encoding is to use variable length coding such that more probable symbol assign short the code work.

1076
01:30:58,040 --> 01:31:02,040
 And then less probable symbol assign longer code work.

1077
01:31:02,040 --> 01:31:05,040
 So this will ensure the average number of bits per symbol will be smaller.

1078
01:31:05,040 --> 01:31:09,040
 So entropy encoding is used in coding of DC and AC code.

1079
01:31:09,040 --> 01:31:13,040
 So that's the high level message for this question.

1080
01:31:15,040 --> 01:31:19,040
 So with that, let's look at it quickly at the summary.

1081
01:31:19,040 --> 01:31:22,040
 So the summary of this M-Pack one is as follow.

1082
01:31:22,040 --> 01:31:24,040
 So there are two types of coding.

1083
01:31:24,040 --> 01:31:26,040
 One is intra-frame or iframe.

1084
01:31:26,040 --> 01:31:30,040
 So for intra-frame is based on J-Pack base approach.

1085
01:31:30,040 --> 01:31:32,040
 Next is the inter-frame.

1086
01:31:32,040 --> 01:31:35,040
 So the inter-frame, there are two type, p-frame and b-frame.

1087
01:31:35,040 --> 01:31:40,040
 So base of them is you predict the error and then you use DCT to encode the error.

1088
01:31:40,040 --> 01:31:44,040
 And also the block size that you use is fixed block size.

1089
01:31:44,040 --> 01:31:46,040
 The macro block.

1090
01:31:46,040 --> 01:31:53,040
 So we put it as fixed block size is because later on we study about H.264 and subsequent standard.

1091
01:31:53,040 --> 01:31:56,040
 You'll see that their block size sometimes is not fixed.

1092
01:31:56,040 --> 01:32:01,040
 So some of the key feature, you can either use one or two reference frame for p-frame and b-frame.

1093
01:32:01,040 --> 01:32:07,040
 Their resolution is low because it's earlier standards.

1094
01:32:07,040 --> 01:32:13,040
 Bitrate is usually low as well, about 1.5 megabits per second.

1095
01:32:13,040 --> 01:32:17,040
 Just like what we show on the VCD application.

1096
01:32:19,040 --> 01:32:22,040
 So I think we'll probably take a break now.

1097
01:32:22,040 --> 01:32:26,040
 We'll come back at 8.20 and then we'll continue with M-Pack 2.

1098
01:32:32,040 --> 01:32:40,040
 I want to ask how to define the search window size.

1099
01:32:40,040 --> 01:32:44,040
 Search window size usually depends on different standard.

1100
01:32:44,040 --> 01:32:48,040
 They will have some default number.

1101
01:32:48,040 --> 01:32:51,040
 So common value is 15.1.5.

1102
01:32:51,040 --> 01:32:53,040
 15.1.5.

1103
01:32:53,040 --> 01:32:55,040
 15.1.5.

1104
01:32:55,040 --> 01:32:57,040
 15.1.5.

1105
01:32:57,040 --> 01:32:59,040
 15.1.5.

1106
01:32:59,040 --> 01:33:01,040
 P is equal to 1.5.

1107
01:33:03,040 --> 01:33:05,040
 This is a common one.

1108
01:33:05,040 --> 01:33:11,040
 But as I mentioned, actually, because there are many, many different standards, each standard is a little bit different.

1109
01:33:11,040 --> 01:33:13,040
 So that's why there are a lot of key.

1110
01:33:13,040 --> 01:33:21,040
 So usually, the important thing is just remember the idea.

1111
01:33:21,040 --> 01:33:25,040
 If I really want to ask you the question, I'll tell you what search window we should use.

1112
01:33:25,040 --> 01:33:29,040
 Because different standards, search window is different.

1113
01:33:29,040 --> 01:33:33,040
 So I don't want the students to be bogged down with all those key.

1114
01:33:33,040 --> 01:33:34,040
 Okay.

1115
01:33:34,040 --> 01:33:45,040
 And for the first step, for example, does HL always mean the center?

1116
01:33:45,040 --> 01:33:46,040
 Center, yeah.

1117
01:33:46,040 --> 01:33:47,040
 Is HL always the center?

1118
01:33:47,040 --> 01:33:49,040
 Yeah, the first one is the center and afterwards?

1119
01:33:49,040 --> 01:33:50,040
 Half-center.

1120
01:33:50,040 --> 01:33:52,040
 Yeah, half of it.

1121
01:33:55,040 --> 01:33:58,040
 Can you talk about this symbol?

1122
01:33:58,040 --> 01:34:00,040
 I don't know.

1123
01:34:00,040 --> 01:34:01,040
 Okay.

1124
01:34:01,040 --> 01:34:04,040
 Actually, this symbol is coming from a textbook.

1125
01:34:04,040 --> 01:34:06,040
 What it means is just to take the average.

1126
01:34:06,040 --> 01:34:10,040
 This one, you get the prediction error.

1127
01:34:10,040 --> 01:34:12,040
 A prediction best match block.

1128
01:34:12,040 --> 01:34:14,040
 This one, you take the best match block.

1129
01:34:14,040 --> 01:34:16,040
 You take this block, you take the average.

1130
01:34:16,040 --> 01:34:18,040
 Oh, so this is average?

1131
01:34:18,040 --> 01:34:19,040
 Yes, yes.

1132
01:34:19,040 --> 01:34:20,040
 I don't know why the book used that.

1133
01:34:20,040 --> 01:34:24,040
 Oh, so it means this minus there is average.

1134
01:34:24,040 --> 01:34:25,040
 Yes, yes.

1135
01:34:25,040 --> 01:34:28,040
 The average of those, yeah.

1136
01:34:28,040 --> 01:34:33,040
 So I will just try to look for the six-digit number.

1137
01:34:33,040 --> 01:34:37,040
 Is it a lab?

1138
01:34:37,040 --> 01:34:40,040
 Yeah, I don't know if it's a lab.

1139
01:34:40,040 --> 01:34:41,040
 I don't know if it's a lab.

1140
01:34:41,040 --> 01:34:43,040
 I go back and I come back to work.

1141
01:34:43,040 --> 01:34:44,040
 Yesterday?

1142
01:34:44,040 --> 01:34:45,040
 Yeah.

1143
01:34:45,040 --> 01:34:47,040
 Today have you come back?

1144
01:34:47,040 --> 01:34:48,040
 Yeah.

1145
01:34:48,040 --> 01:34:53,040
 Yesterday I came back to work.

1146
01:34:53,040 --> 01:34:56,040
 Have you checked with the lab staff?

1147
01:34:56,040 --> 01:34:58,040
 I don't know.

1148
01:34:58,040 --> 01:35:02,040
 What time do you go back?

1149
01:35:02,040 --> 01:35:05,040
 Oh, can you go back?

1150
01:35:05,040 --> 01:35:08,040
 Can you go to the lab early tomorrow morning?

1151
01:35:08,040 --> 01:35:09,040
 Tomorrow morning?

1152
01:35:09,040 --> 01:35:10,040
 Yeah.

1153
01:35:10,040 --> 01:35:11,040
 Early.

1154
01:35:11,040 --> 01:35:12,040
 Yeah, I will go back.

1155
01:35:12,040 --> 01:35:15,040
 Usually they should be opening at 8.30.

1156
01:35:15,040 --> 01:35:16,040
 Okay.

1157
01:35:16,040 --> 01:35:17,040
 Tomorrow morning?

1158
01:35:17,040 --> 01:35:18,040
 Yeah, tomorrow morning.

1159
01:35:18,040 --> 01:35:19,040
 Okay.

1160
01:35:19,040 --> 01:35:23,040
 I'm just a little confused about this problem.

1161
01:35:23,040 --> 01:35:28,040
 You just mentioned that three steps will be faster than this.

1162
01:35:28,040 --> 01:35:39,040
 But under these six-digit consequence, we need to check five points at first and two

1163
01:35:39,040 --> 01:35:42,040
 points at second, five-point at third.

1164
01:35:42,040 --> 01:35:53,040
 Because first of all, between 2D logarithm search, there's a few different variations.

1165
01:35:53,040 --> 01:35:55,040
 So some is actually searching five-point.

1166
01:35:55,040 --> 01:35:58,040
 There are some who each search nine-point.

1167
01:35:58,040 --> 01:36:03,040
 But either five-point or nine-point doesn't really matter that much.

1168
01:36:03,040 --> 01:36:08,040
 What it means is that 2D logarithm search means that you keep searching and your search

1169
01:36:08,040 --> 01:36:09,040
 width will not reduce.

1170
01:36:09,040 --> 01:36:18,040
 You keep having to keep searching until your composition is a minimum or you are reaching

1171
01:36:18,040 --> 01:36:20,040
 the border only then you reduce it.

1172
01:36:20,040 --> 01:36:26,040
 So that means before this search will be reduced, there's a very good chance it has to go through.

1173
01:36:26,040 --> 01:36:29,040
 Because this particular search will be reduced small.

1174
01:36:29,040 --> 01:36:31,040
 It will be realized much larger.

1175
01:36:31,040 --> 01:36:37,040
 So there's probably going to be many, many positions before you finally reduce to three-by-three.

1176
01:36:38,040 --> 01:36:48,040
 But under 2D logarithm, will the point finally found be relatively close to the border or not close to the border?

1177
01:36:48,040 --> 01:36:49,040
 Yeah, it's possible.

1178
01:36:49,040 --> 01:36:50,040
 Yeah, it's possible.

1179
01:36:50,040 --> 01:36:54,040
 So that may be introduced on higher things.

1180
01:36:54,040 --> 01:36:56,040
 What do you mean by that?

1181
01:36:56,040 --> 01:37:07,040
 Just like a error or because you will not hit the points close to this place?

1182
01:37:07,040 --> 01:37:14,040
 The idea is like, you just roughly, how should I make this?

1183
01:37:14,040 --> 01:37:16,040
 Because you have to do a trade-off.

1184
01:37:16,040 --> 01:37:18,040
 You cannot check every single point.

1185
01:37:18,040 --> 01:37:25,040
 So the high-level inclusion is that in the beginning you randomly sample some point

1186
01:37:25,040 --> 01:37:29,040
 but you not randomly evenly sample different positions.

1187
01:37:29,040 --> 01:37:36,040
 And once you have found out this evenly sample position, if you find this is the enumer now,

1188
01:37:36,040 --> 01:37:45,040
 your assumption is that the position of the smallest error is likely going to be standard

1189
01:37:45,040 --> 01:37:47,040
 and where you find the addition.

1190
01:37:47,040 --> 01:37:52,040
 It's just like, I don't know how, you roughly get the idea.

1191
01:37:52,040 --> 01:37:59,040
 So therefore this is the basic principle and it has to be within this particular section.

1192
01:37:59,040 --> 01:38:08,040
 So therefore if you are very close to the boundary already, there's no point to continue on this.

1193
01:38:08,040 --> 01:38:11,040
 Then you have to also use your section.

1194
01:38:11,040 --> 01:38:15,040
 So it's just like a balance of the trade-off?

1195
01:38:15,040 --> 01:38:17,040
 Yes, it's always a trade-off.

1196
01:38:17,040 --> 01:38:18,040
 Okay.

1197
01:38:18,040 --> 01:38:19,040
 I'm sorry.

1198
01:38:19,040 --> 01:38:20,040
 I'm sorry.

1199
01:38:20,040 --> 01:38:21,040
 I'm sorry.

1200
01:38:21,040 --> 01:38:27,040
 I want to know how should we choose the center.

1201
01:38:27,040 --> 01:38:34,040
 Yeah, and afterwards the middle between here and the border.

1202
01:38:34,040 --> 01:38:35,040
 Oh yeah.

1203
01:38:35,040 --> 01:38:37,040
 Yeah, then you get this point here.

1204
01:38:37,040 --> 01:38:39,040
 Between here and here, the middle.

1205
01:38:39,040 --> 01:38:41,040
 Between here and here, the middle.

1206
01:38:41,040 --> 01:38:47,040
 The basic idea is that your first step, you should evenly sample all the possible positions.

1207
01:38:47,040 --> 01:38:49,040
 You know what I'm saying?

1208
01:38:49,040 --> 01:38:51,040
 Because you do not know where this is.

1209
01:38:51,040 --> 01:38:54,040
 So you want your starting point to be representative.

1210
01:38:54,040 --> 01:38:58,040
 Then you have to start with a more representative point.

1211
01:38:58,040 --> 01:39:04,040
 So the most reasonable is the middle of the line and the middle of the line.

1212
01:39:04,040 --> 01:39:07,040
 So it's the first point of the first 22?

1213
01:39:07,040 --> 01:39:08,040
 Yes, yes.

1214
01:39:08,040 --> 01:39:12,040
 Because if you don't divide it like this, you might find some more...

1215
01:39:12,040 --> 01:39:19,040
 Or the long-term point is that you start to find a more representative point.

1216
01:39:19,040 --> 01:39:24,040
 I want to know what's the last one after the boundary.

1217
01:39:24,040 --> 01:39:25,040
 Okay.

1218
01:39:25,040 --> 01:39:27,040
 It's the duty of a very long section.

1219
01:39:27,040 --> 01:39:29,040
 The section is always the same.

1220
01:39:29,040 --> 01:39:31,040
 Only two conditions can be solved.

1221
01:39:31,040 --> 01:39:35,040
 The first one is if your line is the point of the line.

1222
01:39:35,040 --> 01:39:39,040
 If the line is the point of the middle,

1223
01:39:39,040 --> 01:39:42,040
 then the minimum should be the point of the line.

1224
01:39:42,040 --> 01:39:44,040
 So you can say it.

1225
01:39:44,040 --> 01:39:46,040
 Or you have reached the boundary.

1226
01:39:46,040 --> 01:39:48,040
 Because you can't go out of the boundary.

1227
01:39:48,040 --> 01:39:50,040
 You probably know that you can't go out of the boundary.

1228
01:39:50,040 --> 01:39:54,040
 You can also set the line at that time.

1229
01:39:54,040 --> 01:39:58,040
 So how do you set the line?

1230
01:39:58,040 --> 01:40:00,040
 The length of the line.

1231
01:40:00,040 --> 01:40:05,040
 The other method is to make two points from the width.

1232
01:40:06,040 --> 01:40:11,040
 What was the example?

1233
01:40:11,040 --> 01:40:13,040
 For example, if you take an example,

1234
01:40:13,040 --> 01:40:15,040
 from the width to the width,

1235
01:40:15,040 --> 01:40:17,040
 how do you draw the line?

1236
01:40:17,040 --> 01:40:19,040
 It seems to be a bit messy.

1237
01:40:19,040 --> 01:40:20,040
 I don't know.

1238
01:40:20,040 --> 01:40:21,040
 Do you start with the line?

1239
01:40:21,040 --> 01:40:24,040
 Because you think about it from...

1240
01:40:24,040 --> 01:40:28,040
 This point is in the corresponding to the fact that there is a macro block.

1241
01:40:28,040 --> 01:40:31,040
 The middle point is the one that is located here.

1242
01:40:31,040 --> 01:40:36,040
 So this point is the point of the middle point of the macro block.

1243
01:40:36,040 --> 01:40:38,040
 So when you have checked it,

1244
01:40:38,040 --> 01:40:42,040
 the point of the point is the point of the middle point.

1245
01:40:42,040 --> 01:40:44,040
 The top point is actually a macro block.

1246
01:40:44,040 --> 01:40:49,040
 The macro block is the bottom point of the two points.

1247
01:40:49,040 --> 01:40:55,040
 So basically, the beginning is here.

1248
01:40:55,040 --> 01:40:57,040
 The middle point of the macro block is also here.

1249
01:40:57,040 --> 01:40:59,040
 You can see it here until the end.

1250
01:40:59,040 --> 01:41:02,040
 What is the process of this arrow?

1251
01:41:02,040 --> 01:41:05,040
 The process of the middle point is that you don't need to worry about it.

1252
01:41:05,040 --> 01:41:07,040
 You only need to know the last one.

1253
01:41:07,040 --> 01:41:09,040
 You know the middle point.

1254
01:41:09,040 --> 01:41:12,040
 Because the macro block is located here at the beginning.

1255
01:41:12,040 --> 01:41:14,040
 And then you can see it here at the end.

1256
01:41:14,040 --> 01:41:17,040
 So the offset is basically like this.

1257
01:41:17,040 --> 01:41:23,040
 So from the beginning to the end of the middle point,

1258
01:41:23,040 --> 01:41:26,040
 the point of the point is not needed to be counted.

1259
01:41:26,040 --> 01:41:28,040
 Why is it so...

1260
01:41:28,040 --> 01:41:31,040
 You have that one to represent you.

1261
01:41:31,040 --> 01:41:33,040
 That one is to help you.

1262
01:41:33,040 --> 01:41:38,040
 Because if you don't have the middle point to show it to you,

1263
01:41:38,040 --> 01:41:43,040
 it's easier for you to follow its first and second and third steps.

1264
01:41:43,040 --> 01:41:47,040
 That one is to help you to see the first step is here.

1265
01:41:47,040 --> 01:41:49,040
 The second step is here.

1266
01:41:49,040 --> 01:41:51,040
 You need to know what it is.

1267
01:41:51,040 --> 01:41:53,040
 I don't understand this.

1268
01:41:53,040 --> 01:41:56,040
 How do you start to choose it from the beginning?

1269
01:41:56,040 --> 01:41:59,040
 For example, in these few points,

1270
01:41:59,040 --> 01:42:03,040
 this point is the smallest.

1271
01:42:03,040 --> 01:42:05,040
 Maybe you are right.

1272
01:42:05,040 --> 01:42:08,040
 This thing is a bit misguided.

1273
01:42:08,040 --> 01:42:12,040
 If you want it, you can even say it is the smallest.

1274
01:42:12,040 --> 01:42:16,040
 If it is like this, you can not go to the arrow.

1275
01:42:16,040 --> 01:42:20,040
 So it is the third step?

1276
01:42:20,040 --> 01:42:24,040
 Basically, this point is the smallest.

1277
01:42:24,040 --> 01:42:26,040
 So the first time it comes to this point.

1278
01:42:26,040 --> 01:42:28,040
 Now, if you say this point,

1279
01:42:28,040 --> 01:42:30,040
 you can say its length.

1280
01:42:30,040 --> 01:42:32,040
 Say it is half of this point.

1281
01:42:32,040 --> 01:42:33,040
 This is the smallest.

1282
01:42:33,040 --> 01:42:34,040
 If this point is the smallest,

1283
01:42:34,040 --> 01:42:38,040
 now you are in the middle of this point.

1284
01:42:38,040 --> 01:42:40,040
 Basically, it is like this.

1285
01:42:40,040 --> 01:42:42,040
 But it doesn't have the right answer.

1286
01:42:42,040 --> 01:42:44,040
 Why is it the smallest?

1287
01:42:44,040 --> 01:42:46,040
 This is just a test.

1288
01:42:46,040 --> 01:42:52,040
 So the smallest is that you have already made the calculation.

1289
01:42:52,040 --> 01:42:54,040
 It just didn't tell you?

1290
01:42:54,040 --> 01:42:57,040
 Yes, I said this picture.

1291
01:42:57,040 --> 01:43:03,040
 Yes, so you have already calculated their total.

1292
01:43:03,040 --> 01:43:06,040
 In the picture, this is so big.

1293
01:43:06,040 --> 01:43:08,040
 Because in the M-Pyve,

1294
01:43:08,040 --> 01:43:10,040
 this is a C-Tournament.

1295
01:43:10,040 --> 01:43:13,040
 It is actually bigger.

1296
01:43:13,040 --> 01:43:15,040
 So the truth is that it is bigger.

1297
01:43:15,040 --> 01:43:19,040
 Yes, the P is usually the first step.

1298
01:43:19,040 --> 01:43:21,040
 The standard is 15.

1299
01:43:21,040 --> 01:43:26,040
 So it is T2P plus 1 is 30.

1300
01:43:26,040 --> 01:43:28,040
 Yes, the later steps are bigger.

1301
01:43:28,040 --> 01:43:32,040
 Because in learning this video conversion,

1302
01:43:32,040 --> 01:43:34,040
 there is a problem with it.

1303
01:43:34,040 --> 01:43:36,040
 There are too many versions.

1304
01:43:36,040 --> 01:43:39,040
 If you go to the past in every detail,

1305
01:43:39,040 --> 01:43:40,040
 it is very difficult in the world.

1306
01:43:40,040 --> 01:43:41,040
 No one can remember.

1307
01:43:41,040 --> 01:43:43,040
 I don't go to the next step.

1308
01:43:43,040 --> 01:43:46,040
 If you can't understand the content of the video,

1309
01:43:46,040 --> 01:43:49,040
 it is very difficult to memorize.

1310
01:43:49,040 --> 01:43:53,040
 My view is that

1311
01:43:53,040 --> 01:43:55,040
 as long as you learn what is its main point,

1312
01:43:55,040 --> 01:43:57,040
 what is its main point of view,

1313
01:43:57,040 --> 01:44:01,040
 if you want to ask from a test point of view,

1314
01:44:01,040 --> 01:44:03,040
 don't ask from a test point of view.

1315
01:44:03,040 --> 01:44:05,040
 I will tell you this.

1316
01:44:05,040 --> 01:44:11,040
 I will not let you memorize these details.

1317
01:44:11,040 --> 01:44:13,040
 Because if I can't remember them,

1318
01:44:13,040 --> 01:44:15,040
 I won't let you memorize them.

1319
01:44:15,040 --> 01:44:19,040
 In addition, from my point of view,

1320
01:44:19,040 --> 01:44:21,040
 I can't let students get too bad.

1321
01:44:21,040 --> 01:44:23,040
 Students can't get too good,

1322
01:44:23,040 --> 01:44:25,040
 and they can't get too bad.

1323
01:44:25,040 --> 01:44:26,040
 That is our problem.

1324
01:44:26,040 --> 01:44:29,040
 So it is very difficult to have the ability.

1325
01:44:29,040 --> 01:44:31,040
 If I answer all the questions in the question,

1326
01:44:31,040 --> 01:44:34,040
 the school will ask me why the students can't answer them.

1327
01:44:34,040 --> 01:44:36,040
 So like the difficult method,

1328
01:44:36,040 --> 01:44:39,040
 it is not about how to learn the details.

1329
01:44:39,040 --> 01:44:44,040
 It is about how to get closer to the understanding of the subject.

1330
01:44:44,040 --> 01:44:47,040
 So usually,

1331
01:44:47,040 --> 01:44:49,040
 if you want to answer the question,

1332
01:44:49,040 --> 01:44:51,040
 you can look at the past part of the subject.

1333
01:44:51,040 --> 01:44:52,040
 Because I can't tell you that

1334
01:44:52,040 --> 01:44:56,040
 the whole thing is probably your understanding.

1335
01:44:56,040 --> 01:44:58,040
 So you can look at the past part of the subject.

1336
01:44:58,040 --> 01:45:01,040
 There are many examples in the past.

1337
01:45:01,040 --> 01:45:03,040
 So in some cases,

1338
01:45:03,040 --> 01:45:05,040
 you can have a concept.

1339
01:45:05,040 --> 01:45:08,040
 The topic of the calculation is

1340
01:45:08,040 --> 01:45:14,040
 what the� and usually the most exact choice is.

1341
01:45:14,040 --> 01:45:16,040
 A topic that you have finished the question is

1342
01:45:16,040 --> 01:45:18,040
 How are study days determined?

1343
01:45:18,040 --> 01:45:19,040
 What is it?

1344
01:45:19,040 --> 01:45:20,040
 The past few months are correct?

1345
01:45:20,040 --> 01:45:22,040
 Wow,

1346
01:45:22,040 --> 01:45:24,040
 I am 모羟able on you have done a lot.

1347
01:45:24,040 --> 01:45:26,040
 I have too many years right now.

1348
01:45:26,040 --> 01:45:28,040
 Is it similar to what you said?

1349
01:45:28,040 --> 01:45:31,040
 They are more than before.

1350
01:45:31,040 --> 01:45:33,080
 This is the past

1351
01:45:33,080 --> 01:45:35,040
 The past few months.

1352
01:45:35,040 --> 01:45:36,040
 So

1353
01:45:36,040 --> 01:45:37,040
 we can see that

1354
01:45:37,040 --> 01:45:39,040
 So what is the purpose of this?

1355
01:45:39,040 --> 01:45:41,040
 What is the purpose of this?

1356
01:45:41,040 --> 01:45:43,040
 So you will say,

1357
01:45:43,040 --> 01:45:45,040
 oh, this is how it works.

1358
01:45:45,040 --> 01:45:47,040
 Thank you.

1359
01:45:47,040 --> 01:45:49,040
 Okay.

1360
01:45:49,040 --> 01:45:51,040
 We are talking about the motion estimation

1361
01:45:51,040 --> 01:45:53,040
 and prediction arrow.

1362
01:45:53,040 --> 01:45:55,040
 In fact, it is two blocks.

1363
01:45:55,040 --> 01:45:57,040
 We do the check for each pixel.

1364
01:45:57,040 --> 01:45:59,040
 And then we do the check

1365
01:45:59,040 --> 01:46:01,040
 for the other side of the screen.

1366
01:46:01,040 --> 01:46:03,040
 And then we do the check for the other side.

1367
01:46:03,040 --> 01:46:05,040
 And this is the other side.

1368
01:46:05,040 --> 01:46:07,040
 So we do the check for the other side.

1369
01:46:07,040 --> 01:46:09,040
 Yes.

1370
01:46:09,040 --> 01:46:11,040
 Because even if it is the most similar

1371
01:46:11,040 --> 01:46:13,040
 to the original photoshop,

1372
01:46:13,040 --> 01:46:15,040
 there will be some differences between the pixels.

1373
01:46:15,040 --> 01:46:17,040
 Yes.

1374
01:46:17,040 --> 01:46:19,040
 And then we do the check for the other side.

1375
01:46:19,040 --> 01:46:21,040
 Yes.

1376
01:46:21,040 --> 01:46:23,040
 I am sorry.

1377
01:46:23,040 --> 01:46:25,040
 I will start the test later.

1378
01:46:25,040 --> 01:46:27,040
 I will go to the toilet first.

1379
01:46:27,040 --> 01:46:29,040
 If you want to ask questions, you can eat.

1380
01:46:29,040 --> 01:46:31,040
 I will go to the toilet.

1381
01:46:31,040 --> 01:46:33,040
 Thank you.

1382
01:46:35,040 --> 01:46:37,040
 I need to go to the toilet first.

1383
01:46:37,040 --> 01:46:39,040
 Maybe you can ask after the class.

1384
01:47:05,040 --> 01:47:07,040
 Thank you.

1385
01:47:35,040 --> 01:47:37,040
 Thank you.

1386
01:48:05,040 --> 01:48:07,040
 Thank you.

1387
01:48:35,040 --> 01:48:37,040
 Thank you.

1388
01:49:05,040 --> 01:49:07,040
 Thank you.

1389
01:49:35,040 --> 01:49:37,040
 Thank you.

1390
01:50:05,040 --> 01:50:07,040
 Thank you.

1391
01:50:35,040 --> 01:50:37,040
 Thank you.

1392
01:51:05,040 --> 01:51:07,040
 Thank you.

1393
01:51:35,040 --> 01:51:37,040
 Thank you.

1394
01:52:05,040 --> 01:52:07,040
 Thank you.

1395
01:52:35,040 --> 01:52:37,040
 Thank you.

1396
01:53:05,040 --> 01:53:07,040
 Thank you.

1397
01:53:35,040 --> 01:53:37,040
 Thank you.

1398
01:54:05,040 --> 01:54:07,040
 Thank you.

1399
01:54:35,040 --> 01:54:37,040
 Thank you.

1400
01:55:05,040 --> 01:55:07,040
 Thank you.

1401
01:55:35,040 --> 01:55:37,040
 Thank you.

1402
01:55:37,040 --> 01:55:39,040
 Thank you.

1403
01:55:39,040 --> 01:55:41,040
 Thank you.

1404
01:55:41,040 --> 01:55:43,040
 Thank you.

1405
01:55:43,040 --> 01:55:45,040
 Thank you.

1406
01:55:45,040 --> 01:55:47,040
 Thank you.

1407
01:55:47,040 --> 01:55:49,040
 Thank you.

1408
01:55:49,040 --> 01:55:51,040
 Thank you.

1409
01:55:51,040 --> 01:55:53,040
 Thank you.

1410
01:55:53,040 --> 01:55:55,040
 Thank you.

1411
01:55:55,040 --> 01:55:57,040
 Thank you.

1412
01:55:57,040 --> 01:55:59,040
 Thank you.

1413
01:55:59,040 --> 01:56:01,040
 Thank you.

1414
01:56:01,040 --> 01:56:03,040
 Thank you.

1415
01:56:03,040 --> 01:56:05,040
 Thank you.

1416
01:56:05,040 --> 01:56:07,040
 Thank you.

1417
01:56:07,040 --> 01:56:09,040
 Thank you.

1418
01:56:09,040 --> 01:56:11,040
 Thank you.

1419
01:56:11,040 --> 01:56:13,040
 Thank you very much.

1420
01:56:13,040 --> 01:56:15,040
 Thank you for that.

1421
01:56:15,040 --> 01:56:17,040
 Thank you for that.

1422
01:56:17,040 --> 01:56:19,040
 Thank you.

1423
01:56:19,040 --> 01:56:21,040
 Thank you.

1424
01:56:21,040 --> 01:56:23,040
 Thank you very much.

1425
01:56:23,040 --> 01:56:25,040
 Thank you.

1426
01:56:25,040 --> 01:56:27,040
 Thank you.

1427
01:56:27,040 --> 01:56:29,040
 Thank you.

1428
01:56:29,040 --> 01:56:31,040
 Thanks.

1429
01:56:31,040 --> 01:56:36,720
 useful for MPEG-2 video transmitted over network with the following characteristics.

1430
01:56:36,720 --> 01:56:42,880
 So, earlier on during the introduction, we explained that scalability is basically this idea,

1431
01:56:42,880 --> 01:56:48,720
 you have the base layer, and then you have the base layer and you have the enhancement layer.

1432
01:56:48,720 --> 01:56:55,840
 So, the base layer is to capture the basic video quality, right, the very lower level,

1433
01:56:55,840 --> 01:57:02,800
 the basic video quality. And enhancement layer is, okay, in addition, if you decode together

1434
01:57:02,800 --> 01:57:08,480
 with the base layer, it can improve the video quality. Yeah, so at high level, that's what it

1435
01:57:08,480 --> 01:57:13,840
 does, because under different network conditions, sometimes you may need to have this flexibility

1436
01:57:13,840 --> 01:57:19,200
 of only transmitting the base layer. But so, in some cases, when your network condition is not

1437
01:57:19,200 --> 01:57:24,880
 so good, you may only want to transmit the base layer, okay, so that your receiver can,

1438
01:57:24,880 --> 01:57:31,120
 no, at least recover the basic video quality. But when the network condition is better, then you

1439
01:57:31,120 --> 01:57:37,600
 can also transmit the enhancement layer, so that at the decoder side, now you have the base layer,

1440
01:57:37,600 --> 01:57:42,720
 together with the enhancement layer, you can have a better video quality. So, therefore,

1441
01:57:42,720 --> 01:57:47,840
 depending on condition, right, you want to have this flexibility to be able to transmit just the

1442
01:57:47,840 --> 01:57:54,400
 base layer or base layer plus enhancement layer. So, this capability is known as scalability.

1443
01:57:54,880 --> 01:58:01,600
 Okay, right, okay, so when is this scalably, kind of scalable coding useful? So, it's useful for

1444
01:58:01,600 --> 01:58:07,200
 network with this kind of condition. The first one is network with different bit rate. So, network

1445
01:58:07,200 --> 01:58:11,920
 with different bit rate means that, okay, sometimes for this network, you need to go through different

1446
01:58:11,920 --> 01:58:18,000
 connection or different branch here. So, some connection you may have a high bandwidth, okay,

1447
01:58:18,000 --> 01:58:23,040
 some part of the network you may have a low bandwidth, right, so some network has high bandwidth,

1448
01:58:23,040 --> 01:58:29,680
 some network has low bandwidth. So, if your network, right, some of the bandwidth is quite low,

1449
01:58:29,680 --> 01:58:37,840
 then we can only transmit, okay, those, you know, base layer video only. So, suppose if you are person

1450
01:58:37,840 --> 01:58:45,280
 one, right, okay, some of your network, this connection, it has high bandwidth, some has low

1451
01:58:45,280 --> 01:58:50,720
 bandwidth, so then I can only transmit the base layer to you. But if you have another person,

1452
01:58:50,720 --> 01:58:55,600
 right, all his connection has high bandwidth, then I can transmit both the base layer as well as the

1453
01:58:55,600 --> 01:59:02,800
 enhancement layer to the second person, then his video quality will be better. So, this is when

1454
01:59:02,800 --> 01:59:08,240
 your network is, have a different bit rate, okay, sometimes your network may have a variable bit

1455
01:59:08,240 --> 01:59:12,640
 rate channel. That means, right, in the morning, maybe the bandwidth is very high, right, maybe

1456
01:59:12,640 --> 01:59:17,280
 at night, the bandwidth is low. So, if the bandwidth condition would change over time,

1457
01:59:17,360 --> 01:59:22,719
 then what we can do is that when the network condition is good, we transmit both base layer

1458
01:59:22,719 --> 01:59:27,759
 and enhancement layer. But when the network condition, like bandwidth is low, then we only

1459
01:59:27,759 --> 01:59:33,040
 transmit the base layer, okay, so this is for the second condition, right, so for the third condition

1460
01:59:33,040 --> 01:59:39,840
 is when a network with noisy connection, sometimes, you know, some connection has lots of bit rate

1461
01:59:39,840 --> 01:59:46,400
 error, right, so for example, if you are going to transmit over some, some buildings that, you know,

1462
01:59:46,400 --> 01:59:52,160
 part of the, if you are doing wireless transmission, right, there's some occlusion, so sometimes

1463
01:59:52,160 --> 01:59:56,879
 your channel can be very noisy, that means there are lots of error. So, for those cases,

1464
01:59:56,879 --> 02:00:02,879
 then what we'll do is that for the base layer, we will try to provide some stronger error protection

1465
02:00:02,879 --> 02:00:08,639
 for the base layer, okay, and for the enhancement layer, yeah, we can either choose not to transmit

1466
02:00:08,640 --> 02:00:16,720
 or we don't put as much emphasis to protect those enhancement layer, okay, so that's a basic

1467
02:00:16,720 --> 02:00:22,240
 principle, right, so let's look at now a bit more concretely what is this scalable coding here,

1468
02:00:22,240 --> 02:00:28,000
 right, so the scalable coding, right, actually consists of layer coding, right, so as I mentioned

1469
02:00:28,000 --> 02:00:33,040
 before, you have the base layer and you can have one or more enhancement layer here, okay,

1470
02:00:33,040 --> 02:00:40,320
 so when we encode the video, we have this base layer here, okay, so this base layer is to encode

1471
02:00:40,320 --> 02:00:45,760
 the basic quality and then you have the enhancement layer, so enhancement layer can be one or it can

1472
02:00:45,760 --> 02:00:51,120
 be more, so in this illustration it shows two enhancement layer, so this enhancement layer

1473
02:00:51,840 --> 02:00:58,000
 together with the base layer, right, will give you better quality, so the coding and the decoding

1474
02:00:58,080 --> 02:01:03,600
 of the enhancement layer will depend on the base layer, okay, so that's a high-level idea,

1475
02:01:04,160 --> 02:01:11,040
 so you can, okay, the base layer can be coded independently, transmitted and decoded independently,

1476
02:01:11,040 --> 02:01:17,920
 okay, to give the basic video quality, right, okay, so the bitstream or base layer are sent first

1477
02:01:17,920 --> 02:01:23,360
 to give fast and basic view of the video followed by the enhancement layer, the enhancement layer,

1478
02:01:23,360 --> 02:01:28,719
 as the name suggests, it improves the quality, right, so the coding and the decoding of the

1479
02:01:28,719 --> 02:01:33,599
 enhancement layer here, you can see, is depending on the base layer, so therefore the coding and

1480
02:01:33,599 --> 02:01:40,559
 the decoding of the enhancement layer are depending on the base layer, okay, all the previous enhancement

1481
02:01:40,559 --> 02:01:45,839
 layer, okay, so this picture gives you a very quick visualizations of the relationship between

1482
02:01:45,839 --> 02:01:51,920
 base layer and the enhancement layer, right, so next we are going to look a bit more specifically

1483
02:01:52,000 --> 02:01:59,360
 at some of the, you know, this scalable coding type here, right, so the first one yet you have is

1484
02:02:00,080 --> 02:02:05,760
 spacious scalability, so as the names suggest, spatial means it's a space-based scalability,

1485
02:02:05,760 --> 02:02:10,320
 so therefore what it means is that, right, for your base layer, right, the, you know,

1486
02:02:11,200 --> 02:02:16,800
 the resolution could be small, but for the enhancement layer, right, together with the

1487
02:02:16,880 --> 02:02:21,840
 enhancement layer, then the resolution will be large, okay, so this is known as a spacious

1488
02:02:21,840 --> 02:02:27,040
 scalability, the other one is, second one is known as a temporal scalability, right, that means for

1489
02:02:27,040 --> 02:02:33,520
 base layer, you probably can only support 15 frames per second, but when you have base layer

1490
02:02:33,520 --> 02:02:39,360
 plus the enhancement layer, then you can support 30 frames per second, so this is known as a

1491
02:02:39,360 --> 02:02:46,560
 temporal scalability, okay, the other one is a SNR or quality scalability, for base layer,

1492
02:02:46,560 --> 02:02:52,560
 your quality is not so good, right, but for base layer plus enhancement layer, your quality is much

1493
02:02:52,560 --> 02:03:01,680
 higher, so these are a few common scalability and the impact as well as H.264, right, okay, so again

1494
02:03:01,680 --> 02:03:08,080
 more illustration, for spatial scalability, you can see the base layer, right, the resolution is

1495
02:03:08,080 --> 02:03:16,000
 smaller, okay, but together with enhancement layer, the resolution now is increased, so this is known

1496
02:03:16,000 --> 02:03:24,560
 as a spatial scalability, so next one is the quality scalability, right, or the SNR scalability,

1497
02:03:24,560 --> 02:03:30,480
 for base layer, the quality is not so good, right, just like this one, the quality is not so good,

1498
02:03:30,480 --> 02:03:36,720
 but once you combine with enhancement layer, the quality will be better, okay, just like this,

1499
02:03:38,160 --> 02:03:43,360
 okay, so the next one is a temporal scalability, for base layer, your number of frames is not as

1500
02:03:43,360 --> 02:03:50,000
 many, but once you combine with enhancement layer, then the number of frames per second is higher,

1501
02:03:50,000 --> 02:04:05,040
 right, so this is another visualization, right, okay, so let's look at the types of different

1502
02:04:05,040 --> 02:04:11,120
 scalability, I think just now from the few images is we already have some idea, so in terms of impact

1503
02:04:11,120 --> 02:04:17,760
 to scalability, the first one is known as a SNR scalability, SNR stands for signal to noise ratio

1504
02:04:17,760 --> 02:04:24,640
 scalability, so this kind of scalability, the enhancement layer will provide higher SNR, higher

1505
02:04:24,640 --> 02:04:32,080
 SNR in this case means higher quality, okay, so the first types of scalability is to provide higher

1506
02:04:32,080 --> 02:04:38,960
 quality or higher SNR, okay, so the second one is a spatial scalability, just like what we have shown

1507
02:04:38,960 --> 02:04:44,880
 in the previous example, the enhancement layer will increase the spatial resolution from small

1508
02:04:44,880 --> 02:04:51,200
 to become larger, the third one is temporal scalability, okay, is to facilitate higher frame

1509
02:04:51,200 --> 02:04:57,040
 rate, initially is lower frame rate, now with enhancement layer you have higher frame rate,

1510
02:04:57,040 --> 02:05:02,640
 okay, so there's also the hybrid scalability, so hybrid scalability means it can be a combination

1511
02:05:02,640 --> 02:05:08,160
 of two of the above, because you can have potentially a few enhancement layer, so sometimes you can

1512
02:05:08,240 --> 02:05:14,880
 combine them together, so when you have two or more, you only have two, combination of these two

1513
02:05:14,880 --> 02:05:22,000
 is known as a hybrid scalability, okay, and then next there's one which is known as the data partitioning,

1514
02:05:22,000 --> 02:05:28,559
 so data partitioning essentially, what you do is that this quantized DCT coefficient, if you remember,

1515
02:05:29,280 --> 02:05:34,880
 right, you have the error, prediction error, right, you let it go through DCT transform,

1516
02:05:34,880 --> 02:05:39,120
 right, and afterwards you let it go through the quantization, so when you let it go through the

1517
02:05:39,120 --> 02:05:45,520
 quantization, if you remember, similar to JPEG with the zig-zag scanning, right, so if you,

1518
02:05:45,520 --> 02:05:52,400
 so some of the KVCIN are low AC KVCIN, some of the KVCIN are high AC KVCIN, so if you partition this

1519
02:05:52,960 --> 02:06:01,360
 low AC KVCIN with high AC KVCIN, this is known as the data partitioning, right, because low AC KVCIN

1520
02:06:01,360 --> 02:06:09,599
 actually correspond to like general information, but high AC KVCIN as the name suggests correspond

1521
02:06:09,599 --> 02:06:16,480
 to detail, right, so therefore if you just keep the low AC KVCIN, right, it gives you the general

1522
02:06:16,480 --> 02:06:24,480
 overview of the visual content, but high AC KVCIN will give you the detail, so this is the data

1523
02:06:24,480 --> 02:06:30,240
 partitioning, right, okay, so next we are just going to spend a bit more time on this but not

1524
02:06:30,240 --> 02:06:36,559
 too much, right, okay, so we are going to look at this SNR scalability, right, so SNR scalability,

1525
02:06:36,559 --> 02:06:42,480
 as I mentioned, the enhancement over the base layer is improve the signal to noise ratio or the quality,

1526
02:06:43,280 --> 02:06:49,679
 right, okay, so, right, okay, we can go through this particular right up first and afterwards we'll

1527
02:06:49,679 --> 02:06:56,320
 look at the diagram to have a better understanding about what, how it's being done here, right, so

1528
02:06:56,320 --> 02:07:02,480
 for this SNR scalability, you will generate two bit stream, one is called base layer bit stream,

1529
02:07:02,480 --> 02:07:07,759
 the other is an enhancement layer bit stream here, okay, so for this you have the base layer bit

1530
02:07:07,759 --> 02:07:11,840
 stream and you have the enhancement layer bit stream, so first we are going to see how do we

1531
02:07:11,840 --> 02:07:17,280
 generate this base layer bit stream, so to generate the base layer bit stream is actually very similar

1532
02:07:17,280 --> 02:07:24,559
 to what we have studied earlier on, so for base layer, but essentially we'll be using a cost quantization

1533
02:07:24,560 --> 02:07:31,280
 table, so cost quantization table means the value, the step size is larger, so if the step size is

1534
02:07:31,280 --> 02:07:38,800
 larger, right, that means actually your quantization loss will be larger, that means you can actually

1535
02:07:38,800 --> 02:07:45,360
 compress the file into a smaller bit stream, but the quality will not be as good, okay, so therefore

1536
02:07:45,360 --> 02:07:52,400
 if you use a cost quantization table, right, with a larger step size, right, the quality of the video

1537
02:07:52,400 --> 02:07:57,759
 that you generate will be lower quality because there's lots of information loss-ready, but the

1538
02:07:57,759 --> 02:08:05,920
 good thing about it is that the bit is much smaller, okay, because your step size is large, so you drive

1539
02:08:05,920 --> 02:08:12,160
 lots of queries in to become zero, so therefore if you use a cost quantization table, your base

1540
02:08:12,160 --> 02:08:18,240
 layer will have low quality and the number of bits that you use will be smaller, okay, so after

1541
02:08:18,320 --> 02:08:24,000
 works, right, so generating this base layer is very simple, so next we are going to see how do we

1542
02:08:24,000 --> 02:08:30,400
 generate the enhancement layer, so for the enhancement layer what we do is that just now we have this

1543
02:08:30,400 --> 02:08:35,920
 particular costly quantized DCT coefficient from the base layer, okay, we can let it go through

1544
02:08:37,280 --> 02:08:46,480
 inverse quantization, okay, or the quantization, right, so this particular quantized coefficient,

1545
02:08:46,480 --> 02:08:51,839
 we can let it go through the, okay, for this base layer, this is the base layer, initially we have

1546
02:08:51,839 --> 02:08:58,240
 the quantized DCT coefficient, right, so we can let it go through the inverse quantization and

1547
02:08:58,240 --> 02:09:04,559
 after works we compare with the original DCT coefficient to get the error, okay, to get the

1548
02:09:04,559 --> 02:09:11,519
 error, so this error then we let it go through a more, a final quantization table, right, so this

1549
02:09:11,520 --> 02:09:17,280
 final quantization table will make sure that less information is lost, that will correspond to the

1550
02:09:18,480 --> 02:09:23,920
 enhancement layer, okay, so let's look at the descriptions here, so the costly quantized DCT

1551
02:09:23,920 --> 02:09:30,080
 coefficient are that inverse quantized and fed to the enhancement layer, okay, to compare with the

1552
02:09:30,080 --> 02:09:37,520
 original DCT, so you have the original DCT and you have the reconstructed DCT on the base layer,

1553
02:09:37,520 --> 02:09:44,480
 you take that difference, okay, so the difference then you let it pass through a fine quantization

1554
02:09:44,480 --> 02:09:51,120
 table, right, so that the information that you obtain now will be more detailed because less

1555
02:09:51,120 --> 02:09:57,680
 loss occur, okay, to get the DCT coefficient with higher quality, right, and after works you let it go

1556
02:09:57,680 --> 02:10:06,560
 through VC, variable length coding and so on, to obtain the, this enhancement bit street, okay, so

1557
02:10:06,560 --> 02:10:12,000
 this part initially at, no, the description may not be so clear, from this particular diagram

1558
02:10:12,000 --> 02:10:18,960
 it will be a little bit clearer, okay, so what we have is that, suppose this is the current frame

1559
02:10:18,960 --> 02:10:25,680
 that we want to encode, right, we partition into numerous macro block, so right, this diagram is

1560
02:10:25,680 --> 02:10:30,480
 a little bit different from the previous diagram, but the high-level idea is the same, so you have

1561
02:10:30,480 --> 02:10:36,879
 this particular current macro block, okay, this frame memory here refers to the previous reference

1562
02:10:36,879 --> 02:10:42,080
 frame, okay, so you take your current macro block, you compare to your previous reference frame,

1563
02:10:42,080 --> 02:10:47,440
 you let it go through the motion estimation, right, so once you have the motion estimation,

1564
02:10:47,440 --> 02:10:53,360
 then you can also get the best match block, so once you get the best match block here, this is

1565
02:10:53,360 --> 02:10:58,400
 your prediction, okay, so you take your macro block and your best match block, the most similar

1566
02:10:58,400 --> 02:11:03,280
 block, you take their difference, then this is the prediction error, so it's just similar to what

1567
02:11:03,280 --> 02:11:09,360
 we have studied before, so we have this prediction error, we let it go through the DCT, we let it

1568
02:11:09,360 --> 02:11:14,799
 go through the quantization, okay, the entropy encoding, right, and then you will get the bit

1569
02:11:14,799 --> 02:11:20,799
 street, right, so this part is exactly the same as what we have studied before, except they show

1570
02:11:20,799 --> 02:11:26,559
 the diagram slightly differently, okay, but otherwise it's the same, okay, so the main thing

1571
02:11:26,560 --> 02:11:34,400
 about here is that for this particular, for this base layer, the quantization that we use here,

1572
02:11:34,400 --> 02:11:39,920
 we use a coarse quantization, that means they are step sizes larger, okay, so this particular

1573
02:11:39,920 --> 02:11:45,440
 quantization table that we have, they are step sizes larger, okay, so that the quality here will

1574
02:11:45,440 --> 02:11:52,000
 be lower, but their bit stream will be lesser as well, okay, so now once we have this particular

1575
02:11:52,880 --> 02:11:59,600
 quantized coefficient here, we let it go through the inverse quantization, okay,

1576
02:12:00,320 --> 02:12:05,120
 and then we compare with the original DCT coefficient, we compare the original DCT

1577
02:12:05,120 --> 02:12:11,680
 coefficient and this reconstructed DCT coefficient, we take their difference, so it's, that means we

1578
02:12:11,680 --> 02:12:17,520
 take the difference between the original and what is coming from the base layer, right, we take the

1579
02:12:17,520 --> 02:12:23,360
 original, we compare with the base layer, we calculate that small difference, this small difference

1580
02:12:24,160 --> 02:12:30,320
 we let it go through another quantization table, but this quantization table now that step size is

1581
02:12:30,320 --> 02:12:38,960
 much smaller, right, because you want it to cover more detail, so this final quantization table,

1582
02:12:38,960 --> 02:12:45,040
 you let it go through the entropy encoding and then you'll get enhancement bit stream, okay,

1583
02:12:45,040 --> 02:12:50,640
 you get enhancement bit stream here, right, so this part here, right, this particular branch here is,

1584
02:12:51,200 --> 02:12:58,320
 right, so because this is the difference, when you take the inverse quantization, you couple with

1585
02:12:58,320 --> 02:13:05,680
 just now your original DCT quantization, then you can actually reconstruct it, right, to reconstruct

1586
02:13:05,680 --> 02:13:12,720
 your reference frame, okay, so that's a basic idea of SNS scalability, in short, to summarize,

1587
02:13:13,440 --> 02:13:19,280
 okay, this part here is the base encoder, for this base encoder is very similar to what we

1588
02:13:19,280 --> 02:13:24,560
 have studied before, except we use a larger quantization table here, such that your bit stream

1589
02:13:24,560 --> 02:13:31,040
 quality is not so high, but the number of bits is smaller, that's exactly what we want, okay, and for

1590
02:13:31,040 --> 02:13:37,280
 this enhancement encoder here, what it does is that it takes the difference between your original DCT

1591
02:13:37,280 --> 02:13:46,240
 coefficient and, you know, the lower quality DCT coefficient from the base layer, it calculates

1592
02:13:46,240 --> 02:13:50,639
 their difference, and then this difference you go and encode it, right, so if you do want to border

1593
02:13:50,639 --> 02:13:57,280
 about too much of the detail, this is the high level idea, okay, right, so now you can see this

1594
02:13:57,280 --> 02:14:04,000
 base layer contains basic quality, this enhancement layer, right, actually is like encode the difference,

1595
02:14:04,000 --> 02:14:10,720
 so therefore you need to encode together with the base layer to obtain more detailed information,

1596
02:14:12,800 --> 02:14:18,720
 right, okay, so there's the ideas of SNR scalability, so next, if we look at the next one,

1597
02:14:18,720 --> 02:14:24,000
 it's a spatial scalability, so I think we'll spend quite a bit of time talking about it,

1598
02:14:24,000 --> 02:14:30,000
 so we can just go ahead to look at the information, so the base layer is used to generate bit stream

1599
02:14:30,000 --> 02:14:35,840
 of reduced resolution, so base layer, the resolution is lower, right, so when you combine with enhancement

1600
02:14:35,840 --> 02:14:42,080
 layer, the resolution will be higher, so how do we achieve that, right, so to achieve that again,

1601
02:14:42,080 --> 02:14:47,600
 there are some details, but we are not going to go too much, we are not going to be border with

1602
02:14:47,600 --> 02:14:53,760
 too much detail, but rather we'll be focusing on some high level understanding, so for this current

1603
02:14:53,760 --> 02:14:59,360
 frame, for example, this current frame, what we do is that we do a spatial decimeter, so this spatial

1604
02:14:59,360 --> 02:15:05,280
 decimeter means that, right, initially, your initial video could be this resolution, but we let it go

1605
02:15:05,280 --> 02:15:11,200
 through a low pass filtering and sampling so that you can reduce the size of the image, so we let it

1606
02:15:11,200 --> 02:15:17,519
 go through spatial decimeter to reduce the size of the image, from initially, for example, this big,

1607
02:15:17,519 --> 02:15:23,920
 now to become smaller, right, so this resolution now will be smaller, you let it go through some

1608
02:15:23,920 --> 02:15:30,560
 base layer encoder, just like what we have studied before, any of the MPEG encoder here, and then the

1609
02:15:30,560 --> 02:15:35,680
 bit stream that you come up from here is the base layer bit stream, this base layer bit stream

1610
02:15:35,680 --> 02:15:41,760
 corresponding to lower resolution video, okay, and then afterwards for the enhancement layer,

1611
02:15:41,760 --> 02:15:49,200
 what we do is that initially we have this low level, low resolution bit stream, we try to perform

1612
02:15:49,200 --> 02:15:55,120
 this spatial interpolator, so this is like performing interpolation from low resolution to

1613
02:15:55,120 --> 02:16:02,800
 interpolate into bigger resolution, so after you have performed the interpolation, you take the

1614
02:16:02,800 --> 02:16:09,679
 difference between the original and your interpolated result, you get your error, so this error, you

1615
02:16:09,679 --> 02:16:14,960
 encode it using the MPEG standard to get your enhancement layer, right, so that's the basic

1616
02:16:14,960 --> 02:16:25,840
 idea of spatial scalability, okay, so next the temporal scalability, right, so the input video

1617
02:16:25,840 --> 02:16:33,360
 is temporarily split into two parts, right, so each part carrying the original, half of the original

1618
02:16:33,360 --> 02:16:40,240
 frame rate, right, so the base layer encoder, carry out normal single layer encoding, right,

1619
02:16:40,240 --> 02:16:48,000
 okay, that is known as the bit layer, that is the base layer, right, okay, so from the visualization

1620
02:16:48,000 --> 02:16:54,719
 it's actually easy to understand, so suppose initially you have a video, right, so you have this

1621
02:16:54,719 --> 02:17:01,119
 video with many different frames, so what we do is that this temporal demultiplexer means that we

1622
02:17:01,119 --> 02:17:08,959
 split it into even frame and odd frame, okay, right, for example frame one, three, five, seven, the other

1623
02:17:08,959 --> 02:17:14,719
 is two, four, six and so on, so if you take the odd frame here, for example one, three, five here,

1624
02:17:15,279 --> 02:17:21,519
 we try to encode it using the MPEG standard, then you'll get your base layer here, so this base layer

1625
02:17:21,519 --> 02:17:27,199
 bit stream actually only have half of the frame rate, okay, half of the frame rate, so how do you

1626
02:17:27,199 --> 02:17:33,359
 generate the enhancement layer now, for the enhancement layer you take the bit, the frame that

1627
02:17:33,360 --> 02:17:41,120
 you have for one, three, five and so on, you do the, you know, you take this one, three, five, you

1628
02:17:41,120 --> 02:17:47,680
 compare with this frame of two, four, six and so on, right, you take the arrow, okay, you take the

1629
02:17:47,680 --> 02:17:54,480
 arrow and then this arrow you encode it using the MPEG standard, right, and then you get the enhancement

1630
02:17:54,480 --> 02:17:59,520
 layer, so you can see the idea is always the same, right, the base layer you just encode the basic

1631
02:17:59,520 --> 02:18:04,480
 structure and afterwards you take the arrow or the difference, all right, and then this difference

1632
02:18:04,480 --> 02:18:11,360
 encoded to make it into the enhancement layer, all right, so I think for this part here we didn't

1633
02:18:11,360 --> 02:18:16,080
 go through too much into the detail because if you go into the detail it'll be a bit too much,

1634
02:18:16,080 --> 02:18:23,840
 so we only focus on some high level understanding, but the basic principle is this, okay, and then

1635
02:18:23,840 --> 02:18:30,080
 next, hybrid scalability, so as just now the summary states, right, if we have any of the three

1636
02:18:30,080 --> 02:18:34,880
 scalability when you combine them together, it's called hybrid scalability, so for example it can

1637
02:18:34,880 --> 02:18:42,160
 be spatial plus temporal, SNR by spatial or SNR plus temporal, so the combination of this is known as

1638
02:18:42,160 --> 02:18:48,000
 hybrid scalability, right, so usually when we have a hybrid scalability, that means you have a three

1639
02:18:48,000 --> 02:18:53,360
 layer structures, right, so you have a three-layer hybrid encoder, right, so the base layer and then

1640
02:18:53,440 --> 02:18:59,040
 you have two enhancement layers, enhancement layer one and enhancement layer two, right, one for each

1641
02:18:59,040 --> 02:19:07,680
 of these scalability, right, okay, and then the last one that we have is the data partitioning,

1642
02:19:14,960 --> 02:19:21,120
 so data partitioning is that, right, as we mentioned, right, we have the DST coefficient,

1643
02:19:21,120 --> 02:19:29,440
 all right, so we just partition into low AC and the high AC, so low AC contain the general, it's like,

1644
02:19:29,440 --> 02:19:34,160
 you know, the general information, but high AC actually correspond to high frequency, that

1645
02:19:34,160 --> 02:19:41,440
 means the detail, so we split it into two branches, right, so the enhancement layer, because enhancement

1646
02:19:41,440 --> 02:19:46,080
 layer usually corresponds to detail, so the enhancement layer will correspond to the high

1647
02:19:46,080 --> 02:19:52,960
 frequency coefficient, right, so straight speaking data partitioning is not layer coding,

1648
02:19:53,600 --> 02:19:59,280
 right, because you just simply have one video but you divide it into two parts, right, so a single

1649
02:19:59,280 --> 02:20:04,880
 stream of data is simply divided up into two parts here, right, okay, so there's no further

1650
02:20:04,880 --> 02:20:08,880
 dependence of base layer in generating the enhancement layer, so enhancement layer,

1651
02:20:09,759 --> 02:20:16,880
 do not really depends on the base layer, you just simply, you know, take the DCT coefficient

1652
02:20:16,880 --> 02:20:22,800
 and break it into two parts, one correspond to base layer, the other correspond to the enhancement

1653
02:20:22,800 --> 02:20:28,080
 layer, right, so it's useful for transmission over noisy channel or progressive scanning,

1654
02:20:28,640 --> 02:20:35,119
 right, progressive transmission, right, so because noisy channel means that base layer,

1655
02:20:35,120 --> 02:20:40,080
 we try to provide more protection, progressive scanning means that we can transmit those low

1656
02:20:40,080 --> 02:20:45,120
 AC coefficient first, so you can see the basic information first, right, and then once you have

1657
02:20:45,120 --> 02:20:52,400
 more detail, right, high AC coefficient, then you can also increase it with the enhancement layer,

1658
02:20:54,560 --> 02:21:01,520
 right, okay, so, right, we spent a bit of time talking about the, this scalability, right,

1659
02:21:01,600 --> 02:21:06,240
 MPEG-2 scalability, next we are also going to look at some of the advantages of MPEG-2

1660
02:21:06,240 --> 02:21:12,160
 compared to MPEG-1, so what are the advantages, so without even knowing the detail, you know that

1661
02:21:12,160 --> 02:21:18,160
 MPEG-2, since it come out after MPEG-1, surely will offer better picture quality, okay, so it

1662
02:21:18,160 --> 02:21:23,920
 offer better picture quality than MPEG-1, it support both progressive as well as inter-layer

1663
02:21:23,920 --> 02:21:29,760
 scan, okay, whereas MPEG-1 only support progressive scanning, so at the time it's considered as an

1664
02:21:29,760 --> 02:21:34,720
 advantage, yeah, because it's more flexible, but nowadays actually we don't really care about

1665
02:21:34,720 --> 02:21:41,280
 interlay scanning because the bandwidth is high enough, okay, right, okay, but at the time it's

1666
02:21:41,280 --> 02:21:48,240
 considered as advantage, okay, so it supports scalability, right, as compared to MPEG-1,

1667
02:21:49,040 --> 02:21:57,120
 okay, so it's more resilient to error, okay, so MPEG-2 can transmit video or noisy and

1668
02:21:57,200 --> 02:22:03,360
 reliable network with bit error, right, we have explained a bit earlier on, so for MPEG-2 it also

1669
02:22:03,360 --> 02:22:08,400
 support different chroma subsampling format, right, what we covered in previous lecture,

1670
02:22:08,400 --> 02:22:15,200
 so MPEG-1 only has 420, but MPEG-2 because it want to have a better quality, so it can cover

1671
02:22:15,920 --> 02:22:21,360
 a different chroma subsampling scheme, for example 444 will give you better quality as compared to

1672
02:22:21,360 --> 02:22:27,360
 420, right, so it has more flexible video format support various picture quality,

1673
02:22:28,880 --> 02:22:37,200
 such as in DVD and HDTV, so yeah, so an important commercial product arising from MPEG-2 is DVD,

1674
02:22:37,200 --> 02:22:43,280
 so some of you probably have watched DVD when you are a kid, right, so it's actually arising from

1675
02:22:43,280 --> 02:22:49,520
 MPEG-2, right, okay, so next let's look at one simple kind of past year

1676
02:22:50,480 --> 02:22:56,240
 questions, so for this question actually it will ask you to briefly discuss how MPEG-2

1677
02:22:56,240 --> 02:23:02,960
 scalability can be used in network with variable bit rate channel, right, okay, so I'll give you

1678
02:23:02,960 --> 02:23:07,520
 a bit of time to at least think back what we have just talked about and see whether you can answer

1679
02:23:07,520 --> 02:23:15,520
 this question

1680
02:23:19,520 --> 02:23:47,520
 all right, okay, so anyway let's try to go through the answer together, again this answer will be

1681
02:23:48,480 --> 02:23:55,840
 released on NTU Learn by tomorrow, right, okay, yeah, so MPEG-2 the scalable coding is actually

1682
02:23:55,840 --> 02:24:00,320
 this is a little bit on the longer side, in exam you actually don't have to write so much,

1683
02:24:00,320 --> 02:24:04,640
 but yeah the answer is actually mainly on this part here, so for MPEG-2

1684
02:24:05,520 --> 02:24:10,640
 scalable coding pretty much as we mentioned we understand you have the base layer, right,

1685
02:24:10,640 --> 02:24:16,480
 which actually only transmit the basic quality and then you have the enhancement layer which

1686
02:24:16,480 --> 02:24:23,520
 actually can together with base layer can you know provide higher quality view, so that's a basic

1687
02:24:23,520 --> 02:24:29,760
 principle of scalable coding, so this is what this part this part is actually similar to the

1688
02:24:29,760 --> 02:24:36,240
 lectures here, but right the main answer is actually coming from here for variable bit rate channel

1689
02:24:36,240 --> 02:24:43,600
 which means sometimes your network condition is good you allow more bandwidth sometimes the

1690
02:24:43,600 --> 02:24:50,160
 network condition is not so good right you know you may not be able to transmit so much information,

1691
02:24:50,160 --> 02:24:55,680
 so for network with variable bit rate channel when the bandwidth condition is high right we'll

1692
02:24:55,680 --> 02:25:00,560
 try to transmit both the base layer and the enhancement layer, right, so when the network

1693
02:25:00,560 --> 02:25:05,600
 condition is not so good we only transmit the base layer, right, so this is consistent with our

1694
02:25:05,600 --> 02:25:12,480
 understanding how this MPEG-2 scalable coding works, okay, so that's the kind of simple answer to

1695
02:25:13,600 --> 02:25:31,920
 this question, all right, okay, so let's continue, right, okay, so pretty much we have covered some of

1696
02:25:31,920 --> 02:25:38,800
 the kind of major improvement of MPEG-2 over MPEG-1, so of course there are many different

1697
02:25:38,800 --> 02:25:45,359
 expect but I try to choose some of the most important and expect as well as the improvement,

1698
02:25:45,359 --> 02:25:52,160
 right, so now if you look at the MPEG-2 again it has intraframe coding, so for iframe it's coded

1699
02:25:52,160 --> 02:25:58,160
 independently just like jpeg, okay, and then you have the interframe coding just like the pframe

1700
02:25:58,160 --> 02:26:03,599
 and bframe, right, it's actually again you are encoding the error, right, when you do the

1701
02:26:03,600 --> 02:26:10,480
 motion estimation the prediction error we use DCT to do the coding and afterwards we use a

1702
02:26:10,480 --> 02:26:16,160
 fixed block size motion compensation, right, the size, the block size is still the fixed block size

1703
02:26:16,160 --> 02:26:21,920
 here, right, some additional feature is now you can see that due to the different level and

1704
02:26:21,920 --> 02:26:29,120
 profile of MPEG-2 it can support a wider or larger range of resolution and target them for

1705
02:26:29,120 --> 02:26:35,200
 different application, yeah, so this is you know because it can support different profile and

1706
02:26:35,200 --> 02:26:41,280
 different level, it's now the table that we roughly show, right, and another important feature of MPEG-2

1707
02:26:41,280 --> 02:26:46,880
 is it's support this scalable coding, right, okay, this idea of base layer and enhancement layer

1708
02:26:46,880 --> 02:26:51,200
 and depending on the situation you may just sometimes you may want to transmit the base

1709
02:26:51,200 --> 02:26:58,000
 layer only, sometimes you may want to transmit base, bus enhancement layer, right, okay, and then it has

1710
02:26:58,000 --> 02:27:05,440
 more chroma sub sampling scheme, like it supports 444, 422, 420, right, so that to cater for different

1711
02:27:05,440 --> 02:27:15,920
 quality, yeah, so that's a quick summary of MPEG-2. Next let's quickly look at MPEG-4, right, so what

1712
02:27:15,920 --> 02:27:22,960
 is the basic idea of this MPEG-4? So MPEG-1 and 2, you can see MPEG-1 and 2 they use a block size

1713
02:27:22,960 --> 02:27:29,039
 coding technique, right, so what they do is that given a frame, they partition it into different

1714
02:27:29,039 --> 02:27:35,679
 fixed size macro block, right, and then afterwards depending on whether it's i-frame or p and b-frames,

1715
02:27:35,679 --> 02:27:42,000
 right, you for p and b-frames you do this motion estimation and compensation, so that's a basic

1716
02:27:42,000 --> 02:27:49,039
 idea of MPEG-1 and 2, but for MPEG-4, right, it's a little bit different, so for MPEG-4 it adopt this

1717
02:27:49,120 --> 02:27:56,080
 object-based coding, right, so object-based coding, right, what it means is that for quick

1718
02:27:56,080 --> 02:28:02,000
 visualization is like this, suppose you have this particular video that you want to compress here,

1719
02:28:02,000 --> 02:28:07,920
 so what it does is that for this encoder you will try to detect different objects, right, you will

1720
02:28:07,920 --> 02:28:14,880
 try to define different objects here, like for example different vop stand for video object plane,

1721
02:28:14,880 --> 02:28:20,560
 okay, you'll define different objects through this video object plane and then you will try to

1722
02:28:20,560 --> 02:28:28,160
 encode these different vop separately, okay, so an advantage of doing this is that, right, if you

1723
02:28:28,160 --> 02:28:34,160
 have for example a separate another object that you have, right, we call another vop, we can actually

1724
02:28:34,160 --> 02:28:40,320
 know somehow code this particular part of this particular bitstream or this object here into

1725
02:28:40,320 --> 02:28:46,400
 our bitstream to actually do some manipulation, so for example we can choose to remove this,

1726
02:28:47,680 --> 02:28:54,480
 remove the banana, okay, remove this part of the bitstream, but introduce this cookie into it,

1727
02:28:54,480 --> 02:29:00,800
 right, so that you can do some content manipulation, so this is the original idea of MPEG-4, they thought

1728
02:29:00,800 --> 02:29:06,400
 that they want to do some content manipulation, right, so that's why they try to encode the video

1729
02:29:06,400 --> 02:29:13,440
 based on the object, yeah, so therefore there's a high-level idea difference as compared to MPEG-1

1730
02:29:13,440 --> 02:29:20,240
 and 2, so you use an object-based coding, right, because the idea is that with that you can then

1731
02:29:20,240 --> 02:29:25,600
 do different things like composition, you can compose a content, you can manipulate, like take

1732
02:29:25,600 --> 02:29:31,440
 up some, include some, you can even help to do the indexing and retrieval because maybe you know

1733
02:29:31,520 --> 02:29:38,080
 some of the content in this video at the object level, yeah, but from the compression perspective

1734
02:29:38,080 --> 02:29:48,320
 actually this MPEG-4 is not commonly used, right, so a quick overview of MPEG-4, right, so it's

1735
02:29:49,600 --> 02:29:56,320
 published in 1998, okay, so their bit rate is a wider range from 5 kilobits per second to 10

1736
02:29:56,320 --> 02:30:04,160
 megabits per second, right, so as we have introduced earlier on is based on video object-based coding,

1737
02:30:04,160 --> 02:30:10,240
 so you have a video object-based coding and there's a way you can describe this content in a hierarchy,

1738
02:30:11,360 --> 02:30:18,400
 hierarchical manner, okay, right, so it can compose media object like what we mentioned,

1739
02:30:18,400 --> 02:30:25,360
 but you can insert some object, you can remove some, so it allows you to do some manipulation,

1740
02:30:25,360 --> 02:30:29,280
 but what you need to do is also you need to do some multiplexing, right,

1741
02:30:30,480 --> 02:30:35,520
 adding of some information and synchronization of this stream to make sure that everything is done

1742
02:30:35,520 --> 02:30:44,960
 properly, okay, right, okay, so this slide shows at high level what is the key difference between

1743
02:30:44,960 --> 02:30:52,000
 the frame-based coding and video object-based coding, so for frame-based coding, right,

1744
02:30:52,080 --> 02:30:57,200
 is this frame-based coding is just like the block-based coding that we have

1745
02:30:57,200 --> 02:31:03,600
 studied in MPEG-1 and 2 and this video object-based coding is this MPEG-4, right, so the MPEG-4,

1746
02:31:03,600 --> 02:31:09,760
 not the AVC, it's MPEG-4, right, okay, so let's have a look at the difference, so for example,

1747
02:31:09,760 --> 02:31:15,440
 for MPEG-1 and 2 is based on frame-based, sometimes it's also known as block-based coding,

1748
02:31:15,440 --> 02:31:20,400
 so this is what we have studied a few times already, right, okay, so for example,

1749
02:31:21,680 --> 02:31:27,760
 right, these few figures illustrate the MPEG-1 and MPEG-2 coding standard, right, so this is the

1750
02:31:27,760 --> 02:31:33,520
 current frame, okay, and then these are the two reference frames here, so for MPEG-1 and 2,

1751
02:31:33,520 --> 02:31:38,160
 the idea are similar, you partition this current frame into different macro block,

1752
02:31:39,039 --> 02:31:45,840
 and then for each of the macro block, right, you try to perform motion estimation and compensation

1753
02:31:45,840 --> 02:31:50,000
 to find the best match block, so because you partition it into different blocks, so it's a

1754
02:31:50,000 --> 02:31:55,280
 block-based coding, okay, so this MPEG-1 and 2 is a block-based coding, and then you need to perform

1755
02:31:55,280 --> 02:32:01,680
 the motion estimation and compensation, right, so for example, in this particular illustration here,

1756
02:32:01,680 --> 02:32:07,520
 right, suppose this is your current frame that you want to encode, this is currently the macro

1757
02:32:07,520 --> 02:32:13,200
 block you want to encode, so you try to search through the search window to find the best match

1758
02:32:13,200 --> 02:32:19,040
 block, right, okay, so in this particular illustration is showing that, okay, for this match,

1759
02:32:19,040 --> 02:32:25,200
 this current block you want to encode, if you try to perform the motion estimation and compensation,

1760
02:32:25,200 --> 02:32:31,200
 sometimes you may arrive at two different macro block that are very similar, okay, for example,

1761
02:32:31,200 --> 02:32:38,480
 you can have a potential match 1 at this block and potential match 2 at this block, so at the time

1762
02:32:38,480 --> 02:32:42,080
 there are some, you know, kind of discussion because sometimes there are some potential,

1763
02:32:43,760 --> 02:32:49,920
 you know, because you can find a few potential blocks, so sometimes you don't actually understand

1764
02:32:50,480 --> 02:32:55,280
 which block is actually better, right, if you look at this diagram you should see by right,

1765
02:32:55,280 --> 02:32:59,920
 this block should be better, but sometimes because it's the block-based approach,

1766
02:32:59,920 --> 02:33:03,680
 it's just simply look at which block gives you the smallest error, so sometimes there's some

1767
02:33:03,680 --> 02:33:09,520
 argument that this may not be the best way to do it, okay, right, so as opposed to that,

1768
02:33:10,480 --> 02:33:17,040
 right, the initial intentions of this, you know, MPEG4, VOP coding is that,

1769
02:33:17,040 --> 02:33:22,240
 right, you are going to first of all identify different objects, we call it VOP, so VOP1 and

1770
02:33:22,240 --> 02:33:29,520
 VOP2, so it's a VOP-based coding or object-based coding in MPEG4, right, so, right, when you are

1771
02:33:29,520 --> 02:33:35,280
 trying to perform the coding, you are just trying to look at the whole object, okay, rather than

1772
02:33:35,280 --> 02:33:39,520
 individual block, you are going to look at whole object rather than the individual block,

1773
02:33:39,520 --> 02:33:44,640
 so that, you know, you can then find out, for example, this person's motion is in this direction

1774
02:33:44,640 --> 02:33:49,840
 and this object's motion is in this separate direction and so on, so this is at a slightly

1775
02:33:49,840 --> 02:33:56,720
 different kind of, you know, thinking about how to encode the video, right, but it turns out that

1776
02:33:57,199 --> 02:34:03,599
 this way of doing it is actually quite difficult, that's why it's not so popular from the compression

1777
02:34:03,599 --> 02:34:09,359
 perspective, right, so anyway, yeah, at least conceptually we know what is the difference,

1778
02:34:09,359 --> 02:34:16,480
 okay, so figure C just now illustrates a possible example in which your birth potential matches

1779
02:34:16,480 --> 02:34:23,279
 your prediction, right, okay, as we have explained and for figure D, it shows that each object

1780
02:34:23,920 --> 02:34:29,280
 of arbitrary shape will obtain a unique motion vector consistent with the actual object motion,

1781
02:34:29,280 --> 02:34:33,920
 so this is the thinking initially, if you can detect the object, then your motion

1782
02:34:35,440 --> 02:34:40,640
 kind of estimation is actually more meaningful, yeah, that is the original intention,

1783
02:34:42,880 --> 02:34:48,080
 right, okay, so next we will just go through one of, yeah, just a few more slides before we finish,

1784
02:34:48,160 --> 02:34:55,440
 right, so for MPEG4, VOP coding here, so involve the motion estimation, compensation encoding,

1785
02:34:56,000 --> 02:35:01,600
 right, involve estimation, compensation encoding of the prediction error, so at that level it's the

1786
02:35:01,600 --> 02:35:07,600
 same, you still need to perform estimation, compensation, and coding, but the difference is

1787
02:35:07,600 --> 02:35:13,360
 that, right, instead of a, you know, a simple block, it actually defines an object, for example,

1788
02:35:13,360 --> 02:35:19,440
 this is the object here, right, this is a particular object, it defines a bounding box for this VOP,

1789
02:35:19,440 --> 02:35:25,680
 so this is a video object plane, for example, this is the object of interest, so it defines a bounding

1790
02:35:25,680 --> 02:35:32,960
 box, okay, for this particular VOP here, okay, so it defines a bounding box for this VOP, so once

1791
02:35:32,960 --> 02:35:38,240
 you define a bounding box like in this VOP here, right, inside, especially there's still some

1792
02:35:38,320 --> 02:35:44,480
 macro block here, but those macro blocks that is within this particular object we call interior

1793
02:35:44,480 --> 02:35:49,360
 macro block, so these are the interior macro blocks, those that are half of them is inside,

1794
02:35:49,360 --> 02:35:54,880
 half of them outside, we call it the boundary macro block, okay, so therefore in this case here,

1795
02:35:54,880 --> 02:36:02,560
 for VOP, we have this particular bounding box of the object, right, and then some of the macro

1796
02:36:02,560 --> 02:36:08,160
 blocks inside is called interior macro block, some is called boundary macro block, right, okay,

1797
02:36:08,160 --> 02:36:14,800
 so M-pack 4 defines a rectangular bounding box for each VOP, right, as illustrated here, okay,

1798
02:36:14,800 --> 02:36:21,359
 and each VOP is divided into many macro blocks as being shown here, okay, so macro block that

1799
02:36:21,359 --> 02:36:27,199
 like entirely within the VOP is known as interior macro block, so this is interior macro block,

1800
02:36:27,199 --> 02:36:31,680
 those that are near the border, some is inside, some are outside VOP, these are known as the

1801
02:36:31,680 --> 02:36:40,160
 boundary macro block, right, so next we want to see how do we perform motion estimation

1802
02:36:40,160 --> 02:36:45,520
 and compensation, so for those blocks that are inside the VOP, it's quite straightforward because

1803
02:36:45,520 --> 02:36:51,920
 all the information is already defined, but for those blocks that are near the boundary,

1804
02:36:51,920 --> 02:36:58,000
 we need to do some pre-processing, okay, so let's look at it, so for interior macro blocks,

1805
02:36:58,000 --> 02:37:03,040
 right, that's inside the VOP, but we just need to perform the motion estimation and compensation

1806
02:37:03,040 --> 02:37:11,280
 similar to M-pack 1 and 2, right, but for those blocks that are at the border boundary, it requires

1807
02:37:11,280 --> 02:37:16,720
 some pre-processing steps first by doing some padding, right, so let's take one example to

1808
02:37:16,720 --> 02:37:23,840
 illustrate this, okay, for example this is the VOP, right, and yeah, and this is the background here,

1809
02:37:23,840 --> 02:37:28,320
 so before we can do motion estimation because these values are not defined, so we need to do some

1810
02:37:29,200 --> 02:37:34,400
 padding first, so the padding what we do is that first of all we do a row-wise padding,

1811
02:37:34,400 --> 02:37:39,280
 okay, so for example, right, this pixel if we do not know, we just take the nearest pixel value,

1812
02:37:39,280 --> 02:37:44,320
 we write it down horizontally, so you can see this 60 and 60, this one we do not know, we just take

1813
02:37:44,320 --> 02:37:51,680
 this nearest value, we replicate it, okay, right, and then this one here, right, okay, we just write

1814
02:37:51,680 --> 02:37:58,000
 down from here, 70, and these three pixels here we just take from here, right, so it's another 60 here,

1815
02:37:58,000 --> 02:38:05,680
 but if this background pixel is between two different parts of the VOP, then we do the

1816
02:38:05,680 --> 02:38:12,960
 interpolation, but between 50 and 80 is 65, so we fill up with this value 65, so once we have done it

1817
02:38:12,960 --> 02:38:18,800
 horizontally, then the next thing is that, okay, so this is known as a horizontal repetitive padding,

1818
02:38:19,439 --> 02:38:24,960
 afterwards we perform the vertical repetitive padding, so for the vertical repetitive padding

1819
02:38:24,960 --> 02:38:30,320
 you can see, for example, within this 50 and 70, if we do interpolation, the average is 60,

1820
02:38:30,320 --> 02:38:38,240
 so we just fill up with 60, okay, right, okay, and then between 50 and 60 is 55, right, so we

1821
02:38:38,240 --> 02:38:43,759
 fill up with 55, so by the same token, we can fill up the rest of these missing pixels here,

1822
02:38:43,760 --> 02:38:49,440
 so this is one way for you to do some padding, right, to fill up the missing pixel, right,

1823
02:38:49,440 --> 02:38:58,640
 before you go and perform the motion compensation, estimation compensation, right, okay, so because

1824
02:38:58,640 --> 02:39:03,600
 this m-pack 4 in from the compression perspective is not so commonly used, so we will not go too

1825
02:39:03,600 --> 02:39:10,160
 much into the detail, right, okay, so the advantage of m-pack 4 is that it can integrate nature as

1826
02:39:10,160 --> 02:39:17,440
 synthetic content, okay, it can support 2D and 3D content, the code thing can be from low bit rate,

1827
02:39:18,000 --> 02:39:23,200
 okay, to relatively high bit rate here, right, it supports management and protection intellectual

1828
02:39:23,200 --> 02:39:30,080
 property because you can do some manipulation, right, so m-pack 4 summary, so the coding, high-level

1829
02:39:30,080 --> 02:39:34,960
 idea of the coding is the object-based coding, all right, okay, so it can integrate natural and

1830
02:39:35,039 --> 02:39:40,880
 synthetic content and it can support composition, manipulation, like just now the high-level

1831
02:39:40,880 --> 02:39:48,800
 diagram that we have shown, right, okay, so I think, yeah, today we'll probably stop here,

1832
02:39:48,800 --> 02:39:57,279
 but before you go, let me just quickly share something with you, so yeah, next Tuesday is,

1833
02:39:57,920 --> 02:40:07,840
 okay, so next Tuesday is a mid-autumn festival, so I wish all of you have a good festival, right,

1834
02:40:07,840 --> 02:40:11,520
 okay, actually I also have a very short video, just about one minute,

1835
02:40:15,920 --> 02:40:16,800
 right, if you can,

1836
02:40:17,679 --> 02:40:27,679
 so this is in Yu Yuan, right, Shang,

1837
02:40:28,320 --> 02:40:49,840
 okay, since some of you are living, yeah, better just continue on, so I think that in Garden by the Bay,

1838
02:40:49,840 --> 02:40:54,800
 Singapore, so just now the one is in Shanghai, in Singapore there's also some celebration in Garden

1839
02:40:54,800 --> 02:41:00,320
 by the Bay, okay, so for those of you if you're interested, you can go die with your friends,

1840
02:41:00,960 --> 02:41:02,480
 right, okay, so I'll see you next week,

1841
02:41:02,480 --> 02:41:08,160
 thank you,

1842
02:41:32,480 --> 02:41:34,800
 So the point is to use objects to create a shape.

1843
02:41:34,800 --> 02:41:37,080
 So it's like a background.

1844
02:41:37,080 --> 02:41:42,480
 Yes, so the background is not a object.

1845
02:41:42,480 --> 02:41:46,640
 So it becomes a shape.

1846
02:41:46,640 --> 02:41:48,880
 If you want to create a shape,

1847
02:41:48,880 --> 02:41:52,480
 you have to create an object.

1848
02:41:52,480 --> 02:41:57,480
 Then you have to create an estimation of an object.

1849
02:41:57,480 --> 02:41:58,840
 Basically, it's like this.

1850
02:41:58,840 --> 02:42:02,840
 So it's like this.

1851
02:42:02,840 --> 02:42:05,840
 It's actually to reduce its effect.

1852
02:42:05,840 --> 02:42:11,840
 After that, it also sells motion estimation and compensation.

1853
02:42:11,840 --> 02:42:13,840
 But like I said,

1854
02:42:13,840 --> 02:42:15,840
 the big or the big one is like this.

1855
02:42:15,840 --> 02:42:21,840
 The big one is because it has to be from the whole-ground option.

1856
02:42:21,840 --> 02:42:25,840
 So in general, there are some pixel values here.

1857
02:42:25,840 --> 02:42:28,840
 But because it's called a background,

1858
02:42:28,840 --> 02:42:31,840
 because it now has to be from the whole-ground option.

1859
02:42:31,840 --> 02:42:36,840
 So they don't have to use these other backgrounds.

1860
02:42:36,840 --> 02:42:39,840
 Because it's basically a whole-ground object.

1861
02:42:39,840 --> 02:42:41,840
 This whole-ground object is their background.

1862
02:42:41,840 --> 02:42:44,840
 So they remove these backgrounds.

1863
02:42:44,840 --> 02:42:49,840
 They use this thing to make it look like this.

1864
02:42:49,840 --> 02:42:50,840
 I know.

1865
02:42:50,840 --> 02:42:56,840
 Why don't we use the same value for the background?

1866
02:42:56,840 --> 02:43:00,840
 First, the background pixel values don't matter.

1867
02:43:00,840 --> 02:43:01,840
 They are full-ground.

1868
02:43:01,840 --> 02:43:02,840
 They don't have to use background values.

1869
02:43:02,840 --> 02:43:05,840
 So they don't have to use background values.

1870
02:43:05,840 --> 02:43:11,840
 Next, if you only use a part of the full-ground object,

1871
02:43:11,840 --> 02:43:13,840
 you have to make a padding.

1872
02:43:13,840 --> 02:43:16,840
 There are many ways to choose.

1873
02:43:16,840 --> 02:43:19,840
 This is just one of the options.

1874
02:43:19,840 --> 02:43:22,840
 So there is a good thing about this.

1875
02:43:22,840 --> 02:43:26,840
 It has a lower value.

1876
02:43:26,840 --> 02:43:29,840
 From a high level,

1877
02:43:29,840 --> 02:43:35,840
 it has to imagine that this video has some objects.

1878
02:43:35,840 --> 02:43:38,840
 I mean, it has this kind of sweetness.

1879
02:43:38,840 --> 02:43:40,840
 It has some kind of influence.

1880
02:43:40,840 --> 02:43:42,840
 So it has chosen this kind of sweetness.

1881
02:43:42,840 --> 02:43:44,840
 It has chosen other sweetness.

1882
02:43:44,840 --> 02:43:46,840
 From a high level,

1883
02:43:46,840 --> 02:43:50,840
 it has to have objects to fill it.

1884
02:43:50,840 --> 02:43:52,840
 So this is the highest level.

1885
02:43:52,840 --> 02:43:54,840
 It has to choose what to use.

1886
02:43:54,840 --> 02:43:57,840
 Like horizontal padding and vertical padding.

1887
02:43:57,840 --> 02:44:00,840
 So it has to have many ways to choose.

1888
02:44:00,840 --> 02:44:05,840
 Many coding sounds,

1889
02:44:05,840 --> 02:44:11,840
 they create a standard.

1890
02:44:11,840 --> 02:44:14,840
 Usually, the process is like this.

1891
02:44:14,840 --> 02:44:17,840
 At first, they have a call for both.

1892
02:44:17,840 --> 02:44:20,840
 Then they will have many groups from all over the world.

1893
02:44:20,840 --> 02:44:23,840
 Different people will have different ideas.

1894
02:44:23,840 --> 02:44:26,840
 Then they will have a text-based screen.

1895
02:44:26,840 --> 02:44:27,840
 They will say,

1896
02:44:27,840 --> 02:44:30,840
 there are some videos we have reviewed.

1897
02:44:30,840 --> 02:44:32,840
 If you have different groups,

1898
02:44:32,840 --> 02:44:34,840
 we will see who is the best.

1899
02:44:34,840 --> 02:44:36,840
 So you have a real result.

1900
02:44:36,840 --> 02:44:38,840
 Yes, you can do this.

1901
02:44:38,840 --> 02:44:40,840
 Thank you.

1902
02:44:40,840 --> 02:44:42,840
 There is a small question.

1903
02:44:42,840 --> 02:44:45,840
 This question is,

1904
02:44:45,840 --> 02:44:48,840
 what is the current situation?

1905
02:44:48,840 --> 02:44:51,840
 Okay, a friend asked,

1906
02:44:51,840 --> 02:44:54,840
 this keyboard doesn't need to be used.

1907
02:44:54,840 --> 02:44:59,840
 Basically, the smallest one is the smallest one.

1908
02:44:59,840 --> 02:45:01,840
 You can just imagine it.

1909
02:45:01,840 --> 02:45:06,840
 So this keyboard is a bit...

1910
02:45:06,840 --> 02:45:10,840
 Maybe the original meaning is a bit...

1911
02:45:10,840 --> 02:45:15,840
 Maybe you don't need to leave the keyboard.

1912
02:45:15,840 --> 02:45:17,840
 And in the test,

1913
02:45:17,840 --> 02:45:19,840
 what are the nine or five points?

1914
02:45:19,840 --> 02:45:20,840
 Generally speaking,

1915
02:45:20,840 --> 02:45:23,840
 the original position is the smallest one.

1916
02:45:23,840 --> 02:45:29,840
 You are with the same position.

1917
02:45:29,840 --> 02:45:32,840
 Because this is the real one.

1918
02:45:32,840 --> 02:45:34,840
 This is the one you have set up.

1919
02:45:34,840 --> 02:45:37,840
 The reference before is already moving.

1920
02:45:37,840 --> 02:45:40,840
 There is another question.

1921
02:45:40,840 --> 02:45:42,840
 This question is more...

1922
02:45:42,840 --> 02:45:45,840
 This kind of flow,

1923
02:45:45,840 --> 02:45:48,840
 we need to complete the task.

1924
02:45:48,840 --> 02:45:50,840
 So this is the truth.

1925
02:45:50,840 --> 02:45:54,840
 Because this is a question to judge.

1926
02:45:54,840 --> 02:45:57,840
 Because I think something is more important to you.

1927
02:45:57,840 --> 02:46:00,840
 Because when you first learn from the student,

1928
02:46:00,840 --> 02:46:02,840
 you can...

1929
02:46:02,840 --> 02:46:04,840
 So what?

1930
02:46:04,840 --> 02:46:06,840
 What is the best example?

1931
02:46:06,840 --> 02:46:11,840
 The best example is the test of the past few years.

1932
02:46:11,840 --> 02:46:15,840
 So why do I try to...

1933
02:46:15,840 --> 02:46:24,840
 try to give you more examples of these three points?

1934
02:46:24,840 --> 02:46:28,840
 This is indeed a bit difficult.

1935
02:46:28,840 --> 02:46:32,840
 But usually...

1936
02:46:32,840 --> 02:46:36,840
 This is indeed a bit difficult to answer.

1937
02:46:36,840 --> 02:46:40,840
 Because this is actually quite complicated.

1938
02:46:40,840 --> 02:46:44,840
 Especially the encoding of B-frame.

1939
02:46:44,840 --> 02:46:46,840
 It's a complicated one.

1940
02:46:46,840 --> 02:46:47,840
 So...

1941
02:46:47,840 --> 02:46:51,840
 It's like adding something on a basic frame.

1942
02:46:51,840 --> 02:46:55,840
 If you have a high level of understanding,

1943
02:46:55,840 --> 02:46:59,840
 you might think this is too complicated.

1944
02:46:59,840 --> 02:47:02,840
 I personally think this is a bit complicated.

1945
02:47:02,840 --> 02:47:04,840
 So I might not be able to answer this question.

1946
02:47:04,840 --> 02:47:06,840
 But the B-frame...

1947
02:47:06,840 --> 02:47:08,840
 I remember...

1948
02:47:08,840 --> 02:47:10,840
 If you look at the past few years,

1949
02:47:10,840 --> 02:47:13,840
 you will see that you have indeed gone through similar things.

1950
02:47:13,840 --> 02:47:16,840
 Because your examples have B-frame,

1951
02:47:16,840 --> 02:47:19,840
 which means that it might be...

1952
02:47:19,840 --> 02:47:21,840
 Okay, thank you.

1953
02:47:21,840 --> 02:47:24,840
 This is still a bit difficult.

1954
02:47:24,840 --> 02:47:26,840
 So sometimes...

1955
02:47:26,840 --> 02:47:28,840
 If you are in a test,

1956
02:47:28,840 --> 02:47:32,840
 you will often have to take some more serious measures.

1957
02:47:32,840 --> 02:47:34,840
 But...

1958
02:47:34,840 --> 02:47:36,840
 But sometimes...

1959
02:47:36,840 --> 02:47:39,840
 Because during the test,

1960
02:47:39,840 --> 02:47:42,840
 we have our own pressure.

1961
02:47:42,840 --> 02:47:43,840
 We can't...

1962
02:47:43,840 --> 02:47:45,840
 Every student is too good at it.

1963
02:47:45,840 --> 02:47:47,840
 We can't do it too hard.

1964
02:47:47,840 --> 02:47:49,840
 So sometimes we have to take some...

1965
02:47:49,840 --> 02:47:51,840
 A bit of a different approach.

1966
02:47:51,840 --> 02:47:53,840
 It's just that it's a bit less difficult.

1967
02:47:53,840 --> 02:47:54,840
 Okay, okay.

1968
02:47:54,840 --> 02:47:56,840
 So you are quite familiar with the B-frame.

1969
02:47:56,840 --> 02:47:58,840
 At this time...

1970
02:47:58,840 --> 02:48:00,840
 I will tell you more about the B-frame.

1971
02:48:00,840 --> 02:48:02,840
 Because this is a bit more difficult.

1972
02:48:02,840 --> 02:48:04,840
 Because...

1973
02:48:04,840 --> 02:48:07,840
 The professor left two years ago.

1974
02:48:07,840 --> 02:48:09,840
 And then...

1975
02:48:09,840 --> 02:48:11,840
 There was a period of time...

1976
02:48:11,840 --> 02:48:15,840
 I usually call it the first period.

1977
02:48:15,840 --> 02:48:17,840
 The first period.

1978
02:48:17,840 --> 02:48:18,840
 And then...

1979
02:48:18,840 --> 02:48:21,840
 There were some teachers who left again and again.

1980
02:48:21,840 --> 02:48:23,840
 So my content slowly increased from...

1981
02:48:23,840 --> 02:48:29,840
 I was the first to accept all the classes this year.

1982
02:48:29,840 --> 02:48:31,840
 So...

1983
02:48:31,840 --> 02:48:33,840
 You can say that...

1984
02:48:33,840 --> 02:48:37,840
 You can go to the test for more than two or three years.

1985
02:48:37,840 --> 02:48:39,840
 And then if you see those questions,

1986
02:48:39,840 --> 02:48:40,840
 you see that...

1987
02:48:40,840 --> 02:48:42,840
 This is the one that I have never been to.

1988
02:48:42,840 --> 02:48:43,840
 And then...

1989
02:48:43,840 --> 02:48:45,840
 That's the part of me.

1990
02:48:45,840 --> 02:48:48,840
 If you see that thing, you see that it's completely different.

1991
02:48:48,840 --> 02:48:50,840
 It's some completely...

1992
02:48:50,840 --> 02:48:51,840
 The awards this year.

1993
02:48:51,840 --> 02:48:53,840
 There are things that have never been published.

1994
02:48:53,840 --> 02:48:55,840
 You can understand that question.

1995
02:48:55,840 --> 02:48:57,840
 It's not from other...

1996
02:48:57,840 --> 02:48:59,840
 The questions that were taught by other professors.

1997
02:48:59,840 --> 02:49:02,840
 So those are the reference points of his experience.

1998
02:49:02,840 --> 02:49:04,840
 You don't have to think about it.

1999
02:49:04,840 --> 02:49:05,840
 Okay.

2000
02:49:05,840 --> 02:49:08,840
 But, Professor, you didn't mention that I had a part of the last class.

2001
02:49:08,840 --> 02:49:10,840
 Then what did we do?

2002
02:49:10,840 --> 02:49:11,840
 We went to the battle.

2003
02:49:11,840 --> 02:49:13,840
 Because last year...

2004
02:49:14,840 --> 02:49:16,840
 The last semester was like this.

2005
02:49:16,840 --> 02:49:19,840
 I was called the last semester of the class for nine weeks.

2006
02:49:19,840 --> 02:49:21,840
 Nine or ten weeks.

2007
02:49:21,840 --> 02:49:23,840
 There was another guest lecture.

2008
02:49:23,840 --> 02:49:25,840
 But that guest lecture...

2009
02:49:25,840 --> 02:49:27,840
 Because that part of it was not tested.

2010
02:49:27,840 --> 02:49:29,840
 So it became the last semester.

2011
02:49:29,840 --> 02:49:31,840
 That was...

2012
02:49:31,840 --> 02:49:33,840
 The last semester was actually me.

2013
02:49:33,840 --> 02:49:35,840
 It was me who was the first one.

2014
02:49:35,840 --> 02:49:36,840
 Okay.

2015
02:49:36,840 --> 02:49:37,840
 Now Professor.

2016
02:49:37,840 --> 02:49:38,840
 But I'll tell you.

2017
02:49:38,840 --> 02:49:40,840
 Because I have more classes this year.

2018
02:49:40,840 --> 02:49:42,840
 So there might be some new content.

2019
02:49:42,840 --> 02:49:46,840
 But basically, from these...

2020
02:49:46,840 --> 02:49:48,840
 Some of the subjects of the class...

2021
02:49:48,840 --> 02:49:50,840
 There might be some new...

2022
02:49:50,840 --> 02:49:51,840
 Okay, okay.

2023
02:49:51,840 --> 02:49:55,840
 So the next one is the new courses that you've been doing this year.

2024
02:49:55,840 --> 02:49:57,840
 Will you provide some...

2025
02:49:57,840 --> 02:49:59,840
 Practice subjects?

2026
02:49:59,840 --> 02:50:01,840
 If it's suitable, I'll provide them.

2027
02:50:01,840 --> 02:50:02,840
 Okay.

2028
02:50:02,840 --> 02:50:03,840
 Yes.

2029
02:50:03,840 --> 02:50:05,840
 I'm going to leave now.

2030
02:50:05,840 --> 02:50:07,840
 I usually don't speak Thai.

2031
02:50:07,840 --> 02:50:08,840
 Professor, you're still very good.

2032
02:50:08,840 --> 02:50:09,840
 I don't speak Thai.

2033
02:50:09,840 --> 02:50:11,840
 To be honest, this place...

2034
02:50:11,840 --> 02:50:14,840
 This place is not very well-known to students.

2035
02:50:14,840 --> 02:50:16,840
 I don't know if you understand it or not.

2036
02:50:16,840 --> 02:50:18,840
 In the world, in NTU...

2037
02:50:18,840 --> 02:50:21,840
 Every class has a bell curve.

2038
02:50:21,840 --> 02:50:22,840
 Yeah, yeah, yeah.

2039
02:50:22,840 --> 02:50:23,840
 It's a branch.

2040
02:50:23,840 --> 02:50:25,840
 So even if...

2041
02:50:25,840 --> 02:50:27,840
 For example, the question is very simple.

2042
02:50:27,840 --> 02:50:29,840
 But I think he's still trying to make it.

2043
02:50:29,840 --> 02:50:30,840
 It's not very clear.

2044
02:50:30,840 --> 02:50:32,840
 If that test is very difficult,

2045
02:50:32,840 --> 02:50:33,840
 I think it's very bad.

2046
02:50:33,840 --> 02:50:35,840
 But he still has to make adjustments.

2047
02:50:35,840 --> 02:50:36,840
 Okay.

2048
02:50:36,840 --> 02:50:38,840
 From that perspective,

2049
02:50:38,840 --> 02:50:40,840
 the difference is not too big.

2050
02:50:40,840 --> 02:50:41,840
 Okay.

2051
02:50:41,840 --> 02:50:42,840
 Thank you.

2052
02:50:42,840 --> 02:50:43,840
 Thank you.

2053
02:50:43,840 --> 02:50:44,840
 Thank you.

2054
02:50:44,840 --> 02:50:45,840
 Okay.

2055
02:50:45,840 --> 02:50:47,840
 I want to ask you something.

2056
02:50:47,840 --> 02:50:49,840
 I don't understand this question.

2057
02:50:49,840 --> 02:50:52,840
 If you find this place in NTU,

2058
02:50:52,840 --> 02:50:54,840
 or this place,

2059
02:50:54,840 --> 02:50:57,840
 you have to take half of the length of the search.

2060
02:50:57,840 --> 02:50:59,840
 Otherwise, it will be ruined.

2061
02:50:59,840 --> 02:51:02,840
 You can look at the glass.

2062
02:51:02,840 --> 02:51:04,840
 I didn't make any mistakes.

2063
02:51:04,840 --> 02:51:06,840
 So at the beginning,

2064
02:51:06,840 --> 02:51:08,840
 you can put it in the box.

2065
02:51:08,840 --> 02:51:09,840
 Okay.

2066
02:51:09,840 --> 02:51:11,840
 In the first step,

2067
02:51:11,840 --> 02:51:13,840
 in fact, the two-day algorithm search

2068
02:51:13,840 --> 02:51:16,840
 also has several different versions.

2069
02:51:16,840 --> 02:51:18,840
 We just use this textbook.

2070
02:51:18,840 --> 02:51:20,840
 This textbook's version is saying,

2071
02:51:20,840 --> 02:51:22,840
 in the first step, you find

2072
02:51:22,840 --> 02:51:25,840
 five points with a representative.

2073
02:51:25,840 --> 02:51:27,840
 And the five points with a representative

2074
02:51:27,840 --> 02:51:31,840
 usually tell you how to find the most effective

2075
02:51:31,840 --> 02:51:33,840
 and the most effective point.

2076
02:51:33,840 --> 02:51:35,840
 So the middle one is probably one.

2077
02:51:35,840 --> 02:51:37,840
 And if you divide the average,

2078
02:51:37,840 --> 02:51:39,840
 the other one is this one.

2079
02:51:39,840 --> 02:51:41,840
 So one, two, three, four.

2080
02:51:41,840 --> 02:51:42,840
 Okay.

2081
02:51:42,840 --> 02:51:44,840
 In fact, the other version,

2082
02:51:44,840 --> 02:51:46,840
 you have to find the nine points,

2083
02:51:46,840 --> 02:51:47,840
 which is reasonable.

2084
02:51:47,840 --> 02:51:48,840
 Or this version,

2085
02:51:48,840 --> 02:51:50,840
 you have to find the one, two, three, four points.

2086
02:51:50,840 --> 02:51:51,840
 So in the first step,

2087
02:51:51,840 --> 02:51:53,840
 you have to find the point

2088
02:51:53,840 --> 02:51:55,840
 where the small point is.

2089
02:51:55,840 --> 02:51:57,840
 Like L or L.

2090
02:51:57,840 --> 02:51:58,840
 Or the closest point,

2091
02:51:58,840 --> 02:52:00,840
 or the smallest point.

2092
02:52:00,840 --> 02:52:01,840
 Okay.

2093
02:52:01,840 --> 02:52:03,840
 So if we have found this point

2094
02:52:03,840 --> 02:52:05,840
 in these five points,

2095
02:52:05,840 --> 02:52:08,840
 the difference between the two is very reasonable.

2096
02:52:08,840 --> 02:52:11,840
 If you know that the difference between the two

2097
02:52:11,840 --> 02:52:12,840
 is reasonable,

2098
02:52:12,840 --> 02:52:14,840
 we should use that point to focus.

2099
02:52:14,840 --> 02:52:16,840
 We are looking for it again.

2100
02:52:16,840 --> 02:52:18,840
 So you have to focus on this point.

2101
02:52:18,840 --> 02:52:21,840
 You are looking for the other five points.

2102
02:52:21,840 --> 02:52:22,840
 Okay.

2103
02:52:22,840 --> 02:52:23,840
 One, two, three, four, five.

2104
02:52:23,840 --> 02:52:24,840
 Okay.

2105
02:52:24,840 --> 02:52:25,840
 In the first step,

2106
02:52:25,840 --> 02:52:26,840
 the algorithm search

2107
02:52:26,840 --> 02:52:28,840
 has only a few situations

2108
02:52:28,840 --> 02:52:31,840
 where you will find the range of the range.

2109
02:52:31,840 --> 02:52:32,840
 Okay.

2110
02:52:32,840 --> 02:52:33,840
 If this point,

2111
02:52:33,840 --> 02:52:34,840
 for example,

2112
02:52:34,840 --> 02:52:35,840
 one, two, three, four, five,

2113
02:52:35,840 --> 02:52:36,840
 the smallest point

2114
02:52:36,840 --> 02:52:38,840
 is not in the middle,

2115
02:52:38,840 --> 02:52:39,840
 in fact,

2116
02:52:39,840 --> 02:52:40,840
 we are not yet

2117
02:52:40,840 --> 02:52:42,840
 yet too confident

2118
02:52:42,840 --> 02:52:43,840
 or confident

2119
02:52:43,840 --> 02:52:46,840
 that we are close to the point.

2120
02:52:46,840 --> 02:52:48,840
 So we don't reduce

2121
02:52:48,840 --> 02:52:50,840
 the range of the search.

2122
02:52:50,840 --> 02:52:51,840
 I think you understand.

2123
02:52:51,840 --> 02:52:53,840
 Is it only in this center,

2124
02:52:53,840 --> 02:52:55,840
 in the center of our search,

2125
02:52:55,840 --> 02:52:57,840
 or we have already touched the border,

2126
02:52:57,840 --> 02:52:58,840
 I understand.

2127
02:52:58,840 --> 02:53:01,840
 So this border is the border of the whole range.

2128
02:53:01,840 --> 02:53:02,840
 Yes.

2129
02:53:02,840 --> 02:53:03,840
 I understand.

2130
02:53:03,840 --> 02:53:04,840
 Search window.

2131
02:53:04,840 --> 02:53:05,840
 What?

2132
02:53:05,840 --> 02:53:07,840
 Because in this world,

2133
02:53:07,840 --> 02:53:09,840
 this is the search window.

2134
02:53:09,840 --> 02:53:10,840
 This is the search window.

2135
02:53:10,840 --> 02:53:12,840
 Because this may have a big picture

2136
02:53:12,840 --> 02:53:14,840
 behind it.

2137
02:53:14,840 --> 02:53:17,840
 Because our definition is that

2138
02:53:17,840 --> 02:53:19,840
 our definition is that

2139
02:53:19,840 --> 02:53:21,840
 your motion factor

2140
02:53:21,840 --> 02:53:23,840
 should appear in the search window.

2141
02:53:23,840 --> 02:53:25,840
 Otherwise, it will be over.

2142
02:53:25,840 --> 02:53:26,840
 Yes.

2143
02:53:26,840 --> 02:53:27,840
 It's too big.

2144
02:53:27,840 --> 02:53:28,840
 OK.

2145
02:53:28,840 --> 02:53:30,840
 I just wanted to ask

2146
02:53:30,840 --> 02:53:33,840
 if this border is your border.

2147
02:53:33,840 --> 02:53:34,840
 Thank you.

2148
02:53:34,840 --> 02:53:36,840
 It's a very small border.

2149
02:53:36,840 --> 02:53:38,840
 I don't know what it is.

2150
02:53:38,840 --> 02:53:40,840
 Why is it so small?

2151
02:53:40,840 --> 02:53:42,840
 This is...

2152
02:53:42,840 --> 02:53:44,840
 I asked

2153
02:53:44,840 --> 02:53:46,840
 if there is a border

2154
02:53:46,840 --> 02:53:48,840
 and there is a...

2155
02:53:48,840 --> 02:53:52,840
 I still have a question.

2156
02:53:52,840 --> 02:53:54,840
 I think...

2157
02:53:54,840 --> 02:53:56,840
 I don't know.

2158
02:53:56,840 --> 02:53:58,840
 You said that

2159
02:53:58,840 --> 02:54:00,840
 this border is the border of the whole range.

2160
02:54:00,840 --> 02:54:02,840
 What is the definition

2161
02:54:02,840 --> 02:54:04,840
 of the border

2162
02:54:04,840 --> 02:54:06,840
 of the whole range?

2163
02:54:06,840 --> 02:54:07,840
 OK.

2164
02:54:07,840 --> 02:54:08,840
 Basically,

2165
02:54:08,840 --> 02:54:10,840
 the center of the scale

2166
02:54:10,840 --> 02:54:12,840
 of the M2

2167
02:54:12,840 --> 02:54:14,840
 is very simple.

2168
02:54:14,840 --> 02:54:15,840
 Yes.

2169
02:54:15,840 --> 02:54:16,840
 Because

2170
02:54:16,840 --> 02:54:18,840
 your words

2171
02:54:18,840 --> 02:54:20,840
 are about

2172
02:54:20,840 --> 02:54:22,840
 transmission,

2173
02:54:22,840 --> 02:54:24,840
 the condition of communication channel

2174
02:54:24,840 --> 02:54:26,840
 is sometimes

2175
02:54:26,840 --> 02:54:28,840
 moving.

2176
02:54:28,840 --> 02:54:30,840
 So,

2177
02:54:30,840 --> 02:54:32,840
 and because

2178
02:54:32,840 --> 02:54:34,840
 the first person,

2179
02:54:34,840 --> 02:54:36,840
 if the bandwidth

2180
02:54:36,840 --> 02:54:38,840
 is particularly high,

2181
02:54:38,840 --> 02:54:40,840
 and the bandwidth

2182
02:54:40,840 --> 02:54:42,840
 is particularly poor,

2183
02:54:42,840 --> 02:54:44,840
 we should provide different versions.

2184
02:54:44,840 --> 02:54:46,840
 Instead of providing

2185
02:54:46,840 --> 02:54:48,840
 one version,

2186
02:54:48,840 --> 02:54:50,840
 we can use the same way.

2187
02:54:50,840 --> 02:54:52,840
 Because the bandwidth is high,

2188
02:54:52,840 --> 02:54:54,840
 we should provide a better quality.

2189
02:54:54,840 --> 02:54:56,840
 Yes, this is channel.

2190
02:54:56,840 --> 02:54:58,840
 OK.

2191
02:54:58,840 --> 02:55:00,840
 So, the high-level scale

2192
02:55:00,840 --> 02:55:02,840
 of the M2

2193
02:55:02,840 --> 02:55:04,840
 and if we just

2194
02:55:04,840 --> 02:55:06,840
 set up different bitrate,

2195
02:55:06,840 --> 02:55:08,840
 the situation is

2196
02:55:08,840 --> 02:55:10,840
 if we

2197
02:55:10,840 --> 02:55:12,840
 send a transmitter

2198
02:55:12,840 --> 02:55:14,840
 to the receiver,

2199
02:55:14,840 --> 02:55:16,840
 usually the communication link

2200
02:55:16,840 --> 02:55:18,840
 is not just one line.

2201
02:55:18,840 --> 02:55:20,840
 You have to pass through a lot of this route.

2202
02:55:20,840 --> 02:55:21,840
 OK.

2203
02:55:21,840 --> 02:55:23,840
 You can go from here to the first route,

2204
02:55:23,840 --> 02:55:25,840
 to the second route, to the third route.

2205
02:55:25,840 --> 02:55:27,840
 You can imagine there are many links.

2206
02:55:27,840 --> 02:55:29,840
 And then, the link of the bandwidth

2207
02:55:29,840 --> 02:55:30,840
 is high,

2208
02:55:30,840 --> 02:55:32,840
 the link is bandwidth low.

2209
02:55:32,840 --> 02:55:34,840
 For example, if I send you two

2210
02:55:34,840 --> 02:55:36,840
 sections, the first and the second sections,

2211
02:55:36,840 --> 02:55:38,840
 both are very good,

2212
02:55:38,840 --> 02:55:40,840
 then I can send you

2213
02:55:40,840 --> 02:55:42,840
 a base plus two parts.

2214
02:55:42,840 --> 02:55:44,840
 But if it is

2215
02:55:44,840 --> 02:55:46,840
 the first section is very good,

2216
02:55:46,840 --> 02:55:48,840
 the second section is very low,

2217
02:55:48,840 --> 02:55:50,840
 then I can't send

2218
02:55:50,840 --> 02:55:52,840
 a base

2219
02:55:52,840 --> 02:55:54,840
 and a transmitter.

2220
02:55:54,840 --> 02:55:56,840
 It's just a base layer.

2221
02:55:56,840 --> 02:55:58,840
 So, it's the same as the second section?

2222
02:55:58,840 --> 02:56:00,840
 Yes, a little different.

2223
02:56:00,840 --> 02:56:02,840
 The first one is just...

2224
02:56:02,840 --> 02:56:04,840
 It's almost the same.

2225
02:56:04,840 --> 02:56:06,840
 The second one is to change the time.

2226
02:56:06,840 --> 02:56:08,840
 Yes, yes, yes.

2227
02:56:08,840 --> 02:56:10,840
 To change the different links.

2228
02:56:10,840 --> 02:56:12,840
 Thank you.

2229
02:56:12,840 --> 02:56:14,840
 Thank you.

2230
02:56:14,840 --> 02:56:16,840
 You're welcome.

2231
02:56:16,840 --> 02:56:18,840
 Let me ask you about the question.

2232
02:56:18,840 --> 02:56:20,840
 We are...

2233
02:56:20,840 --> 02:56:22,840
 We are...

2234
02:56:22,840 --> 02:56:24,840
 Are you my...

2235
02:56:24,840 --> 02:56:26,840
 No, no. I mean,

2236
02:56:26,840 --> 02:56:28,840
 the work, the three-part...

2237
02:56:28,840 --> 02:56:30,840
 The second one is

2238
02:56:30,840 --> 02:56:32,840
 about the impact of the AI

2239
02:56:32,840 --> 02:56:34,840
 on the image and the video.

2240
02:56:34,840 --> 02:56:35,840
 Yes.

2241
02:56:35,840 --> 02:56:36,840
 And then, both of us

2242
02:56:36,840 --> 02:56:38,840
 will discuss the question.

2243
02:56:38,840 --> 02:56:40,840
 Two...

2244
02:56:40,840 --> 02:56:42,840
 Basically,

2245
02:56:42,840 --> 02:56:44,840
 from my point of view,

2246
02:56:44,840 --> 02:56:46,840
 I will say...

2247
02:56:46,840 --> 02:56:48,840
 Because

2248
02:56:48,840 --> 02:56:50,840
 this is the first assignment.

2249
02:56:50,840 --> 02:56:52,840
 So, in the first assignment,

2250
02:56:52,840 --> 02:56:54,840
 there are not too many things

2251
02:56:54,840 --> 02:56:56,840
 that we have learned.

2252
02:56:56,840 --> 02:56:58,840
 In the original,

2253
02:56:58,840 --> 02:57:00,840
 if I had some technical issues,

2254
02:57:00,840 --> 02:57:02,840
 I would guess that each student

2255
02:57:02,840 --> 02:57:04,840
 would have the same idea.

2256
02:57:04,840 --> 02:57:06,840
 So, the idea was

2257
02:57:06,840 --> 02:57:08,840
 to let you

2258
02:57:08,840 --> 02:57:10,840
 discuss this

2259
02:57:10,840 --> 02:57:12,840
 with the AI.

2260
02:57:12,840 --> 02:57:14,840
 You might find something interesting.

2261
02:57:14,840 --> 02:57:16,840
 So, the topic is

2262
02:57:16,840 --> 02:57:18,840
 about the open-source.

2263
02:57:18,840 --> 02:57:20,840
 You have to find...

2264
02:57:20,840 --> 02:57:22,840
 Basically, using the AI

2265
02:57:22,840 --> 02:57:24,840
 in any

2266
02:57:24,840 --> 02:57:26,840
 image or video production,

2267
02:57:26,840 --> 02:57:28,840
 you will find some examples

2268
02:57:28,840 --> 02:57:30,840
 like image production,

2269
02:57:30,840 --> 02:57:32,840
 image production,

2270
02:57:32,840 --> 02:57:34,840
 and

2271
02:57:34,840 --> 02:57:36,840
 some super-resolution.

2272
02:57:36,840 --> 02:57:38,840
 There are many...

2273
02:57:38,840 --> 02:57:40,840
 If you have no idea,

2274
02:57:40,840 --> 02:57:42,840
 you can check the PPC.

2275
02:57:42,840 --> 02:57:44,840
 It will give you some examples.

2276
02:57:44,840 --> 02:57:46,840
 And then, I would like to ask

2277
02:57:46,840 --> 02:57:48,840
 if the question is

2278
02:57:48,840 --> 02:57:50,840
 whether we are focused on innovation

2279
02:57:50,840 --> 02:57:52,840
 or specifically,

2280
02:57:52,840 --> 02:57:54,840
 not the whole question.

2281
02:57:54,840 --> 02:57:56,840
 In fact,

2282
02:57:56,840 --> 02:57:58,840
 I don't say that we are focused on innovation.

2283
02:57:58,840 --> 02:58:00,840
 I just want you to

2284
02:58:00,840 --> 02:58:02,840
 discuss these issues.

2285
02:58:02,840 --> 02:58:04,840
 And the main point is

2286
02:58:04,840 --> 02:58:06,840
 that we are focused on challenges.

2287
02:58:06,840 --> 02:58:08,840
 Challenges.

2288
02:58:08,840 --> 02:58:10,840
 So, it's not about you.

2289
02:58:10,840 --> 02:58:12,840
 Because it's a business,

2290
02:58:12,840 --> 02:58:14,840
 it's not about you being a very complete person.

2291
02:58:14,840 --> 02:58:16,840
 But, as you said,

2292
02:58:16,840 --> 02:58:18,840
 the correct way is

2293
02:58:18,840 --> 02:58:20,840
 you can start

2294
02:58:20,840 --> 02:58:22,840
 using the Cheshire BT

2295
02:58:22,840 --> 02:58:24,840
 to find some possible issues.

2296
02:58:24,840 --> 02:58:26,840
 And then, based on these issues,

2297
02:58:26,840 --> 02:58:28,840
 you can read the relevant documents

2298
02:58:28,840 --> 02:58:30,840
 and get a deeper understanding.

2299
02:58:30,840 --> 02:58:32,840
 Cheshire BT is not only

2300
02:58:32,840 --> 02:58:34,840
 a high-resonation.

2301
02:58:34,840 --> 02:58:36,840
 It can find some related issues.

2302
02:58:36,840 --> 02:58:38,840
 It looks like it's true.

2303
02:58:38,840 --> 02:58:40,840
 But it's not.

2304
02:58:40,840 --> 02:58:42,840
 But it can be a...

2305
02:58:42,840 --> 02:58:44,840
 In general,

2306
02:58:44,840 --> 02:58:46,840
 the Cheshire BT is more reliable.

2307
02:58:46,840 --> 02:58:48,840
 You can use it

2308
02:58:48,840 --> 02:58:50,840
 to understand the challenges.

2309
02:58:50,840 --> 02:58:52,840
 What kind of challenges are there?

2310
02:58:52,840 --> 02:58:54,840
 We will start from the

2311
02:58:54,840 --> 02:58:56,840
 reading the relevant

2312
02:58:56,840 --> 02:58:58,840
 rules and then

2313
02:58:58,840 --> 02:59:00,840
 to sort out

2314
02:59:00,840 --> 02:59:02,840
 your own thoughts

2315
02:59:02,840 --> 02:59:04,840
 or to sort out

2316
02:59:04,840 --> 02:59:06,840
 other thoughts.

2317
02:59:06,840 --> 02:59:08,840
 Do you have any advice for the user?

2318
02:59:08,840 --> 02:59:10,840
 I do.

2319
02:59:10,840 --> 02:59:12,840
 I have.

2320
02:59:12,840 --> 02:59:14,840
 Our question

2321
02:59:14,840 --> 02:59:16,840
 is about personal work

2322
02:59:16,840 --> 02:59:18,840
 or other things.

2323
02:59:18,840 --> 02:59:20,840
 I don't know that question.

2324
02:59:20,840 --> 02:59:22,840
 I just call it an abstract.

2325
02:59:22,840 --> 02:59:24,840
 Usually, we can only

2326
02:59:24,840 --> 02:59:26,840
 call it an abstract or summary bar.

2327
02:59:26,840 --> 02:59:28,840
 So,

2328
02:59:28,840 --> 02:59:30,840
 it's clear in the world.

2329
02:59:30,840 --> 02:59:32,840
 It must be a separate student.

2330
02:59:32,840 --> 02:59:34,840
 Okay.

2331
02:59:58,840 --> 03:00:00,840
 Thank you.

